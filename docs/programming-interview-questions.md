# 2023 年 50+最佳编程面试问答

> 原文：<https://hackr.io/blog/programming-interview-questions>

像亚马逊、谷歌和微软这样的大公司总是在寻找加入他们队伍的编程和软件开发人才。因此，为了在上述知名公司获得有利可图的机会，你需要积累尽可能多的知识。

为了减轻你的努力，我们已经编制了一个顶级编程面试问题的列表，这是任何打算问[编程面试问题](https://hackr.io/blog/programming-interview-questions)的人必须知道的。

## 顶级编程面试问题和答案

所以，没有任何进一步的麻烦，我们开始吧:

#### **问题:请说明你所理解的计算机编程。**

**答:**计算机编程又称为编码或编程，是通过某种编程语言将一种算法编码成符号，通常是计算机程序，以便计算机执行的过程。

每种编程语言都包含一组指令，供计算机执行一组任务。编程是一个复杂的过程，包括设计算法、用编程语言编写算法代码、调试程序、维护和更新代码。

#### 问题:你能列举并解释计算机程序执行过程中可能出现的各种错误吗？

**答:**计算机程序执行过程中会出现三种类型的错误。这些是:

*   **逻辑错误—**这发生在计算机程序执行错误逻辑的情况下。因为没有为这些类型的编程错误生成报告，所以它们是最难处理的。
*   **运行时错误—**当程序包含非法操作时发生。例如，将一个数除以 0。这些是程序执行过程中唯一立即显示的错误。出现运行时错误时，程序停止执行，并显示诊断消息。
*   **语法错误—**当违反正在使用的编程语言的一条或多条语法规则时，就会出现语法错误。这种错误是在编译时检测到的。

#### **问题:请解释一个算法。它的一些重要特征是什么？**

**答:**算法可以定义为一组有限的步骤，当遵循这些步骤时，有助于完成特定的任务。算法的重要特征是清晰、高效和有限。

#### **问题:你对维护和更新一个计算机程序的理解是什么？**

**答:**计算机程序的维护和更新过程在成功安装后开始。虽然程序维护是监控计算机程序的缺陷和错误的连续过程，但更新计算机程序意味着随着时间的推移通过较小和较大的改变使其变得更好。

#### 问题:请简要说明变量。

**答:**变量用于存储程序的输入以及程序执行过程中的计算结果。这些实际上是命名的内存位置。存储在变量中的值可以在程序执行期间改变。

#### **问题:每种编程语言都有保留字。它们是什么？举几个例子。**

**答案:**保留字，也称关键字，是在特定的编程语言中，具有预定义含义的字。这些保留字不能用于或重新定义为其他目的服务。以下是一些保留字的示例:

*   **C–**break、case、char、default、else、float、if 和 int
*   **Java–**抽象、布尔、捕捉、类、常量、双精度、枚举、最终、实现、实例、抛出、瞬态和易变
*   **Python—**and、assert、continue、def、del、global、not、lambda、raise 和 yield

#### **问题:你对循环的理解是什么？简要解释各种类型的循环。**

**答:**循环是程序设计中的一种结构，它可以将一组定义好的语句重复设定的次数，或者直到满足特定的条件。有三种重要的循环类型:

*   **FOR…NEXT Loop–**当您事先知道循环要重复的总次数时，这是最有效的循环
*   **WHILE……WEND Loop–**它不断重复某个特定动作，直到相关条件变为假。当重复的总次数未知时，这个循环特别有用。
*   **嵌套循环–**当一个循环在一个循环内部使用时，它被称为嵌套循环

#### 问题:请解释计划文档。为什么重要？

**答:**程序文档是对特定计算机程序的算法、编码方法、设计、测试和正确使用的书面描述。对于那些每天使用程序的人来说，它是有价值的，对于那些打算修正、修改和更新计算机程序的程序员来说也是有价值的。

对于一个认真的程序员来说，可靠的文档是必须的。完整文档的可用性不仅有助于跟踪计算机应用程序的各个方面，还有助于提高计算机应用程序的整体质量。程序文档的主要焦点是开发、维护和向其他开发者传递知识。

#### **问题:什么是常数？说明他们的类型。**

**答案:**常量是一个编程实体，它的值在程序执行过程中不能改变或修改。常量有两种主要类型:

*   **数字常量—**包括整数、单精度和双精度数字。例如，22、24、-898、4.5 和 73.45
*   **字符串常量—**包括一系列用双引号括起来的字母数字字符。字符串常量的最大长度是 255 个字符。例如，“西姆拉”，“我爱你”，“橙色是新的黑色”

#### **问题:请解释一下运营商。**

**答:**运算符用于在计算机程序中对数据执行某些操作。这些用符号来表示。例如，/代表数学除法，而*代表乘法。有 4 种主要类型的运算符:

*   **算术—**用于执行数学运算
*   **赋值—**用于存储变量中的计算结果、字符串和值
*   **逻辑-**用于允许计算机程序根据多个条件做出决定。换句话说，逻辑运算符允许将简单的条件组合成更复杂的条件
*   **Relational—**用于定义或测试两个实体之间的某种关系。这些运算符计算为 true 或 false，并产生非零值

#### 问:你能解释一下数组吗？

**答案:**数组是一种编程结构，是几个相同类型的数据值的集合。就内存而言，数组是一组存储相同类型数据的连续内存位置。

#### **问题:你所理解的子程序是什么？**

**答:**一组可在计算机程序中任何地方使用的独立语句被称为子程序。一旦子程序成功地执行了它的预定任务，它就把控制权返回给叫做子程序的那部分程序。

#### **问题:解释低级和高级编程语言。还有，举几个例子。**

**回答:**任何不提供计算机指令集架构的泛化的编程语言都是低级编程语言。汇编语言和机器语言是低级编程语言的两个典型例子。

从计算机指令集体系结构中提供高度概括的编程语言被称为高级编程语言。通常，高级编程语言具有类似自然语言的元素，以使程序开发更容易。

高级编程语言的另一个定义是独立于运行它的系统的底层处理器。C++、Java 和 Python 是一些最流行的高级编程语言。

#### **问题:你所理解的机器码是什么？**

**答案:**机器码是一种低级编程语言。与高级编程语言不同，高级编程语言通过编译器将高级代码转换为机器代码以供执行，微处理器直接处理机器代码，而不进行这样的转换。

#### 问题:你了解建模语言吗？举几个例子。

**答:**任何可用于以一套可靠的规则所确定的安排来表达信息或知识或系统的人工语言，都称为建模语言。

同一套规则也用于解释建模语言结构的组件的含义。下面是一些建模语言的例子:

*   业务流程建模符号
*   扩展企业建模语言
*   流程图
*   杰克逊结构化程序设计
*   系统建模语言
*   统一建模语言

#### **问题:请解释一下软件测试。我们为什么需要它？**

**回答:**与编程一样，软件测试是任何软件开发生命周期模型的重要方面，无论是传统的瀑布模型还是现代的[快速应用开发(RAD)模型](https://hackr.io/blog/rapid-application-development-model)。

在软件测试的过程中，软件在一定的条件下被测试，以检查软件的质量。测试一个计算机程序的另一个重要动机是评估它是否成功地提供了一个好的用户体验。其他一些原因包括:

*   检查改进
*   确保正常/预期工作
*   满足用户需求

#### 问:你所说的计算机程序的“测试版”是什么意思？

**答:**计算机程序或软件的最佳版本是尚未准备好公开发布的版本，旨在在收到 beta 测试的用户反馈后进行修改。

#### 问题:你能解释一下自顶向下的设计方法吗？

**答:**自顶向下的设计方法是一种用于分析软件的方法论。不是把一个问题作为一个整体来处理，而是先把它分成许多子问题。然后，它们中的每一个都被单独解决。然后将这些解决方案组合起来，以获得最佳解决方案。

#### **问题:你所理解的程序实现是什么？**

**答:**成功完成计算机程序的软件测试后，需要在目标计算机上安装并投入运行。安装和设置最终用户要使用的计算机程序的过程被称为程序实现。

#### **问题:请解释程序执行。**

**答案:**程序执行是计算机执行程序固有指令的过程。在执行之前，需要将计算机程序加载到计算机的存储器(ram)中。

#### **问题:什么是编译器？**

**答案:**编译器是将一种编程语言的书面代码翻译成另一种语言的计算机程序。通常，编译器指的是将属于高级编程语言的源代码翻译成低级编程语言以创建可执行程序的程序。

**答案:**在测试一个计算机程序的过程中，会发现一些问题。这些被称为错误和缺陷。调试就是纠正它们的过程。换句话说，调试是纠正在实现的代码中发现的错误的过程。

**答案:**任何典型的计算机程序都包含成百上千个 LOC。添加注释是一种简化他人检查或查找代码中某些内容的体验的方式。

#### 问题:你能列举一些编码的最佳实践吗？

**回答:**以下是一些让编程变得高效的编码最佳实践:

*   遵守干燥原则
*   遵循一些容易记住的命名约定
*   尽可能让代码简单明了
*   限制一行代码的长度
*   经常使用注释
*   使用一致的缩进
*   无论何时何地，尽可能避免深度嵌套

#### **问题:你能解释一下干燥的原理吗？**

**回答:**干代表不要重复自己。这是一个软件开发原则，旨在减少软件模式的重复。为了实现这一点，要么需要用抽象代替重复的软件模式，要么必须使用数据规范化。

#### **问题:违反干原则的行为叫什么？它们通常在哪里被发现？**

答:它们被称为湿溶液。虽然 WET 通常代表把所有东西都写两遍，但在某些情况下，它也可能意味着我们喜欢打字或浪费每个人的时间。多层架构中通常采用湿式解决方案。

#### **问题:请解释一下冒泡排序？**

**答案:**冒泡排序是一种简单的排序算法，在这种算法中，一个数据结构中的相邻元素，比如一个数组，被不断地比较，直到我们得到正确的顺序。只有当被比较的元素顺序错误时，它们才会被交换。

冒泡排序允许较小的值“冒泡”到列表的顶部，因此得名。它也被称为下沉排序，因为较大的值“下沉”到底部。看看 C 中的[冒泡排序](https://hackr.io/blog/bubble-sort-in-c)是如何工作的。

#### 问题:请解释一下数据结构。

**答:**数据结构是一种组织和操作数据的特殊方式。它允许高效访问和修改数据。

数据结构也可以定义为数据、适用于它们的功能以及它们之间的关系的集合。数组、链表、堆、图和栈是数据结构的一些例子。

#### 问题:利用数据结构的领域有哪些？

**答:**任何涉及数据的地方都需要数据结构。然而，一些值得注意的例子是:

*   [人工智能](https://hackr.io/tutorials/learn-artificial-intelligence-ai?ref=blog-post)
*   编译程序设计
*   数据库管理
*   制图法
*   数值分析
*   操作系统
*   统计分析

#### **问题:你通过排序理解了什么？说出一些流行的排序技术。**

**答:**排序是将数组的元素按升序或降序排列的过程。一些流行的排序技术有:

#### 问题:请解释一下二分搜索法。使用二分搜索法的最佳场景是什么？

**答:**[二分搜索法](https://hackr.io/blog/binary-search-in-c)最适用于所有元素都已经排序的列表。二分搜索法从列表中间开始搜索。

如果中间的元素不是目标元素，那么它继续搜索列表的下半部分或上半部分。该过程不断重复，直到找到所需的元素。

#### 问:你将如何引用一维数组中的所有元素？

**答:**我们需要使用一个索引循环来引用一维数组中的所有元素。计数器从 0 开始，直到数组大小减 1。因此，通过使用循环计数器作为数组下标，可以按顺序引用所有元素。

#### **问题:你对后进先出和先进先出的理解是什么？**

**回答:** LIFO 和 FIFO 是两种最流行的访问、检索和存储数据的形式。LIFO 代表后进先出。这意味着在这种方法中，首先检索最新存储的数据。在堆栈中遵循这种方法。

FIFO 代表先进先出，与 LIFO 相反。这里，最早存储的数据是最先检索的数据。队列中遵循 FIFO 方法。

#### **问题:能解释一下多维数组吗？**

**回答:**常规阵列只有一个索引。多维数组是具有多个索引的数组。它用于一维索引不充分的情况。

#### **问题:请解释一张图。**

**答案:**一种有一组有序对的数据结构叫做图。这些有序对也称为弧或边。它们用于连接节点，节点是存储和检索数据的地方。

#### 问题:线性和非线性数据结构有什么区别？

**答案:**在线性数据结构中，数据元素是相邻放置的。数组、链表、队列和堆栈是线性数据结构的一些例子。

在非线性数据结构中，数据元素可以连接到两个以上的数据元素。非线性数据结构的例子是图和树。

#### **问题:请解释一个 AVL 树。**

**答案:**总是部分平衡的二叉查找树称为 AVL 树。这是第一个以这种方式设计的数据结构。余额是子树距根的高度差。

#### **问题:我们为什么要用霍夫曼算法？**

**答案:**对于从给定的权值扩展出最小加权路径长度的二叉树，我们使用霍夫曼算法。它使用包含每个数据元素的总次数的表格。

#### **问题:请解释一下斐波那契搜索。**

**答案:**斐波那契搜索是一种适用于排序数组的搜索算法。它使用分治法来大大减少到达目标元素所需的时间。

#### 问题:递归算法是如何工作的？

**答案:**递归算法把一个问题分成更小的、易于管理的子问题。在处理一个子问题之后，从一个递归中获得的输出成为后续递归过程的输入。

#### **问题:什么是递归函数？**

**答案:**调用自身的函数称为递归函数。它基于终止条件并使用堆栈。这种现象被称为递归。

#### 问题:请解释动态内存分配如何帮助管理数据？

**答:**动态内存分配有助于存储简单的结构化数据类型。此外，它有助于组合单独分配的结构块，以形成可根据需要扩展或收缩的复合结构。

#### **问题:无效和作废的区别是什么？**

**回答:【NULL 表示值，VOID 表示数据类型标识符。具有空值的变量表示空值。没有初始大小的指针使用 VOID 来标识。**

#### **问题:请解释变量声明如何影响内存分配。**

**答:**特定的数据类型是用变量声明定义的。要分配的内存总量取决于声明的变量所属的数据类型。

#### **问题:请解释一下数据抽象。**

**回答:**数据抽象有助于将复杂的数据问题分解成易于管理的子问题。在数据抽象之后，指定第一数据对象和要在其上执行的操作。如何将数据对象存储在存储器中成为次要任务。

#### **问题:检查字符串是否为回文的代码是什么？**

**答案:**

```
#include <string.h>
int main()
{
    char a[1000];  
    int i,n,b=0;
    printf("Enter  the string : ");
    gets(a);
    n=strlen(a);
    for(i=0;i<n/2;i++)  
    {
   if(s[i]==a[n-i-1])
   b++;
   }
   if(b==i)
       printf("string is palindrome");
    else
        printf("string is not palindrome");
    return 0;
}
```

**输出:**

```
Enter the string: madam
String is palindrome
```

#### 问:写一个从字符串中移除任意给定字符的方法？

**答案:**

```
public class RemoveChar {  
    public static void main(String[] args) {  
              String str = "How are you"; 
              System.out.println(charRemoveAt(str, 7));  
           }  
           public static String charRemoveAt(String str, int p) {  
              return str.substring(0, p) + str.substring(p + 1);  
           }  
} 
```

**结果:**

```
How are you
```

#### 问题:打印所有排列的字符串的递归方式？

**答案:**

**递归方式:**

```
public class ABC {
    // Function to print all the permutations of str
    static void printPerm(String str, String ans)
    {
        // If string is empty
        if (str.length() == 0) {
            System.out.print(ans + " ");
            return;
        }
        for (int i = 0; i < str.length(); i++) {
            // ith character of str
            char ch = str.charAt(i);
            // Rest of the string after excluding 
            // the ith character
            String ros = str.substring(0, i) + 
                         str.substring(i + 1);
            // Recurvise call
            printPerm(ros, ans + ch);
        }
    }
    // Driver code
    public static void main(String[] args)
    {
        String s = "abb";
        printPermutn(s, "");
    }
}
```

**输出:**

```
abb abb bab bba bab bba
```

#### **问题:写一个函数，找出给定字符串中最长的回文？**

**答案:**

```
public class Demo {
public static void main(String[] args) {
     Demo lp = new Demo();
     String pal = lp.LongPalindrome("bananas");
        System.out.println("" + pal);    
     pal = lp.LongPalindrome("abaradab121");
        System.out.println("" + pal);
}
public String LongPalindrome(String s) {
     // Validations
     if (s.isEmpty()) {
         return "Please enter a String";
     }
     if (s.length() == 1) {
         return s;
     }
     // Validations end
     // Start with one char (starting) as a longest palindrome
     String longest = s.substring(0, 1);
     for (int i = 0; i < s.length(); i = i+1) {
         // get longest palindrome for odd length (center is i)
         String tmp = checkForEquality(s, i, i);
         if (tmp.length() > longest.length()) {
             longest = tmp;
         }
         // get longest palindrome for even length (center is i, i+1)
         tmp = checkForEquality(s, i, i + 1);
         if (tmp.length() > longest.length()) {
             longest = tmp;
         }
     }
     return longest;
}
public String checkForEquality(String s, int begin, int end) {
     while (begin >= 0 && end <= s.length() - 1 && s.charAt(begin) == s.charAt(end)) {
         begin--;
         end++;
     }
return s.substring(begin + 1, end);
}
}
```

#### **问题:如何在 Java 中将数值字符串转换成 int？**

**答案:**

```
public class StringToInteger { public static void main(String args[])
{ 
String integer = "237"; 
int number = new Integer(integer); 
System.out.println("Integer created from String in Java : " + number);  number = Integer.parseInt(integer); 
System.out.println("String to int using parseInt() : " + number);  number = Integer.valueOf(integer); 
System.out.println("String to int Conversion example using valueOf : " + number); 
String negative = "-237"; 
System.out.println("Converting negative String to int in Java");
System.out.println("String to Integer Constructor Example :" + new Integer(negative)); 
System.out.println("String to Integer parseInt Example : " + Integer.parseInt(negative)); 
System.out.println("String Integer valueOf Example : " + Integer.valueOf(negative));
 }
 }
```

**结果输出:**

```
Integer created from String in Java: 237 
String to int using parseInt() : 237
String to int Conversion example using valueOf : 237 
Converting negative String to int in Java 
String to Integer Constructor Example : -237 
String to Integer parseInt Example : -237
String Integer valueOf Example : -237
```

#### **问题:为什么 String 在 Java 中是 final？**

**回答:**Java 中 string 是 final 主要有两个原因，以保证性能和安全性。如果字符串是可变的，那么它很容易被攻击，因为字符串被用于数据库 URL 和网络连接。如果字符串是不可变的，那么就没有同步问题，因为它将使字符串线程安全。

#### **问题:如何在 Java 中去除数组中的重复元素？**

**答案:**

```
import java.io.*;
import java.util.*;   
class DupElements 
{ 
    static int duplicate(int[] arr, int n)
    {
        // Find array sum and subtract sum 
        // first n-1 natural numbers from it 
        // to find the result.
        int sum = 0;
        for (int i = 0; i < n; i++)
            sum += arr[i];
        return sum - (((n - 1) * n) / 2); 
    }
    // Driver code
    public static void main(String args[]) 
    {
        int[] arr = { 9, 8, 2, 6, 11, 8, 18, 3, 4, 5 };
        int n = arr.length;
        System.out.println(duplicate(arr, n));
    }
}
```

**输出:**

```
8
```

#### **问题:如何在 Java 中检查一棵树是否平衡？**

**答案:**

```
class NodeTree {
    int data;
    Node left, right;
    Node(int d)
    {
        data = d;
        left = right = null;
    }
}
class BinaryTree {
    NodeTree root;
    /* Returns true if binary tree with root as root is height-balanced */
    boolean isBalanced(NodeTree node)
    {
        int lh; /* for height of left subtree */
        int rh; /* for height of right subtree */
        /* If tree is empty then return true */
        if (node == null)
            return true;
        /* Get the height of left and right sub trees */
        lh = height(node.left);
        rh = height(node.right);  
        if (Math.abs(lh - rh) <= 1
            && isBalanced(node.left)
            && isBalanced(node.right))
            return true;
        /* If we reach here then tree is not height-balanced */
        return false;
    }    
    int height(Node node)
    {
        /* base case tree is empty */
        if (node == null)
            return 0; 
        /* If tree is not empty then height = 1 + max of left
         height and right heights */
        return 1 + Math.max(height(node.left), height(node.right));
    }  
    public static void main(String args[])
    {
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);
        tree.root.left.left.left = new Node(8);
        if (tree.isBalanced(tree.root))
            System.out.println("Tree is balanced");
        else
            System.out.println("Tree is not balanced");
    }
}
```

**输出:**

```
Tree is not balanaced
```

#### **问题:写一个程序，找出直到给定数的所有质数？**

**答案:**

```
public class ABC {
    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        // Declare the variables
        int a, b, i, j, flag;
        System.out.printf("Enter lower bound of the interval: ");
        a = sc.nextInt(); // Take input
        System.out.printf("\nEnter upper bound of the interval: ");
        b = sc.nextInt(); // Take input 
        // Print display message
        System.out.printf("\nPrime numbers between %d and %d are: ", a, b); 
        for (i = a; i <= b; i++) {
            if (i == 1 || i == 0)
                continue;
            flag = 1;
            for (j = 2; j <= i / 2; ++j) {
                if (i % j == 0) {
                    flag = 0;
                    break;
                }
            }
            if (flag == 1)
                System.out.println(i);
        }
    }
}
```

**输出:**

```
Enter lower bound of the interval: 2
Enter upper bound of the interval: 10
Prime numbers between 2 and 10 are:  3 5 7 
```

#### 问题:写一个程序找出两个矩形 R1 和 R2 是否重叠？

**答案:**

```
class OverlapRect {  
   static class RectPoint { 
        int x, y;
    } 
// Returns true if two rectangles (a1, b1) and (a2, b2) overlap 
 static  boolean doOverlap(Point a1, Point b1, Point a2, Point b2) {
        // If one rectangle is on left side of other 
        if (a1.x > b2.x || a2.x > b1.x) {
            return false;
        }  
        // If one rectangle is above other 
        if (a1.y < b2.y || a2.y < b1.y) {
            return false;
        }
        return true;
    }
    public static void main(String[] args) {
        Point a1 = new Point(),
        b1 = new Point(),
        a2 = new Point(),
        b2 = new Point();
        a1.x=0;a1.y=10; b1.x=10;b1.y=0;
        a2.x=5;a2.y=5; b2.x=15;b2.y=0;
        if (doOverlap(a1, b1, a2, b2)) {
            System.out.println("Rectangles Overlap");
        } else {
            System.out.println("Rectangles Don't Overlap");
        }
    }
}
```

**输出:**

```
Rectangles Overlap
```

#### 问:写一个可以在任何尺寸的屏幕上工作的自动换行程序？

**答案:**

```
public class WordWrap
{ 
    final int MAX = Integer.MAX_VALUE;      
    // A utility function to print the solution
    int printSolution (int p[], int n)
    {
        int k;
        if (p[n] == 1)
        k = 1;
        else
        k = printSolution (p, p[n]-1) + 1;
        System.out.println("Line number" + " " + k + ": " + 
        "From word no." +" "+ p[n] + " " + "to" + " " + n);
        return k;
    }  
    void solveWordWrap (int l[], int n, int M)
    {
        int extras[][] = new int[n+1][n+1];
        int lc[][]= new int[n+1][n+1];  
        int c[] = new int[n+1];
        int p[] =new int[n+1]; 
        for (int i = 1; i <= n; i++)
        {
            extras[i][i] = M - l[i-1];
            for (int j = i+1; j <= n; j++)
            extras[i][j] = extras[i][j-1] - l[j-1] - 1;
        }
        for (int i = 1; i <= n; i++)
        {
            for (int j = i; j <= n; j++)
            {
                if (extras[i][j] < 0)
                    lc[i][j] = MAX;
                else if (j == n && extras[i][j] >= 0)
                    lc[i][j] = 0;
                else
                    lc[i][j] = extras[i][j]*extras[i][j];
            }
        }      
        c[0] = 0;
        for (int j = 1; j <= n; j++)
        {
            c[j] = MAX;
            for (int i = 1; i <= j; i++)
            {
                if (c[i-1] != MAX && lc[i][j] != MAX && 
                   (c[i-1] + lc[i][j] < c[j]))
                {
                    c[j] = c[i-1] + lc[i][j];
                    p[j] = i;
                }
            }
        }    
        printSolution(p, n);
    }  
    public static void main(String args[])
    {
        WordWrap w = new WordWrap();
        int l[] = {3, 2, 2, 5};
        int n = l.length;
        int M = 6;
        w.solveWordWrap (l, n, M);
    }
} Output:
```

```
Line number 1: From word no. 1 to 1
Line number 2: From word no. 2 to 3
Line number 3: From word no. 4 to 4
```

#### **问题:用 Java 写一个程序实现阻塞队列？**

**答案:**

```
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
public class ProducerConsumer {
public static void main(String[] args) {      
     BlockingQueue<Message> queue = new ArrayBlockingQueue<>(10);
     Producer producer = new Producer(queue);    
     Consumer consumer = new Consumer(queue);
     new Thread(producer).start();
     new Thread(consumer).start();
     System.out.println("Producer and Consumer started");
}
}
```

**输出:**

```
Producer and Consumer started
Produced 0
Produced 1
Produced 2
Produced 3
Produced 4
Consumed 0
Produced 5
Consumed 1
Produced 6
Produced 7
Consumed 2
Produced 8
```

#### **问题:如何检查两个字符串是否是变位词？**

**答案:**

```
import java.io.*;
import java.util.Arrays;
import java.util.Collections;
class Anagram {
    static boolean areAnagram(char[] str1, char[] str2)
    {
        // Get lenghts of both strings
        int n1 = str1.length;
        int n2 = str2.length;
        // If length of both strings is not same,
        // then they cannot be anagram
        if (n1 != n2)
        return false;
        // Sort both strings
        Arrays.sort(str1);
        Arrays.sort(str2);  
        // Compare sorted strings
        for (int i = 0; i < n1; i++)
            if (str1[i] != str2[i])
                return false;  
                return true;
    }  
    public static void main(String args[])
    {
        char str1[] = { 'w', 'e', 's', 't' };
        char str2[] = { 't', 't', 'e', 'w' };
        if (areAnagram(str1, str2))
            System.out.println("The two strings are"
                               + " anagram of each other");
        else
            System.out.println("The two strings are not"
                               + " anagram of each other");
    }
}
```

**输出:**

```
The two strings are not anagram of each other.
```

#### **问题:给定两个数组，1，2，3，4，5 和 2，3，1，0，5，找出哪个数不在第二个数组中？**

**答案:**

```
class ABC 
{
    static void findMissing(int a[], int b[], 
                            int n, int m)
    {
        for (int i = 0; i < n; i++)
        {
            int j;
            for (j = 0; j < m; j++)
                if (a[i] == b[j])
                    break;
            if (j == m)
                System.out.print(a[i] + " ");
        }
    }
    // Driver Code
    public static void main(String[] args)
    {
        int a[] = { 1, 2, 3, 4, 5 };
        int b[] = { 2, 5, 3, 1, 0 };
        int n = a.length;
        int m = b.length;          
        findMissing(a, b, n, m);
    }
}
```

**输出:**

```
4, 0
```

#### 问题:如何求一个数组中最大和最小的数？

**答案:**

```
public class FindNumber {
     public static void main(String[] args) {
             int numbers[] = new int[]{45,23,87,13,63};
             int smallest = numbers[0];
             int biggest = numbers[0];         
             for(int i=1; i< numbers.length; i++)
             {
                     if(numbers[i] > biggest)
                                biggest = numbers[i];
                     else if (numbers[i] < smallest)
                                smallest = numbers[i];                 
             }           
             System.out.println("Largest Number is : " + biggest);
             System.out.println("Smallest Number is : " + smallest);
     }
}
```

**输出:**

```
Largest Number is : 87
Smallest Number is : 13
```

#### 问题:如何找到一个数组中前两个最大的数？

**答案:**

```
public class MaxNumbers {
    public void TwoMaxNumbers(int[] nums){
        int maxOne = 0;
        int maxTwo = 0;
        for(int n:nums){
            if(maxOne < n){
                maxTwo = maxOne;
                maxOne =n;
            } else if(maxTwo < n){
                maxTwo = n;
            }
        }
        System.out.println("First Max Number: "+maxOne);
        System.out.println("Second Max Number: "+maxTwo);
    }
    public static void main(String a[]){
        int num[] = {5,34,12, 18,50 ,23};
        TwoMaxNumbers tmn = new TwoMaxNumbers();
        tmn.printTwoMaxNumbers(num);
    }
}
```

**输出:**

```
First Max Number: 50
Second Max Number: 34
```

## 结论

想多准备点吗？这个评价很高的 udemy 课程已经帮助了成千上万的面试候选人，所以一定对你也有用:[脱离:编程和编码面试](https://click.linksynergy.com/deeplink?id=jU79Zysihs4&mid=39197&murl=https://www.udemy.com/course/break-away-coding-interviews-1/)。

这就完成了我们列出的每个有抱负的程序员都必须知道的编程面试问题，这些问题将帮助你通过技术面试。如果您在面试时发现其他问题没有列在这里，请提出意见，我们会将这些问题添加到给定的列表中。万事如意！

**人也在读:**