<html>
<head>
<title>Merge Sort in C – Algorithm and Program With Explanation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>C语言中的归并排序——算法和程序及说明</h1>
<blockquote>原文：<a href="https://hackr.io/blog/merge-sort-in-c#0001-01-01">https://hackr.io/blog/merge-sort-in-c#0001-01-01</a></blockquote><div><div class="content">
										<p class="c3">合并排序是最强大的排序算法之一。合并排序也广泛应用于各种应用程序中。这些算法最好的部分是，它们能够以O(n  <sub> <span class="c9 c7 c15 c8"> 2 </span> </sub> <span class="c9 c7 c15">)复杂度</span> <span class="c1">(我们很快就会看到如何)对给定数据进行排序。此外，合并排序是有趣的，因为它为计算机科学中广泛使用的技术之一——分而治之——创建了一个极好的案例研究。</span></p>
<h2 class="c3" id="merge-sort-algorithm-explanation"><strong> <span class="c2">归并排序算法-解释</span> </strong></h2>
<p class="c3"><span class="c1">给定一个长度为n的数组，我们执行以下步骤对数组进行排序:</span></p>
<ol>
<li><span class="c1">将数组分为长度分别为n/2和n - n/2的两部分(这里如果n是奇数，我们将n/2的值四舍五入)。让我们把这些数组分别称为左半部和右半部。</span></li>
<li><span class="c1">递归排序左半数组和右半数组。</span></li>
<li><span class="c1">合并左半数组和右半数组，得到排序后的全数组。</span></li>
</ol>
<p class="c3"><span class="c1">让我们举个例子:</span></p>
<p class="c3"><span class="c1">给定数组:[6，4，5，1，2，7，3] </span></p>

<p class="c3"><span class="c1">首先，按照上面的步骤1，我们将数组分成两部分。我们可以看到，下面是左半部分和右半部分的子阵列:</span></p>
<ul>
<li><span class="c1">左半边:[6，4，5，1] </span></li>
<li><span class="c1">右半部分:[2，7，3] </span></li>
</ul>
<p class="c3">然后，按照上面的步骤2，我们递归地排序左半部分和右半部分。下面是排序后的子数组的样子:</p>
<ul>
<li><span class="c1">递归排序的左半部分:[1，4，5，6] </span></li>
<li><span class="c1">递归排序的右半部分:[2，3，7] </span></li>
</ul>
<p class="c3">最后，按照步骤3，我们将合并这两半来创建最终的排序数组。最终合并排序后的数组:[1，2，3，4，5，6，7] </p>
<p class="c3">左半部分和右半部分总是可以使用相同的算法递归排序。神奇的事情发生在创建最终合并和排序的数组。所以，让我们用上面的例子来很好地理解它。</p>
<p class="c3">在上面的例子中，我们得到了2个数组[1，4，5，6]和[2，3，7]。我们应该将这两个数组合并成一个排序后的数组。让我们在每个数组的开头放置一个指针。我们将通过在指针指向的相应元素下画线来描述指针。</p>
<p class="c3"><span class="c1">最终合并数组= [] </span></p>

<p class="c3"><span class="c7">左阵:【</span> <span class="c9 c7"> 1 </span> <span class="c1">，4，5，6】</span></p>
<p class="c3"><span class="c7">右阵:【</span> <span class="c9 c7"> 2 </span> <span class="c1">，3，7】</span></p>
<p class="c3"><span class="c1">可以看出，左数组的指针在1，右数组的指针在2。我们选择较小的一个，并把它放在最终的合并数组中，然后移动相应的指针。这样做之后，我们将有以下状态:</span></p>
<p class="c3"><span class="c1">最终合并数组= [1] </span></p>
<p class="c3"><span class="c7">左阵:【</span> <span class="c9 c7"> 4 </span> <span class="c1">，5，6】</span></p>
<p class="c3"><span class="c7">右阵:【</span> <span class="c9 c7"> 2 </span> <span class="c1">，3，7】</span></p>
<p class="c3">这里的指针现在分别位于4和2。我们再次做我们上面做的——选择较小的一个，并把它放在最终的合并数组中，并移动相应的指针。我们将得到如下:</p>
<p class="c3"><span class="c1">最终合并数组= [1，2] </span></p>
<p class="c3"><span class="c7">左阵:【</span> <span class="c9 c7"> 4 </span> <span class="c1">，5，6】</span></p>
<p class="c3"><span class="c7">右阵:【</span> <span class="c9 c7"> 3 </span> <span class="c1">，7】</span></p>
<p class="c3"><span class="c1">我们再重复一次，得到:</span></p>
<p class="c3"><span class="c1">最终合并数组= [1，2，3] </span></p>
<p class="c3"><span class="c7">左阵:【</span> <span class="c7 c9"> 4 </span> <span class="c1">，5，6】</span></p>
<p class="c3"><span class="c7">右阵:【</span><span class="c9 c7">7</span><span class="c1">】</span></p>
<p class="c3"><span class="c1">继续这个练习，我们可以看到，我们能够成功地以排序后的形式得到最终的合并数组:</span></p>
<p class="c3"><span class="c1">最终合并数组= [1，2，3，4，5，6，7] </span></p>
<p class="c3"><span class="c1">左数组:[] </span></p>
<p class="c3"><span class="c1">右数组:[] </span></p>
<p class="c3">如你所见，我们从一个未排序的数组开始，并且成功地得到了一个排序的数组。另一个需要回答的问题是——左右数组是如何排序的？嗯，我们用和上面一样的技术递归地对它们进行了排序。例如，考虑右边的数组:[2，7，3]。为了对它进行排序，我们将再次把它分成两个子数组:[2，7]和[3]。这两个子数组都已经排序了，所以我们可以通过使用上面解释的技术来合并它们，从而得到排序后的数组[2，3，7]。</p>
<p class="c3"><span class="c1">看一下下面的图片，理解同样的过程是如何递归地应用到子阵列上的:</span></p>
<p class="c3"><img title="" src="../Images/831474f5c74a41b8dcedda7ee4487a2f.png" alt="" data-original-src="https://lh3.googleusercontent.com/zSy9CnA6o_vErwJrclL6xgPwAgmLemWjR_W1OwSsraVaGY6wfXHb31_HIIrPh7CRc120CjLo4nzAoR31gMkq371vF_a2DYTKtwCoiVvU4uVv0eDo3jgphnYQ_9Ceg14evnqeX5oc"/></p>
<p class="c3">在上图中，我们用黑色显示了实际的子数组，用蓝色显示了排序后的子数组。让我们理解在上面的数组中执行合并排序的详细步骤:</p>
<ul>
<li><span class="c1">【6，4，5，1，2，7，3】分为【6，4，5，1】和【2，7，3】</span></li>
<li><span class="c1">【6，4，5，1】分为【6，4】和【5，1】</span></li>
<li><span class="c1">【6，4】分为【6】和【4】</span><ul>
<li><span class="c1"> [6]是一个单元素数组，因此，被排序。</span></li>
<li><span class="c1"> [4]是一个单元素数组，因此，被排序。</span></li>
</ul>
</li>
<li><span class="c1">【6】和【4】合并为【4，6】</span></li>
<li><span class="c1">【5，1】分为【5】和【1】</span><ul>
<li><span class="c1"> [5]是一个单元素数组，因此，被排序。</span></li>
<li><span class="c1"> [1]是一个单元素数组，因此，被排序。</span></li>
</ul>
</li>
</ul>
<ul class="c5 lst-kix_xm5gxuez2ou6-3 start">
<li class="c3 c6"><span class="c1">【5】和【1】合并为【1，5】</span></li>
</ul>
<ul class="c5 lst-kix_xm5gxuez2ou6-1">
<li>   <ul class="c5 lst-kix_xm5gxuez2ou6-1">
<li class="c3 c12"><span class="c1">【4，6】和【1，5】合并为【1，4，5，6】</span></li>
</ul>
</li>
</ul>
<ul>
<li><span class="c1">【2，7，3】分为【2，7】和【3】</span></li>
<li><span class="c1">【2，7】分为【2】和【7】</span><ul>
<li><span class="c1"> [2]是一个单元素数组，因此，被排序。</span></li>
<li><span class="c1"> [7]是一个单元素数组，因此，被排序。</span></li>
</ul>
</li>
<li><span class="c1">【2】和【7】合并为【2，7】</span></li>
<li><span class="c1"> [3]是一个单元素数组，因此，被排序。</span></li>
<li><span class="c1">【2，7】和【3】合并为【2，3，7】</span></li>
<li><span class="c1">【1，4，5，6】和【2，3，7】合并成【1，2，3，4，5，6，7】</span></li>
</ul>
<p class="c3">注意重要的一点——我们需要一个单独的数组来存储最终合并数组的数据。这意味着合并排序需要额外的空间。</p>
<p class="c3">这就是合并排序的工作方式。这里有一个动画解释了同样的问题。</p>
<p class="c3"><img title="" src="../Images/a8c006ee2ce915ccb4558a532fd247c9.png" alt="" data-original-src="https://lh5.googleusercontent.com/EQ-tXq1qq2Bt1ihSFc7d3FsHMoWjPWCEt0XThrVvNd4YB_YO86jOx6tyod7TBXdfSEMTfuJVcBYSO38VleOyIEV0PKr1qZg_SSuFRHw14SN07IXwN7kZvxd0tueDpTN6hMShQxmC"/></p>
<h2 class="c3" id="merge-sort-pseudo-code"><strong> <span class="c2">合并排序伪代码</span> </strong></h2>
<p class="c3"><span class="c1">在进入实际代码之前，让我们先来看看伪代码。</span></p>

<pre>function merge_sort(i, j, a, aux) {
 mid = (i + j) / 2
 merge_sort(i, mid, a, aux)
 merge_sort(mid + 1, j, a, aux)
 pointer_left = i, pointer_right = mid + 1
 for k in [i ... j] {
 if pointer_left points to smaller element, aux[k] = a[pointer_left] and increment pointer_left by 1
 if pointer_right points to smaller element, aux[k] = a[pointer_right] and increment pointer_right by 1
 }
 copy the contents of aux[i .. j] to a[i .. j]
}
</pre>
<p class="c3">现在，让我们来看看实际的工作代码。</p>
<h2 id="merge-sort-program-in-c">C语言中的归并排序程序</h2>
<p><span class="c1">让我们一步步理解代码:</span></p>
<p class="c3"><code>void merge_sort(int i, int j, int a[], int aux[])</code></p>
<p>这个原型意味着merge_sort函数对子数组a[i..j]使用辅助<code>array aux[]</code>。</p>
<p class="c3"><span class="c1">如果<code>j &lt;= i</code>，显然，子数组<code>a[i .. j]</code>要么包含1个元素(已排序)，要么不包含元素(也已排序)。因此，在这种情况下，我们什么也不做，只是返回。</span></p>
<pre>if (j &lt;= i) {
 return;
}
</pre>
<p class="c3"><span class="c1">T2<code>int mid = (i + j) / 2;</code></span></p>
<p class="c3"><span class="c1">我们计划将数组划分为两个长度几乎相等的子数组。这些子阵列是<code>a[i .. mid]</code>和<code>a[mid + 1 .. j]</code>。显然，<code>mid = (i + j) / 2</code>是这里最好的，因为mid是I和j的平均值。</span></p>
<p class="c3"><span class="c1">这里，我们通过调用相同的merge_sort函数递归排序<code>a[i .. mid]</code>和<code>a[mid + 1 .. j]</code>子数组。</span></p>
<pre> merge_sort(i, mid, a, aux);
 merge_sort(mid + 1, j, a, aux);
</pre>
<p class="c3">一旦我们有了这两个排序好的子数组，剩下的代码就简单地合并这两个。</p>
<p class="c3"><span class="c1">在这里，我们将pointer_left放在左侧子数组<code>a[i .. mid]</code>的开头，将pointer_right放在右侧子数组<code>a[mid + 1 .. j]</code>的开头。</span></p>

<pre> int pointer_left = i;
 int pointer_right = mid + 1;
 int k;
</pre>
<p class="c3"><span class="c1">在这里，我们有4种情况:</span></p>

<pre> for (k = i; k &lt;= j; k++) {
 if (pointer_left == mid + 1) {
 aux[k] = a[pointer_right];
 pointer_right++;
 } else if (pointer_right == j + 1) {
 aux[k] = a[pointer_left];
 pointer_left++;
 } else if (a[pointer_left] &lt; a[pointer_right]) {
 aux[k] = a[pointer_left];
 pointer_left++;
 } else {
 aux[k] = a[pointer_right];
 pointer_right++;
 }
}
</pre>
<p class="c3"><span class="c1"> <code>pointer_left == mid + 1:</code>在这种情况下，左边的子数组完成了，它的所有元素都已经合并了。</span></p>
<ol>
<li><span class="c1"> <code>pointer_right == j + 1:</code>在这种情况下，右边的子数组完成了，它的所有元素都已经合并了。</span></li>
<li><span class="c1"> <code>a[pointer_left] &lt; a[pointer_right]:</code>这里，2个数组都没有完成。然而，pointer_left指向一个比pointer_right更小的元素，所以我们把它放在合并的数组中。</span></li>
<li><span class="c1"> else最后一种情况:这里，两个数组都没有完成。然而，pointer_right指向一个比pointer_left更小的元素，所以我们把它放在合并的数组中。</span></li>
<li>最后，我们将元素从aux[]复制到a[]。</li>
</ol>
<p class="c3">这就是合并排序的工作方式。</p>
<pre>for (k = i; k &lt;= j; k++) {
 a[k] = aux[k];
}</pre>
<p class="c3"><span class="c2">合并排序复杂度</span></p>
<h2 class="c3" id="merge-sort-complexity"><span class="c1">复杂度给出了作为输入大小的函数的执行算法所需时间的粗略概念。例如，假设T(n)是对大小为n的数组执行合并排序所花费的时间</span></h2>
<p class="c3">如我们所见，T(n)包括3个:</p>
<p class="c3"><span class="c1">在左半部分执行合并排序所花费的时间。左半部分的大小为n/2，因此，花费的时间只有T(n/2)。</span></p>
<ol>
<li><span class="c1">在右半部分执行合并排序所花费的时间。右半部分的大小为n/2，所以这里花费的时间也是T(n/2)。</span></li>
<li><span class="c1">合并左右两半花费的时间。正如我们所看到的，为了合并这两半，我们从两个子数组中一个接一个地选择每个元素，并填充到原始数组中。由于有n个元素，合并所花费的时间将与n成正比。因此，让我们把这个时间称为cn，其中c是某个常数。</span></li>
<li><span class="c1">总时间，T(n) = T(n/2) + T(n/2) + cn </span></li>
</ol>
<p class="c3"><span class="c1">于是，我们有了等式:T(n) = 2T(n/2) + cn。利用一些数学知识，这个等式可以解为</span></p>
<p class="c3"><span class="c1"> T(n) = 2T(n/2) + cn </span></p>
<p class="c3"><span class="c7">= 2(2T(n/4)+cn/2)+cn = 2</span><sup><span class="c7 c8">2</span></sup><span class="c7">T(n/2</span><sup><span class="c7 c8">2</span></sup><span class="c1">)+2cn</span></p>
<p class="c3"><span class="c7">= 2(2(2T(n/8)+cn/4)+cn/2)+cn = 2</span><sup><span class="c7 c8">3</span></sup><span class="c7">T(n/2</span><sup><span class="c7 c8">3</span></sup><span class="c1">)+3cn</span></p>
<p class="c3"><span class="c1">...</span></p>

<p class="c3"><span class="c1">...</span></p>

<p class="c3"><span class="c7">上述数列的第k项为:2</span><sup><span class="c7 c8">k</span></sup><span class="c7">T(n/2</span><sup><span class="c7 c8">k</span></sup><span class="c1">)+kcn</span></p>
<p class="c3"><span class="c7">放2 </span> <span class="c7 c8"> k </span> <span class="c7"> = n，我们有k = log</span><sub><span class="c7 c11">2</span></sub><span class="c7">n .我们把k的这个值放在上式中得到:T(n)= nT(1)+cn log</span><sub><span class="c7 c11">2</span></sub>T16】n</p>
<p class="c3"><span class="c7">这里，T(1)和c是常数。所以，我们可以写成T(n)= An+bn log</span><sub><span class="c7 c11">2</span></sub><span class="c7">n .由于nlog</span><sub><span class="c7 c11">2</span></sub><span class="c7">n大于n，我们可以看出nlog</span><sub><span class="c7 c11">2</span></sub><span class="c7">n是占优势的项。只是给你一个思路，当n = 2 </span> <span class="c7 c8"> 32 </span> <span class="c7">，nlog</span><sub><span class="c7 c11">2</span></sub><span class="c7">n = 32 * 2</span><span class="c7 c8">32</span><span class="c7">时，这显然大了一个数量级。所以，T(n)可以写成T(n)= O(nlog</span><sub><span class="c7 c11">2</span></sub><span class="c1">n)。</span></p>
<p class="c3"><span class="c7"/><span class="c9 c7 c15">冒泡排序算法</span> <span class="c7">的复杂度另一方面如我们所见为O(n </span> <sup> <span class="c7 c8"> 2 </span> </sup> <span class="c7">)。显然，合并排序比冒泡排序算法快得多，这就是它被广泛应用于各种应用程序和库中的原因。</span></p>
<p class="c3"><span class="c7"> <span> <a class="btn btn-primary btn-call-to-action btn-block" href="https://click.linksynergy.com/link?id=jU79Zysihs4&amp;offerid=1045023.2121018&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fdatastructurescncpp%2F" target="_blank" rel="noopener">掌握数据结构&amp;使用C和C++ </a> </span> </span>的算法</p>
<p class="c3"><strong> <span class="c2">结论</span> </strong></p>
<h2 class="c3" id="conclusion">合并排序是一个有趣的算法，是理解数据结构和算法的一个很好的案例。为了打好计算机科学的基础，建议你彻底理解各种排序算法，这将有助于你掌握基础知识。</h2>
<p class="c3">PS:你可能也会对我们在C 博客中的<a href="https://hackr.io/blog/bubble-sort-in-c">冒泡排序感兴趣。</a></p>
<p><strong>人也在读:</strong></p>
<p><strong>People are also reading:</strong></p>


									</div>

									</div>    
</body>
</html>