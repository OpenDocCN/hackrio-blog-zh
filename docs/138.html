<html>
<head>
<title>Top 50 Node.js Interview Questions and Answers [2023]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>50强Node.js面试问答[2023]</h1>
<blockquote>原文：<a href="https://hackr.io/blog/node-js-interview-questions#0001-01-01">https://hackr.io/blog/node-js-interview-questions#0001-01-01</a></blockquote><div><div class="content">
										<p>Node.js是一个JavaScript环境，用于在浏览器外执行JavaScript代码。基于Chrome的V8引擎，它代表了<em>JavaScript anywhere and everywhere</em>编程范式，将web应用程序开发统一到一种语言，而不是服务器和客户端脚本的不同语言。</p>
<p>LinkedIn、IBM、GoDaddy、Groupon、网飞、Paypal都使用<a href="https://hackr.io/blog/what-is-node-js"> Node.js </a>。它越来越受欢迎，引发了对Node.js开发人员的需求，这意味着大量的工作机会！</p>
<p>但是如果你对面试感到紧张，不要担心。我们将帮助您准备这些Node.js面试问题。先说一些入门级角色的基本节点js问题。</p>
<h2 id="node-js-interview-questions-and-answers"><strong> Node.js面试问答</strong></h2>
<h3 id="node-js-interview-questions-for-freshers"><strong> Node.js大一新生面试问题</strong></h3>
<p>这些初学者节点面试问题涵盖了基本概念，但重要的是你彻底了解它们。</p>

<h4 id="toc-1-what-is-node-js"><strong> 1。Node.js是什么？</strong></h4>
<p>Node.js是以Chrome的V8 JavaScript引擎为平台构建的JavaScript运行时环境。它之所以受欢迎，是因为它轻量级且高效，这得益于它的事件驱动和非阻塞I/O模型。Node.js以性能为主要关注点，将JavaScript代码处理为本机代码，您的计算机可以使用这些代码来执行进程。</p>
<p>尽管Node.js基于Chrome的V8引擎，但它本身并不在浏览器中运行。在开发过程中，各种功能(如文件系统API、HTTP库和操作系统实用程序方法)被添加到引擎中，因此Node.js可以作为计算机上的程序执行。</p>
<h4 id="toc-2-how-are-child-threads-handled-in-node-js"><strong> 2。Node.js中的“子线程”是如何处理的？</strong></h4>
<p>基本上，Node.js是一个单线程进程。它不向开发人员公开任何子线程和线程管理模式。然而，子线程可能在Node.js中的各种进程中生成，如异步I/O。尽管通过这些进程产生的子线程在后台运行，但它们不会阻塞主代码或执行任何应用程序代码。但是，如果您需要在Node.js支持的应用程序中提供线程支持，可以使用多种工具。</p>
<h4 id="toc-3-what-are-some-differences-between-angular-js-and-node-js"><strong> 3。Angular JS和Node.js有哪些区别？</strong></h4>
<p>以下是Angular JS和Node.js的一些区别</p>
<table>
<tbody>
<tr>
<td>
<p><strong>角型</strong></p>
</td>
<td>
<p><strong> Node.js </strong></p>
</td>
</tr>
<tr>
<td>
<p>用打字稿写的</p>
</td>
<td>
<p>用各种语言编写，如C、C++和JavaScript</p>
</td>
</tr>
<tr>
<td>
<p>非常适合创建高度互动的网页</p>
</td>
<td>
<p>适合小规模项目和应用</p>
</td>
</tr>
<tr>
<td>
<p>用于<a href="https://hackr.io/blog/web-development-ide"> web应用开发的开源框架</a></p>
</td>
<td>
<p>基于多平台的运行时环境</p>
</td>
</tr>
<tr>
<td>
<p>用于为客户端创建单页应用程序</p>
</td>
<td>
<p>用于创建服务器端网络应用程序</p>
</td>
</tr>
<tr>
<td>
<p>帮助将应用程序拆分成模型-视图-控制器(MVC)组件</p>
</td>
<td>
<p>帮助生成数据库查询</p>
</td>
</tr>
<tr>
<td>
<p>适合开发实时应用程序</p>
</td>
<td>
<p>适用于需要快速行动和扩展的情况</p>
</td>
</tr>
<tr>
<td>
<p>Angular本身就是一个web应用框架</p>
</td>
<td>
<p>Node.js有很多框架，包括Express.js、Partial.js等等</p>
</td>
</tr>
</tbody>
</table>
<h4 id="toc-4-state-the-primary-uses-of-node-js"><strong> 4。陈述Node.js. </strong>的主要用途</h4>
<p>以下是Node.js的一些函数:</p>
<ul>
<li aria-level="1">复杂的单页应用程序: Node.js非常适合创建复杂的单页应用程序，比如在线绘图工具、邮件解决方案和社交网络。这些类型的应用程序仅限于一个页面，UX类似于桌面应用程序。这里可以使用Node.js，因为它在后端有异步数据流。</li>
<li aria-level="1"><strong>实时应用(RTA): </strong>我们在日常生活中使用一些实时应用，如Google Docs、Slack、Skype、WhatsApp等等。Node.js的事件API、WebSockets和异步数据流确保了无故障的服务器操作，这可以即时更新数据。</li>
<li aria-level="1"><strong>聊天室:</strong>这可能是RTA下的俱乐部，但由于即时消息和聊天已经成为顶级实时应用模型之一，它需要特别关注。如果你有一个聊天室产品，你会考虑轻量级、高流量和大量数据流等需求。Node.js和后端的一些<a href="https://hackr.io/blog/best-javascript-frameworks"> JavaScript框架</a>满足了所有这些需求。前面提到的web套接字对于在聊天室环境中接收和发送消息很方便。</li>
<li aria-level="1"><strong>基于浏览器的游戏:</strong>上述聊天室也可以集成到基于浏览器的游戏中，其中Node.js是一个完美的选择。将Node.js技术与HTML5甚至js工具相结合，将有助于您创建基于浏览器的实时游戏。</li>
<li aria-level="1"><strong>数据流应用:</strong>这些应用的关键卖点在于它们在卸载阶段的数据处理。通过这种方式，可以预先下载一些部分以保持连接，稍后再下载其他部分。在这种情况下，Node.js流应用程序处理音频和视频数据。</li>
<li aria-level="1"><strong>表述性状态转移(REST)应用编程接口(API):</strong>由于超文本传输协议(HTTP)的广泛使用，基于REST的API在现代商业软件架构的构建中占据着关键地位。Node.js生态系统的Express.js框架可以帮助构建快速、轻量的REST APIs。</li>
<li aria-level="1"><strong>服务器端web应用:</strong>虽然Node.js及其框架可以帮助创建服务器端web应用，但您不能指望CPU密集型操作。</li>
<li aria-level="1"><strong>命令行工具:</strong> Node.js的庞大生态系统有助于构建CLT——查看在线教程来构建自己的生态系统。</li>
</ul>
<p><img src="../Images/2c58b87525810e216c5c4c28e9f93d11.png" alt="NodeJs Functions" data-original-src="https://hackr.io/blog/media/node-5.png"/></p>

<h4 id="toc-5-what-is-event-driven-programming"><strong> 5。什么是事件驱动编程？</strong></h4>
<p>事件驱动编程方法使用事件来触发各种功能。在这种情况下，事件可以是任何事情，例如按键或单击鼠标按钮。每当事件发生时，就会按照“发布-订阅”模式执行一个已经向元素注册的回调函数。由于这种编程方法，Node.js比其他类似技术更快。</p>
<h4 id="toc-6-in-the-context-of-node-js-what-is-repl"><strong> 6。在Node.js的上下文中，REPL是什么？</strong></h4>
<p>REPL阅读，评估，打印和循环。REPL是一种计算机环境(类似于Windows控制台或Linux shell ),任何输入的命令都会得到系统响应输出。默认情况下，REPL环境与Node.js捆绑在一起，它执行以下任务:</p>
<ul>
<li aria-level="1"><strong>读取</strong>用户输入，将它们转换成JavaScript数据结构，并存储它们。</li>
<li aria-level="1"><strong>评估</strong>数据结构。</li>
<li aria-level="1"><strong>打印</strong>最终输出</li>
<li aria-level="1"><strong>循环</strong>所提供的命令，直到CTRL + C被按下两次。</li>
</ul>
<h4 id="toc-7-what-is-a-test-pyramid-in-node-js"><strong> 7。Node.js中的测试金字塔是什么？</strong></h4>
<p>测试金字塔是解释成功开发项目所需的单元测试、集成测试和端到端测试的比例的图形:</p>
<ul>
<li aria-level="1">单元测试:他们独立地快速测试单个的代码单元。</li>
<li aria-level="1"><strong>集成测试:</strong>测试不同单元之间的集成。</li>
<li aria-level="1">端到端(E2E)测试:他们将系统作为一个整体进行测试，从用户界面到数据存储，然后返回。</li>
</ul>
<h4 id="toc-8-what-is-libuv"><strong> 8。什么是libuv？</strong></h4>
<p>Libuv是Node.js的支持库，用于异步输入/输出。虽然它最初只是为Node.js开发的，但现在已经可以在其他系统上使用，比如Luvit、Julia、Pyuv等等。它的一些功能包括:</p>
<ul>
<li aria-level="1">文件系统事件</li>
<li aria-level="1">子进程</li>
<li aria-level="1">全功能事件循环支持</li>
<li aria-level="1">异步TCP和UDP套接字</li>
</ul>
<h4 id="toc-9-is-node-js-the-best-platform-for-cpu-heavy-applications"><strong> 9。Node.js是CPU密集型应用的最佳平台吗？</strong></h4>
<p>CPU激励型应用程序并不是Node.js的强项。CPU密集型操作会阻塞传入的请求，并将线程推入危急情况。</p>
<h4 id="toc-10-what-is-the-purpose-of-the-express-js-package">10。Express JS包的用途是什么？</h4>
<p>Expressjs构建于Node.js之上，是一个JS框架，用于管理服务器端应用程序中路由和服务器之间的信息流。轻量级、灵活且充满相关特性，非常适合移动和web应用程序开发。</p>
<h4 id="toc-11-what-are-the-main-differences-between-node-js-vs-javascript"><strong> 11。Node.js和Javascript的主要区别是什么？</strong></h4>
<table>
<tbody>
<tr>
<td>
<p><strong> Node.js </strong></p>
</td>
<td>
<p><strong> JavaScript </strong></p>
</td>
</tr>
<tr>
<td>
<p>跨平台开源JS运行时引擎。</p>
</td>
<td>
<p>一种基于OOPS概念的高级脚本语言。</p>
</td>
</tr>
<tr>
<td>
<p>代码可以在浏览器之外运行。</p>
</td>
<td>
<p>代码只能在浏览器中运行。</p>
</td>
</tr>
<tr>
<td>
<p>在服务器端使用。</p>
</td>
<td>
<p>在客户端使用。</p>
</td>
</tr>
<tr>
<td>
<p>没有添加HTML标签的功能。</p>
</td>
<td>
<p>可以添加HTML标签。</p>
</td>
</tr>
<tr>
<td>
<p>只能在谷歌Chrome的V8引擎上运行。</p>
</td>
<td>
<p>可以在任何浏览器上运行。</p>
</td>
</tr>
<tr>
<td>
<p>用C++和JavaScript写的。</p>
</td>
<td>
<p>用C++写的ECMA脚本的升级版本。</p>
</td>
</tr>
</tbody>
</table>
<h4 id="toc-12-what-are-the-major-benefits-of-node-js"><strong> 12。Node.js的主要好处是什么？</strong></h4>
<p>Node.js的好处是:</p>
<ul>
<li aria-level="1">易于学习和巨大的社区支持。</li>
<li aria-level="1">易于扩展和高性能。</li>
<li aria-level="1">高度可扩展，支持扩展。</li>
<li aria-level="1">支持全栈JavaScript。</li>
<li aria-level="1">缓存机制允许网页加载更快。</li>
<li aria-level="1">非阻塞输入输出系统。</li>
</ul>
<h4 id="toc-13-what-is-the-difference-between-asynchronous-and-non-blocking">13。异步和非阻塞的区别是什么？</h4>
<p>异步或非同步意味着我们不会立即收到对消息的响应——没有依赖关系或执行顺序。服务器存储信息，并在执行操作时进行确认。这提高了性能和效率。</p>
<p>非阻塞操作不会停止或阻塞任何操作。不同之处在于，无论有什么数据可用，非阻塞操作都会立即收到响应。如果数据不可用，它将返回一个错误。它主要与I/O一起使用。</p>
<h4 id="toc-14-what-is-package-json"><strong> 14。package.json是什么？</strong></h4>
<p>npm包在项目根文件夹中包含一个package.json文件，其中包含与项目相关的元数据。它向npm提供信息，npm通过这些信息识别项目及其依赖关系。除此之外，它还包含其他元数据，如项目描述、版本、许可信息和配置数据。</p>
<h4 id="toc-15-describe-the-error-first-callback-in-node-js">15。描述Node.js中的错误优先回调</h4>
<p>错误优先回调，也称为错误返回，给出错误和数据。它有几个参数，第一个是错误对象，其他的是数据。错误优先回调模式有很多优点:因为它是一致的，导致更多的采用，如果没有对数据的引用，就没有必要处理它。如果没有错误，调用回调时将null作为第一个参数。</p>
<h3 id="advanced-node-js-interview-questions-for-experienced-professionals"><strong>高级Node.js资深职场人士面试问题</strong></h3>
<p>现在我们进入高级节点面试问题。记住能够将这些概念付诸实践。</p>
<h4 id="toc-16-explain-the-purpose-of-module-exports">16。解释module.exports的用途。</h4>
<p>当部分代码喜欢对象、函数、字符串等时，它们会告诉Node.js。应该从给定的文件中导出，以便其他文件可以访问它。假设我们有这个模块:</p>
<pre class="language-javascript"><code>{

id: '.',

exports: {},

parent: null,

filename: '/modtest.js',

loaded: false,

children: [],

paths:

[

'/node_modules',

'/Users/node_modules',

'/Users/mycomp/projects/node_modules',

'/node_modules'

]

}</code></pre>
<p>请注意，导出属性为空。如果我们对这个属性应用代码，它将成为模块的导出。如果我们需要另一个文件中的模块，那将是导出属性值:</p>
<pre class="language-javascript"><code>module.exports.stringProperty = "Hello, welcome";

console.log(module);

{

id: '.',

exports: { stringProperty: 'Hello, welcome' }

...

}</code></pre>
<h4 id="toc-17-what-is-the-reactor-pattern-in-node-js"><strong> 17。Node.js中的反应器模式是什么？</strong></h4>
<p><strong><img src="../Images/8841dd5780b83cd4f1a75e5b50806d85.png" alt="reactor pattern in Node.js" data-original-src="https://hackr.io/blog/media/reactor-pattern-in-node.png"/>T2】</strong></p>
<p>reactor模式是Node.js中非阻塞I/O操作的一个概念，通过这个模式，我们获得了每个I/O操作的处理程序(或者回调函数)。每个I/O请求被提交给多路分解器，该多路分解器处理并发性并对请求/事件进行排队。它由资源、事件通知器/解复用器、事件循环、事件队列、请求处理程序等组成。</p>
<h4 id="toc-18-explain-lts-releases-of-node-js">18。解释Node.js的LTS版本</h4>
<p>LTS或长期支持适用于由Node.js项目长期支持和维护的发布行。LTS有两种类型:</p>
<ol>
<li aria-level="1">主动，即主动维护和升级，以及</li>
<li aria-level="1">维修线接近线的末端，维修时间很短。</li>
</ol>
<h4 id="toc-19-what-is-a-url-module"><strong> 19。什么是URL模块？</strong></h4>
<p>URL模块提供了处理URL的API:</p>
<ul>
<li aria-level="1">特定于Node.js的遗留API。</li>
<li aria-level="1">实现WHATWG URL(web浏览器使用的标准)的较新API。</li>
</ul>
<p>一些示例方法是URL类下的URL.port、URL.password、URL.host、url.toString()。如需完整文档，请查看官方的<a href="https://nodejs.org/api/url.html#:~:text=The%20url%20module%20provides%20two,Standard%20used%20by%20web%20browsers."> URL模块页面</a>。</p>
<h4 id="toc-20-explain-control-flow-function">20。解释控制流函数。</h4>
<p>控制流函数是执行语句或函数的顺序。因为I/O操作在Node.js中是非阻塞的，所以控制流不能是线性的。因此，它向事件循环注册一个回调，并将控制传递回节点，以便接下来的代码行可以无中断地运行。例如:</p>
<pre class="language-javascript"><code>[code language="javascript"]

fs.readFile('/root/text.txt', func(err, data){

console.log(data);

});

console.log("This is displayed first");

[/code]</code></pre>
<p>在这种情况下，readFile操作需要一些时间；但是，下一个console.log不会被阻止。一旦操作完成，您将看到显示的数据。</p>
<h4 id="toc-21-what-are-the-main-differences-between-the-spawn-and-fork-methods-in-node-js"><strong> 21。Node.js中spawn()和fork()方法的主要区别是什么？</strong></h4>
<table>
<tbody>
<tr>
<td>
<p><strong>产卵</strong></p>
</td>
<td>
<p><strong>叉子</strong></p>
</td>
</tr>
<tr>
<td>
<p>旨在运行系统命令。</p>
</td>
<td>
<p>spawn()的一个特殊实例，它运行V8的一个新实例。</p>
</td>
</tr>
<tr>
<td>
<p>不执行节点进程中的任何其他代码。</p>
</td>
<td>
<p>可以创建在同一个节点代码基上运行的多个工作线程。</p>
</td>
</tr>
<tr>
<td>
<p>child_process.spawn(command[，args][，options])用给定的命令创建一个新进程。</p>
</td>
<td>
<p>spawn()的特例，用于创建子进程。child_process.fork(modulePath[，args][，options])</p>
</td>
</tr>
<tr>
<td>
<p>在父进程和子进程之间创建流接口(二进制格式的数据缓冲)。</p>
</td>
<td>
<p>在父进程和子进程之间创建通信(消息传递)通道。</p>
</td>
</tr>
<tr>
<td>
<p>对于数据流(读/写)等连续操作更有用。例如，将图像/文件从种子进程流式传输到父进程。</p>
</td>
<td>
<p>对于消息传递更有用。例如，JSON或XML数据消息传递。</p>
</td>
</tr>
</tbody>
</table>
<h4 id="toc-22-what-is-the-purpose-of-the-expressjs-package-in-node-js"><strong> 22。Node.js中ExpressJS包的用途是什么？</strong></h4>
<p>ExpressJS包或框架构建在Node.js之上，用于快速跟踪单页面、多页面和基于混合服务器的应用程序的开发。据说Express是MEAN栈的后端部分。</p>

<pre class="language-javascript"><code>let execseq = function() { 

setImmediate(() =&gt; console.log("immediate")); 

process.nextTick(() =&gt; console.log("nextTick")); 

console.log("event loop");

}</code></pre>
<p>这将执行“事件循环”、“nextTick”和“immediate”</p>
<h4 id="toc-24-what-is-the-difference-between-node-js-vs-ajax"><strong> 24。Node.js和Ajax有什么区别？</strong></h4>
<p>Ajax是一种客户端技术，可以更新页面内容而无需刷新页面。Node.js是用于开发服务器软件的服务器端JavaScript。此外，Node.js是一个成熟的开发环境，而Ajax只是获取数据或运行脚本。</p>
<h4 id="toc-25-why-must-the-express-app-and-server-be-separated"><strong> 25。为什么快递的“app”和“server”一定要分开？</strong></h4>
<p>如果我们将应用程序和服务器功能分开，代码可以分成多个模块，这就减少了模块之间的依赖性。每个模块将执行一项任务。最后，逻辑的分离有助于避免重复代码。</p>

<p>虽然immediate这个词有点误导，但是回调只发生在I/O事件回调之后。当我们调用setImmediate()时。，setTimeout()用于为一次性回调的执行设置延迟(以毫秒为单位)。如果我们执行:</p>

<pre class="language-javascript"><code>setImmediate(function() {

console.log('setImmediate')

})

setTimeout(function() {

console.log('setTimeout')

}, 0)</code></pre>
<p>我们将得到“setTimeOut”和“setImmediate”形式的输出。</p>
<h4 id="toc-27-list-and-explain-the-popular-modules-of-node-js"><strong> 27。列举并解释Node.js的热门模块</strong></h4>
<p>以下是Node.js的核心模块:</p>
<table>
<tbody>
<tr>
<td>
<p>超文本传送协议（Hyper Text Transport Protocol的缩写）</p>
</td>
<td>
<p>包括用于创建Node.js http server的类、方法和事件。</p>
</td>
</tr>
<tr>
<td>
<p>统一资源定位器</p>
</td>
<td>
<p>包含URL解析和分析的方法。</p>
</td>
</tr>
<tr>
<td>
<p>查询字符串</p>
</td>
<td>
<p>处理查询字符串。</p>
</td>
</tr>
<tr>
<td>
<p>小路</p>
</td>
<td>
<p>包含使用文件路径的方法。</p>
</td>
</tr>
<tr>
<td>
<p>满量程</p>
</td>
<td>
<p>由处理文件I/O的类、方法和事件组成。</p>
</td>
</tr>
<tr>
<td>
<p>跑龙套</p>
</td>
<td>
<p>包括对开发者有用的实用函数。</p>
</td>
</tr>
</tbody>
</table>
<h4 id="toc-28-what-is-an-example-of-reading-and-writing-streams"><strong> 28。读写流的例子是什么？</strong></h4>
<p>这里有一个阅读流的例子:</p>
<pre class="language-javascript"><code>var readStream = fs.createReadStream('data.txt');

readStream.on('data', function(chunk) {

data += chunk;

});

Here’s an example of reading into stream:

var writeStream = fs.createWriteStream('dataout.txt');

writeStream.write(data,'UTF8');

writeStream.end();</code></pre>
<h4 id="toc-29-what-is-the-crypto-module-in-node-js-how-is-it-used"><strong> 29。Node.js中的加密模块是什么？如何使用？</strong></h4>
<p>Node.js中的crypto模块用于加密，也就是说，它包括一组用于开放SSL的散列、HMAC、签名、解密、加密和验证功能的包装器。</p>
<p>下面是一个使用密码进行加密的示例:</p>
<pre class="language-javascript"><code>const crypto = require('crypto'); 

const cipher = crypto.createCipher('usrnm', 'pwdd'); 

var encryptd = cipher.update('Welcome to hackr', 'utf8', 'hex'); 

encryptd += cipher.final('hex'); 

console.log(encryptd);</code></pre>
<p>让我们使用decipher来解密上面的内容，看看我们是否能得到相同的文本:</p>
<pre class="language-javascript"><code>const crypto = require('crypto'); 

const decipher = crypto.createDecipher('usrnm', 'pwdd'); 

var encryptd = '&lt;enter the previous output-encrypted code here&gt;'; 

var decryptd = decipher.update(encryptd, 'hex', 'utf8'); 

decryptd += decipher.final('utf8'); 

console.log(decryptd);</code></pre>
<h4 id="toc-30-explain-the-dns-module">三十岁。解释DNS模块。</h4>
<p>DNS模块用于解析名称和实际的DNS查找。有了这个模块，不需要记忆IP地址，因为DNS服务器会将域/子域转换成IP地址。</p>
<h4 id="toc-31-explain-the-security-mechanism-of-node-js">31。解释Node.js的安全机制</h4>
<p>安全机制包括:</p>
<ul>
<li aria-level="1"><strong>授权码:</strong>授权码有助于保护Node.js免受未经授权的第三方的攻击。任何想要访问Node.js的人都要通过资源提供者网络的GET请求。</li>
<li aria-level="1"><strong>认证模块:</strong>认证模块就像过滤器一样，扫描Node.js的库，以识别是否存在任何第三方代码。任何黑客行为都可以通过认证检测出来。</li>
<li aria-level="1"><strong>筛选登记:</strong>这是一个质量控制系统，所有的包(代码和软件)都经过检查，以确保其安全性。这种扫描有助于消除未经验证或不可靠的库进入您的应用程序。</li>
<li aria-level="1"><strong>定期更新:</strong>下载Node.js的最新版本可以防止潜在的黑客和攻击。</li>
</ul>
<h4 id="toc-32-explain-the-various-types-of-api-functions-in-node-js">32。解释Node.js. 中各种类型的API函数</h4>
<p>Node.js中的两种API函数是:</p>
<ul>
<li aria-level="1"><strong>异步/非阻塞:</strong>这些请求不等待服务器响应。它们继续处理下一个请求，一旦收到响应，它们就会收到同样的响应。</li>
<li aria-level="1"><strong>同步/阻塞:</strong>这些是阻塞任何其他请求的请求。一旦请求完成，下一个请求才会被处理。</li>
</ul>
<h4 id="toc-33-what-are-lts-versions-of-node-js">33。Node.js有哪些LTS版本？</h4>
<p>长期支持或LTS版本是Node.js发行版，要求关键修复、性能提升和安全更新。这些版本获得至少1.5年的支持，并专注于应用程序的安全性和稳定性。</p>

<h4 id="toc-34-explain-how-assert-works">34。解释assert如何工作。</h4>
<p>Assert用于在Node.js中编写测试。只有当任何正在运行的测试用例失败时，才会提供反馈。为了测试不变量，该模块提供了一组断言测试。它由Node.js内部使用，但是如果您使用require ('assert ')代码，您也可以在其他应用程序中使用它。</p>

<h4 id="toc-35-what-is-callback-hell">35。什么是回调地狱？</h4>
<p>在Node.js中，回调地狱也被称为末日金字塔。这些是由密集嵌套、不可读和不可管理的回调导致的，使得代码更难阅读和调试。这是由于不正确执行异步逻辑造成的。</p>
<h4 id="toc-36-what-is-a-stub-in-node-js">36。Node.js中的存根是什么？</h4>
<p>存根是用来模拟组件行为的程序或函数。存根在测试用例中提供函数的答案。</p>
<h4 id="toc-37-what-is-an-event-loop">37。什么是事件循环？</h4>
<p>Node.js处理异步回调。这是Node.js中非阻塞输入/输出的基础，使其成为最重要的特性之一。记住，Node.js是事件驱动的。由于Node.js的本质是事件驱动的，所以可以将一个侦听器附加到一个事件，以便在事件发生时由前者执行回调。</p>
<p>Node.js执行事件循环，然后继续执行其余代码，而不必等待输出。一旦整个操作结束，它就接收输出并执行回调函数。一旦它收到响应，这些功能就会被一个接一个地执行。</p>
<h4 id="toc-38-what-are-streams-in-node-js-what-are-the-types">38。Node.js中的流是什么？有哪些类型？</h4>
<p>在Node.js中，流是类似于字符串和数组的数据集合。此外，流是对象，通过它可以连续读取源数据或写入目标数据。这些流对于阅读和处理大量信息特别有帮助。Node.js中有四种类型的流，它们是:</p>
<ul>
<li aria-level="1"><strong>可读</strong>:用于从源读取大量数据</li>
<li aria-level="1"><strong>可写</strong>:用于将数据写入目的地</li>
<li aria-level="1"><strong>双工</strong>:用于读写</li>
<li aria-level="1"><strong>转换</strong>:用于数据修改的双工流</li>
</ul>
<h4 id="toc-39-list-and-explain-the-timing-features-of-node-js">39。列举并解释Node.js. 的计时功能</h4>
<p>Node.js提供了一个定时器模块，该模块包含在特定时间段后执行代码的多个函数。该模块中提供的一些函数包括:</p>
<ul>
<li aria-level="1"><strong> process.nextTick: </strong>该函数调度一个回调函数，该函数需要在事件循环的下一次迭代中被调用</li>
<li aria-level="1"><strong> setTimeout/clearTimeout: </strong>该函数在指定的时间量(以毫秒为单位)后调度代码执行</li>
<li aria-level="1"><strong>set immediate/clear immediate:</strong>该函数在现有事件循环周期结束时执行代码</li>
<li aria-level="1"><strong>setInterval/clearInterval:</strong>该函数用于多次执行一段代码</li>
</ul>

<p>process.nextTick()和setImmediate()都是Timers模块的函数，但是区别在于它们的执行。</p>
<ul>
<li aria-level="1">process.nextTick()函数等待动作的执行，直到事件循环中的下一次循环，或者当事件循环结束时，才调用回调函数。</li>
<li aria-level="1">setImmediate()函数用于在事件循环的下一个周期执行回调方法，该方法将回调方法返回到事件循环以执行输入/输出操作。</li>
</ul>
<h4 id="toc-41-explain-readfile-and-createreadstream-in-node-js">41。解释readFile并在Node.js中创建read stream</h4>
<p>readFile和createReadStream都是读取和执行Node.js提供的文件的方法。</p>
<p>readFile过程是完全缓冲的，只有当整个文件进入缓冲区并且可以读取时才返回响应。此过程占用大量内存，如果文件很大，会变得很慢。</p>
<p>createReadStream进程是部分缓冲的，将整个进程视为一系列事件。在此过程中，整个文件被分割成块进行处理，然后作为响应逐个连续发送。与readFile不同，createReadStream在读取和处理大文件时非常有效。</p>

<h4 id="toc-42-does-node-js-provide-a-debugger"><strong> 42。Node.js提供调试器吗？</strong></h4>
<p>Node.js提供了内置的TCP协议和调试客户端。如果希望调试文件，可以在要调试的js文件名前使用以下参数。</p>

<pre class="language-javascript"><code>node debug [script.js | -e “script” | :]</code></pre>
<h4 id="toc-43-describe-the-exit-codes-in-node-js"><strong> 43。描述Node.js. </strong>中的退出代码</h4>
<p>Node.js中的退出代码是一组特定的代码，用于结束进程，也可以包括全局对象。Node.js中的一些退出代码是:</p>
<ul>
<li aria-level="1">内部JavaScript评估失败</li>
<li aria-level="1">致命错误</li>
<li aria-level="1">内部异常处理程序运行时失败</li>
<li aria-level="1">不用的</li>
<li aria-level="1">未捕获的致命异常</li>
</ul>
<h4 id="toc-44-why-is-node-env-used"><strong> 44。为什么要用NODE_ENV？</strong></h4>
<p>当任何Node.js项目处于生产阶段时，Node.js推广使用NODE_ENV变量来标记它的原则。当NODE-ENV设置为生产时，应用程序的执行速度将比平时快2到3倍。该变量还可以提高项目开发阶段的判断能力。</p>
<h4 id="toc-45-what-is-eventemitter-in-node-js"><strong> 45。Node.js中的EventEmitter是什么？</strong></h4>
<p>Node.js有一个EventEmitter类，它包含所有可以发出事件的对象。这些对象包含一个名为eventEmitter.on()的函数，使用该函数可以将多个函数附加到对象发出的事件。每当EventEmitter类中的一个对象抛出一个事件时，该事件的所有附属函数都会被同步调用。</p>
<h4 id="toc-46-what-is-punycode"><strong> 46。什么是Punycode？</strong></h4>
<p>Punycode可以定义为Node.js中的一种编码语法，它有助于将Unicode字符串转换为ASCII。这样做是因为主机名只能理解ASCII代码，而不能理解Unicode。虽然在最近的版本中，它被捆绑在缺省包中，但是您可以使用下面的代码在以前的版本中使用它:</p>
<pre class="language-javascript"><code>punycode = require(‘punycode’);</code></pre>
<h4 id="toc-47-explain-the-concept-of-jit-and-highlight-its-relationship-with-node-js"><strong> 47。解释JIT的概念并强调它与Node.js的关系</strong></h4>
<p>JIT或即时编译器通过将字节码(由可解释的指令组成)转换成指令，将其发送给处理器。一旦你完成了程序的编写部分，源语言语句就被编译器编译成字节码，而不是类似于目标硬件平台处理器的携带数据的代码。</p>
<p>Node.js采用JIT编译，这在很大程度上提高了代码执行的速度。它获取源代码，并在运行时将其转换为机器码。通过这种方式，定期调用的函数被编译成机器码，提高了代码执行的整体速度。</p>
<h4 id="toc-48-why-is-the-buffer-class-used-in-node-js"><strong> 48。Node.js中为什么使用buffer类？</strong></h4>
<p>在Node.js中，buffer类以类似于整数数组的方式存储原始数据。但是，它与原始内存转储通信，内存转储在V8堆之外分配。buffer类是一个全局类，可以在应用程序中访问它，而不必导入Buffer模块。它通常用于纯JavaScript代码不适合二进制数据的情况。</p>
<h4 id="toc-49-how-do-the-fork-and-spawn-methods-work">49。fork和spawn方法是如何工作的？</h4>
<p> </p>
<p>在Node.js中，spawn()用可用的命令集启动一个新进程。这不会生成新的V8实例；处理器上只有一个节点模块副本是活动的。当您的子进程向节点返回大量数据时，可以使用此方法。</p>
<p>另一方面，fork()是spawn()的一个特例，它生成一个新的V8引擎实例。通过这种方法，多个工作者在单个节点代码库上运行多个任务。</p>
<h4 id="toc-50-state-the-steps-to-write-an-express-js-application">50。陈述编写Express JS应用程序的步骤。</h4>
<p>要设置ExpressJs应用程序，您需要完成以下步骤:</p>
<ul>
<li aria-level="1">用项目名称创建一个文件夹</li>
<li aria-level="1">在文件夹中创建一个名为package.json的文件</li>
<li aria-level="1">在命令提示符下运行“npm install”命令，安装程序包文件中的库\</li>
<li aria-level="1">创建一个名为server.js的文件</li>
<li aria-level="1">在包含名为index.js的文件夹的包中创建“router”文件</li>
<li aria-level="1">应用程序是在包含index.html文件的包中创建的</li>
</ul>
<h2 id="bonus-tips"><strong>奖励提示</strong></h2>
<p>这里有一些额外的建议，可以确保你通过面试。</p>
<ul>
<li aria-level="1"><strong>重点关注Node.js编程面试问题。</strong>我们的综合清单简化了这一部分。你可以在网上找到一些这样的资源，包括Hackr。就像每次科技面试一样，</li>
<li aria-level="1"><strong>练习:</strong>现场编码比清闲更伤脑筋，但面试官需要看到你在行动中的技巧。练习几个编码问题，为面试做准备。</li>
<li aria-level="1"><strong>温习相关工具:</strong>重要的是你有使用其他相关技术工具和<a href="https://hackr.io/blog/nodejs-frameworks">框架的经验</a>。这包括MySQL、Mongo或Postgres，以及React、Angular或前端框架的主干。</li>
</ul>
<h2 id="conclusion-start-preparing-for-your-node-js-interview"><strong>结论:开始准备你的Node.js面试</strong></h2>
<p>说到这里，我们的top Node.js面试问题到此结束。在你准备Node js面试的时候，可以考虑看看由社区成员策划的最好的<a href="https://hackr.io/tutorials/learn-node-js?ref=blog-post"> Node.js教程</a>。这些都会对你的Node js面试有很大的帮助。如果你准备好长期学习了呢？</p>
<p><a href="https://click.linksynergy.com/deeplink?id=jU79Zysihs4&amp;mid=39197&amp;murl=https://www.udemy.com/course/the-complete-nodejs-developer-course-2/"> <strong>报名参加Node.js开发者课程</strong> </a></p>
<h2 id="frequently-asked-questions"><strong>常见问题解答</strong></h2>
<h4 id="toc-1-how-do-i-prepare-for-a-node-interview"><strong> 1。我该如何准备节点面试？</strong></h4>
<p>你可以用我们上面列出的Node js编程面试问题综合清单来准备Node面试。留出时间练习Node.js编码问题！</p>
<h4 id="toc-2-what-is-callback-in-node-js"><strong> 2。节点JS中的回调是什么？</strong></h4>
<p>回调是任务完成时调用的函数。它允许其他代码同时运行，并防止阻塞。</p>
<p><strong>人也在读:</strong></p>


									</div>

									</div>    
</body>
</html>