<html>
<head>
<title>Download PostgreSQL Cheat Sheet PDF for Quick References</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>下载PostgreSQL备忘单PDF作为快速参考</h1>
<blockquote>原文：<a href="https://hackr.io/blog/postgresql-cheat-sheet#0001-01-01">https://hackr.io/blog/postgresql-cheat-sheet#0001-01-01</a></blockquote><div><div class="content">
										<p class="c6">PostgreSQL  <span class="c29">是一个免费的开源关系数据库管理系统(RDBMS)，被称为Postgres。</span></p>
<p class="c6">这个RDBMS提供了各种特性，包括自动更新视图、触发器、物化视图、存储过程、外键和具有ACID(原子性、一致性、隔离性和持久性)属性的事务。</p>
<p class="c6"><span class="c58"> PostgreSQL运行在所有主流操作系统上，包括</span> <span class="c38 c58"> Windows </span> <span class="c29">，macOS，Linux，OpenBSD。然而，它是macOS服务器的默认数据库系统。这个数据库系统可以处理各种各样的工作负载。此外，它还带有强大的插件，如流行的PostGIS地理空间数据库扩展器。</span></p>
<p class="c6">由于PostgreSQL在数据科学中有应用，许多专业人士都渴望将它添加到他们的技能组合中。如果有一个Postgres命令行备忘单来帮助您处理日常任务和开发会怎么样？</p>

<p class="c6">你来对地方了。我们创建了这个PostgreSQL备忘单，其中包含语法、命令、查询和示例，以便在使用PostgreSQL数据库时作为快速参考。</p>
<p class="c6"><span class="c38 c58 c26"> <a href="https://drive.google.com/file/d/1vYMDnW2dxts2c-jmn2reo68ElsrrXmac/view?usp=sharing" target="_blank" rel="noopener">点击这里</a>下载Hackr.io的PostgreSQL备忘单PDF。</span></p>
<p class="c6">让我们开始吧！</p>
<h2 id="h-na18bdvnkiib" class="c18 c42"><span class="c26"> PostgreSQL备忘单</span></h2>
<h3 id="h-ml00b8evmp96" class="c57 c42"><span class="c22">第1部分- PostgreSQL查询备忘单:查询数据</span></h3>
<p class="c2">让我们<span class="c8">讨论在PostgreSQL数据库中查询数据的不同命令或查询。</span></p>
<h4 id="h-anku14vtt7h9"><span class="c26"> 1。选择</span> <span class="c41"> </span></h4>
<p class="c6">这个常用的查询允许您从表中检索信息。这也是最复杂的语句之一，因为它有几个子句。因此，为了更好地理解，我们将它分成了几个部分。</p>
<p class="c6"><span class="c8">语法:</span></p>

<pre class="language-sql"><code>SELECT
  select_list
FROM
  table_name;</code></pre>
<p class="c6"><span class="c8">其中:</span></p>
<p class="c6"><strong><span class="c26">Select _ list</span></strong><span class="c8"><strong/>指定要从特定表格中检索的列数。如果提到多列，必须用逗号分隔。此外，可以使用(*)从特定表的所有列中检索数据。</span></p>
<p class="c6"><span class="c26"><strong>table _ name</strong></span><span class="c8"><strong/>指定要从中检索数据的表格的名称。</span></p>
<ul class="c14 lst-kix_et3f1eeach01-0 start">
<li class="c6 c7 li-bullet-0"><strong> <span class="c11">从一列中查询数据</span> </strong></li>
</ul>
<pre class="language-sql"><code>SELECT first_name FROM customer;</code></pre>
<p class="c6"><span class="c8">在这里，分号指定PostgreSQL语句的结束。</span></p>
<ul class="c14 lst-kix_6lbxeotyxcmc-0 start">
<li class="c6 c7 li-bullet-0"><strong> <span class="c11">查询多列数据</span> </strong></li>
</ul>
<pre class="language-sql"><code>SELECT
  first_name,
  last_name,
  email
FROM
  customer;</code></pre>
<ul>
<li><strong> <span class="c11">查询一个表中所有列的数据。</span>T3】</strong></li>
</ul>
<pre class="language-sql"><code>SELECT * FROM customer;</code></pre>
<p class="c6">我们不建议使用(*)，因为它会影响数据库和应用程序的性能。因此，显式指定所有列的名称。</p>
<ul class="c14 lst-kix_anxbj0c3clrb-0 start">
<li class="c6 c7 li-bullet-0"><strong> <span class="c11">用表达式选择语句。</span>T3】</strong></li>
</ul>
<pre class="language-sql"><code>SELECT 
  first_name || ' ' || last_name,
  email
FROM 
  customer;</code></pre>
<p class="c6 c10">(||)是连接运算符。</p>
<p class="c6"><span class="c8">您也可以简单地使用SELECT语句，而不连接任何子句:</span></p>
<pre class="language-sql"><code>SELECT 5 * 3;</code></pre>
<h4 id="h-ialqd69wqgax"><span class="c23"> 2。列别名</span></h4>
<p class="c6">您可以使用<span class="c8">列别名为列或表达式分配一个临时名称。该别名在查询执行期间暂时存在。</span></p>
<p class="c6"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>SELECT column_name AS alias_name
FROM table_name;</code></pre>
<p class="c6 c10">您也可以省略上述语法中的AS:</p>
<pre class="language-sql"><code>SELECT column_name alias_name
FROM table_name;</code></pre>
<p class="c6 c10">或者</p>
<pre class="language-sql"><code>SELECT expression AS alias_name
FROM table_name;</code></pre>

<p class="c6">假设我们需要从表中检索所有客户的名字和姓氏。我们使用下面的查询:</p>
<pre class="language-sql"><code>SELECT 
  first_name,
  last_name
FROM customer;</code></pre>
<p class="c6 c10">现在，我们将使用别名更改姓氏:</p>
<pre class="language-sql"><code>SELECT 
  first_name,
  last_name AS surname
FROM customer;</code></pre>
<p class="c6 c10">列名“姓氏”更改为“姓氏”。</p>
<p class="c6">您也可以使用下面的查询，提供相同的结果(省略as)。</p>
<pre class="language-sql"><code>SELECT 
  first_name,
  last_name surname
FROM customer;</code></pre>
<ul>
<li><strong> <span class="c11">给表达式分配列别名。</span>T3】</strong></li>
</ul>
<p class="c6">这将检索所有客户的名字和姓氏，中间有一个空格。</p>
<pre class="language-sql"><code>SELECT 
  first_name || ' ' || last_name
FROM 
  customer;</code></pre>
<p class="c6 c10">上面的查询将显示一个没有任何特定列名的表。</p>
<p class="c6"><span class="c8">现在，让我们为连接的列指定一个别名，名为“全名:”</span></p>
<pre class="language-sql"><code>SELECT
   first_name || ' ' || last_name AS full_name
FROM
   customer;</code></pre>
<p class="c6 c10">您将得到一个列名为“full_name”的表</p>
<ul class="c14 lst-kix_4xcebht9b1x5-0 start">
<li class="c6 c7 li-bullet-0"><strong> <span class="c11">用空格分配列别名</span> </strong></li>
</ul>
<p class="c6"><span class="c8">列名为“列别名”</span></p>
<p class="c6"><span class="c8">例如:</span></p>
<pre class="language-sql"><code>SELECT
   first_name || ' ' || last_name "full name"
FROM
   customer;</code></pre>
<h3 id="learn-postgresql-from-a-top-rated-database-instructor">向一流的数据库讲师学习Postgresql！<br/><a href="https://click.linksynergy.com/deeplink?id=Qouy7GhEEFU&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Ftopic%2Fpostgresql%2F" target="_blank" rel="noopener"><img src="../Images/6eeb57828ccf22131ac39c81c49a6666.png" alt="postgresql" data-original-src="https://hackr.io/blog/media/postgresql.png"/>T3】</a></h3>
<p class="c6 c10">上述查询将显示一个列名为“full_name”的表。</p>
<h4 id="h-w8yfilrnjkr0"><span class="c23"> 3。排序依据</span></h4>
<p class="c6">“S <span class="c8"> elect”查询结果没有组织起来。因此，您可以使用“order by”子句按升序或降序组织它。</span></p>
<p class="c6"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>SELECT
        select_list
FROM
        table_name
ORDER BY
        sort_expression1 [ASC | DESC],
       ...
        sort_expressionN [ASC | DESC];</code></pre>
<p class="c6 c10">在上述语法中，排序表达式可以是要在ORDER BY关键字之后排序的列或表达式。对于基于多个列或表达式的数据排序，必须在两个列或表达式之间放置逗号(，)来分隔它们。然后，您必须指定升序或降序。</p>
<p class="c6"><span class="c8">注意:“order by”子句必须是任何选择查询中的最后一个。</span></p>

<ul class="c14 lst-kix_tayngsnub9zb-0 start">
<li class="c6 c7 li-bullet-0"><strong> <span class="c11">按一列排序。</span>T3】</strong></li>
</ul>
<pre class="language-sql"><code>SELECT
        first_name,
        last_name
FROM
        customer
ORDER BY
        first_name ASC;</code></pre>
<p class="c6 c10">该查询将显示一个表，其中有一列按升序排列的所有客户的名字。</p>
<p class="c6"><span class="c8">此外，如果没有在order by子句</span>中指定(asc或desc ),则默认为升序</p>
<p class="c6"><span class="c8">因此，以下查询将显示相同的输出:</span></p>
<pre class="language-sql"><code>SELECT
        first_name,
        last_name
FROM
        customer
ORDER BY
        first_name;</code></pre>
<ul>
<li><strong> <span class="c11">按多列排序行。</span>T3】</strong></li>
</ul>
<pre class="language-sql"><code>SELECT
        first_name,
        last_name
FROM
        customer
ORDER BY
        first_name ASC,
        last_name DESC;</code></pre>
<p class="c6">上面的查询将显示一个有两列的表，名字和姓氏。first_name列将按升序排列客户的名字，而last_name列将按降序排列客户的姓氏。</p>
<ul class="c14 lst-kix_pdoyqhk45mey-0 start">
<li class="c6 c7 li-bullet-0"><strong> <span class="c11">按表达式排序行。</span>T3】</strong></li>
</ul>
<pre class="language-sql"><code>SELECT 
        first_name,
        LENGTH(first_name) len
FROM
        customer
ORDER BY 
        len DESC;</code></pre>
<p class="c6 c10">该查询将显示一个包含两列的表，即first_name和它们的长度。它根据名字的长度对行进行降序排序。</p>
<ul class="c14 lst-kix_d9ruqzvht0gi-0 start">
<li class="c6 c7 li-bullet-0"><strong> <span class="c11">对空值行进行排序。</span>T3】</strong></li>
</ul>
<p class="c6"><span class="c8"> Null表示缺失或未知的数据。您甚至可以对包含空值的行进行排序。</span></p>
<pre class="language-sql"><code>ORDER BY sort_expresssion [ASC | DESC] [NULLS FIRST | NULLS LAST]</code></pre>
<p class="c6"><strong> <span class="c11"> -创建新表</span> </strong></p>
<pre class="language-sql"><code>CREATE TABLE sort_demo(
        num INT
);</code></pre>
<p class="c6 c10"><strong><span class="c11">——插入一些数据</span> </strong></p>
<pre class="language-sql"><code>INSERT INTO sort_demo(num)
VALUES(1),(2),(3),(null);</code></pre>
<ul>
<li><strong> <span class="c11">对空值行进行排序。</span>T3】</strong></li>
</ul>
<pre class="language-sql"><code>SELECT num
FROM sort_demo
ORDER BY num;​</code></pre>
<table class="c4">
<tbody>
<tr class="c3">
<td class="c16" colspan="1" rowspan="1"> </td>
<td class="c56" colspan="1" rowspan="1">
<p class="c19"><strong><span class="c11">num</span>T3】</strong></p>
<p class="c19"><span class="c8">整数</span></p>
</td>
</tr>
<tr class="c3">
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 1 </span></p>
</td>
<td class="c56" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 1 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 2 </span></p>
</td>
<td class="c56" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 2 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 3 </span></p>
</td>
<td class="c56" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 3 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 4 </span></p>
</td>
<td class="c56" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> [null] </span></p>
</td>
</tr>
</tbody>
</table>
<p class="c6">如你所见，空值默认是最后一个。</p>
<p class="c6">下面的查询将提供相同的结果。</p>

<pre class="language-sql"><code>SELECT num
FROM sort_demo
ORDER BY num NULLS LAST;</code></pre>
<p class="c6"><span class="c8">但是为了首先获得空值行，您必须显式地提到它:</span></p>

<pre class="language-sql"><code>SELECT num
FROM sort_demo
ORDER BY num NULLS FIRST;</code></pre>
<p class="c6 c10">您将获得以下输出:</p>
<table class="c4">
<tbody>
<tr class="c3">
<td class="c16" colspan="1" rowspan="1"> </td>
<td class="c56" colspan="1" rowspan="1">
<p class="c19"><strong><span class="c11">num</span>T3】</strong></p>
<p class="c19"><span class="c8">整数</span></p>
</td>
</tr>
<tr class="c3">
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 1 </span></p>
</td>
<td class="c56" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> [null] </span></p>
</td>
</tr>
<tr class="c3">
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 2 </span></p>
</td>
<td class="c56" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 1 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 3 </span></p>
</td>
<td class="c56" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 2 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 4 </span></p>
</td>
<td class="c56" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 3 </span></p>
</td>
</tr>
</tbody>
</table>
<h4 id="h-jul7bldc7dp4"><span class="c23"> 4。选择不同的</span></h4>
<p class="c6">这个<span class="c8">从结果集中删除重复的行。可以将DISTINCT子句应用于select语句的选择列表中的一列或多列。</span></p>
<p class="c6"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>SELECT
  DISTINCT column1
FROM
  table_name;</code></pre>
<p class="c6 c10">或者:</p>
<pre class="language-sql"><code>SELECT
  DISTINCT column1, column2
FROM
  table_name;</code></pre>
<p class="c6 c10">或者:</p>
<pre class="language-sql"><code>SELECT
  DISTINCT ON (column1) column_alias,
  column2
FROM
  table_name
ORDER BY
  column1,
  column2;</code></pre>
<p class="c6 c10">例如，我们将使用以下查询创建一个distinct_demo表，并插入一些数据。</p>
<pre class="language-sql"><code>CREATE TABLE distinct_demo (
        id serial NOT NULL PRIMARY KEY,
        bcolor VARCHAR,
        fcolor VARCHAR
);</code></pre>
<p class="c6"><span class="c8">使用以下查询插入行。</span></p>
<pre class="language-sql"><code>INSERT INTO distinct_demo (bcolor, fcolor)
VALUES
        ('red', 'red'),
        ('red', 'red'),
        ('red', NULL),
        (NULL, 'red'),
        ('red', 'green'),
        ('red', 'blue'),
        ('green', 'red'),
        ('green', 'blue'),
        ('green', 'green'),
        ('blue', 'red'),
        ('blue', 'green'),
        ('blue', 'blue');</code></pre>
<p><strong> <span class="c11">不使用相异子句</span> </strong></p>
<pre class="language-sql"><code>SELECT
        id,
        bcolor,
        fcolor
FROM
        distinct_demo ;</code></pre>
<p class="c6 c10">输出:</p>
<table class="c4">
<tbody>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1"><strong> <span class="c11"> id </span> </strong></td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8">整数</span></p>
<p class="c19"><strong><span class="c11">b颜色</span> </strong></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8">字符变化</span></p>
<p class="c19"><strong> <span class="c11">颜色</span> </strong></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8">字符变化</span></p>
<p class="c19"><span class="c8"> 1 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 1 </span></p>
</td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 2 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 2 </span></p>
</td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 3 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 3 </span></p>
</td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> [null] </span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 4 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 4 </span></p>
</td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> [null] </span></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 5 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 5 </span></p>
</td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 6 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 6 </span></p>
</td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 7 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 7 </span></p>
</td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 8 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 8 </span></p>
</td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 9 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 9 </span></p>
</td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 10 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 10 </span></p>
</td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 11 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 11 </span></p>
</td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 12 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c39" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 12 </span></p>
</td>
<td class="c33" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
</td>
<td class="c16" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><strong> <span class="c11">一列中的Distinct子句。</span>T3】</strong></p>
</td>
</tr>
</tbody>
</table>
<ul>
<li>输出:</li>
</ul>
<pre class="language-sql"><code>SELECT
        DISTINCT bcolor
FROM
        distinct_demo
ORDER BY
        bcolor;</code></pre>
<p class="c6 c10"><strong><span class="c26">b颜色</span> <span class="c8"> </span> </strong></p>

<table class="c4">
<tbody>
<tr class="c3">
<td class="c48" colspan="1" rowspan="1"><span class="c8">字符变化</span></td>
<td class="c44" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 1 </span></p>
<p class="c19"><span class="c8">蓝色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c48" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 2 </span></p>
</td>
<td class="c44" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c48" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 3 </span></p>
</td>
<td class="c44" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c48" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 4 </span></p>
</td>
<td class="c44" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> [null] </span></p>
</td>
</tr>
<tr class="c3">
<td class="c48" colspan="1" rowspan="1">
<p class="c19"><strong> <span class="c11">在多列上截然不同。</span>T3】</strong></p>
</td>
<td class="c44" colspan="1" rowspan="1">
<p class="c19">输出:</p>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong><span class="c11">b颜色</span> </strong></li>
</ul>
<pre class="language-sql"><code>SELECT
        DISTINCT bcolor,
        fcolor
FROM
        distinct_demo
ORDER BY
        bcolor,
        fcolor;</code></pre>
<p class="c6 c10"><span class="c8">字符变化</span></p>

<table class="c4">
<tbody>
<tr class="c3">
<td class="c24" colspan="1" rowspan="1"><strong> <span class="c11">颜色</span> </strong></td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8">字符变化</span></p>
<p class="c19"><span class="c8"> 1 </span></p>
</td>
<td class="c20" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
<p class="c19"><span class="c8">蓝色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c24" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 2 </span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
</td>
<td class="c20" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c24" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 3 </span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
</td>
<td class="c20" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c24" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 4 </span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
<td class="c20" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c24" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 5 </span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
<td class="c20" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c24" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 6 </span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
<td class="c20" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c24" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 7 </span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c20" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c24" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 8 </span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c20" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c24" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 9 </span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c20" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c24" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 10 </span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c20" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> [null] </span></p>
</td>
</tr>
<tr class="c3">
<td class="c24" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 11 </span></p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> [null] </span></p>
</td>
<td class="c20" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
</tr>
<tr class="c3">
<td class="c24" colspan="1" rowspan="1">
<p class="c19">输出:</p>
</td>
<td class="c21" colspan="1" rowspan="1">
<p class="c19"><strong><span class="c11">b颜色</span> </strong></p>
</td>
<td class="c20" colspan="1" rowspan="1">
<p class="c19"><span class="c8">字符变化</span></p>
</td>
</tr>
</tbody>
</table>

<pre class="language-sql"><code>SELECT
        DISTINCT ON (bcolor) bcolor,
        fcolor
FROM
        distinct_demo
ORDER BY
        bcolor,
        fcolor;</code></pre>
<p class="c6 c10"><strong> <span class="c11">颜色</span> </strong></p>
<table class="c4">
<tbody>
<tr class="c3">
<td class="c34" colspan="1" rowspan="1"><span class="c8">字符变化</span></td>
<td class="c35" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 1 </span></p>
<p class="c19"><span class="c8">蓝色</span></p>
</td>
<td class="c47" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
<p class="c19"><span class="c8"> 2 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c34" colspan="1" rowspan="1">
<p class="c19"><span class="c8">绿色</span></p>
</td>
<td class="c35" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
</td>
<td class="c47" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 3 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c34" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c35" colspan="1" rowspan="1">
<p class="c19"><span class="c8">蓝色</span></p>
</td>
<td class="c47" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> 4 </span></p>
</td>
</tr>
<tr class="c3">
<td class="c34" colspan="1" rowspan="1">
<p class="c19"><span class="c8"> [null] </span></p>
</td>
<td class="c35" colspan="1" rowspan="1">
<p class="c19"><span class="c8">红色</span></p>
</td>
<td class="c47" colspan="1" rowspan="1">
<p class="c19"><span class="c22">第2节-过滤数据</span></p>
</td>
</tr>
<tr class="c3">
<td class="c34" colspan="1" rowspan="1">
<p class="c19">现在，让我们看看可以与SELECT语句一起使用的不同类，以便从数据库表中过滤和检索数据。</p>
</td>
<td class="c35" colspan="1" rowspan="1">
<p class="c19"><span class="c23"> 1。Where子句</span></p>
</td>
<td class="c47" colspan="1" rowspan="1">
<p class="c19"><span class="c8">它用于根据提到的特定条件检索行。</span></p>
</td>
</tr>
</tbody>
</table>
<h3 id="h-rceuxhpiwu3e" class="c57 c42"><span class="c8">语法:</span></h3>
<p class="c6">条件必须评估为真、假或未知。它可以是布尔表达式，也可以是使用AND和or运算符的布尔表达式的组合。只有满足条件的行将被返回。</p>
<h4 id="h-kclaz6k96ga"><span class="c8">在where子句中，可以使用逻辑和比较运算符:</span></h4>
<p class="c6"><strong> <span class="c11">操作员</span> </strong></p>
<p class="c6"><strong> <span class="c11">描述</span> </strong></p>
<pre class="language-sql"><code>SELECT select_list
FROM table_name
WHERE condition
ORDER BY sort_expression</code></pre>
<p class="c6 c10"><span class="c8"> = </span></p>
<p class="c18 c51"><span class="c8">等于</span></p>
<table class="c65">
<tbody>
<tr class="c69">
<td class="c31" colspan="1" rowspan="1">
<p class="c6"><span class="c8">&gt;T1】</span></p>
</td>
<td class="c61 c51" colspan="1" rowspan="1">
<p class="c6"><span class="c8">大于</span></p>
</td>
</tr>
<tr class="c40">
<td class="c31" colspan="1" rowspan="1">
<p class="c6"><span class="c8">&lt;T1】</span></p>
</td>
<td class="c61 c51" colspan="1" rowspan="1">
<p class="c6"><span class="c8">小于</span></p>
</td>
</tr>
<tr class="c50">
<td class="c31" colspan="1" rowspan="1">
<p class="c6"><span class="c8"> &gt; = </span></p>
</td>
<td class="c51 c61" colspan="1" rowspan="1">
<p class="c6"><span class="c8">大于或等于</span></p>
</td>
</tr>
<tr class="c50">
<td class="c31" colspan="1" rowspan="1">
<p class="c6"><span class="c8"> &lt; = </span></p>
</td>
<td class="c61 c51" colspan="1" rowspan="1">
<p class="c6"><span class="c8">小于或等于</span></p>
</td>
</tr>
<tr class="c50">
<td class="c31" colspan="1" rowspan="1">
<p class="c6"><span class="c8"> &lt; &gt;或者！= </span></p>
</td>
<td class="c36" colspan="1" rowspan="1">
<p class="c6"><span class="c8">不等于</span></p>
</td>
</tr>
<tr class="c50">
<td class="c31" colspan="1" rowspan="1">
<p class="c6"><span class="c8">和</span></p>
</td>
<td class="c36" colspan="1" rowspan="1">
<p class="c6"><span class="c8">逻辑运算符和</span></p>
</td>
</tr>
<tr class="c50">
<td class="c31" colspan="1" rowspan="1">
<p class="c6"><span class="c8">或</span></p>
</td>
<td class="c61 c51" colspan="1" rowspan="1">
<p class="c6"><span class="c8">逻辑运算符或</span></p>
</td>
</tr>
<tr class="c50">
<td class="c31" colspan="1" rowspan="1">
<p class="c6">在…里</p>
</td>
<td class="c36" colspan="1" rowspan="1">
<p class="c6"><span class="c8">如果一个值匹配列表中的任何值，则返回true</span></p>
</td>
</tr>
<tr class="c50">
<td class="c31" colspan="1" rowspan="1">
<p class="c6"><span class="c8">之间</span></p>
</td>
<td class="c36" colspan="1" rowspan="1">
<p class="c6"><span class="c8">如果一个值在一系列值之间，则返回true</span></p>
</td>
</tr>
<tr class="c50">
<td class="c52" colspan="1" rowspan="1">
<p class="c6"><span class="c8">喜欢</span></p>
</td>
<td class="c36" colspan="1" rowspan="1">
<p class="c6"><span class="c8">如果一个值与一个模式匹配，则返回true</span></p>
</td>
</tr>
<tr class="c50">
<td class="c52" colspan="1" rowspan="1">
<p class="c6"><span class="c8">为空</span></p>
</td>
<td class="c36" colspan="1" rowspan="1">
<p class="c6"><span class="c8">如果值为空，则返回true</span></p>
</td>
</tr>
<tr class="c50">
<td class="c52" colspan="1" rowspan="1">
<p class="c6"><span class="c8">不是</span></p>
</td>
<td class="c36" colspan="1" rowspan="1">
<p class="c6"><span class="c8">否定其他算子的结果</span></p>
</td>
</tr>
<tr class="c50">
<td class="c52" colspan="1" rowspan="1">
<p class="c6">上面的查询返回一个包含两列的表，即姓氏和名字，其中名字列上的值只包含Jamie。</p>
</td>
<td class="c36" colspan="1" rowspan="1">
<p class="c6">上面返回的表中，姓氏列中的值为Rice，名字列中的值为Jamie。</p>
</td>
</tr>
<tr class="c50">
<td class="c31" colspan="1" rowspan="1">
<p class="c6">该查询返回一个表，其中包含姓氏为Rodriguez或名字为Adam的值。</p>
</td>
<td class="c36" colspan="1" rowspan="1">
<p class="c6">它返回一个包含名字为Ann、Anne和Annie的值的表。</p>
</td>
</tr>
</tbody>
</table>

<pre class="language-sql"><code>SELECT
        last_name,
        first_name
FROM
        customer
WHERE
        first_name = 'Jamie';</code></pre>
<p class="c6"><span class="c8">该查询返回一个名字列值以‘Ann’开头的表。</span></p>

<pre class="language-sql"><code>SELECT
        last_name,
        first_name
FROM
        customer
WHERE
        first_name = 'Jamie' AND 
       last_name = 'Rice';</code></pre>
<p class="c6 c10">您将得到一个包含所有名字的表，其长度在3到5之间变化。</p>

<pre class="language-sql"><code>SELECT
        first_name,
        last_name
FROM
        customer
WHERE
        last_name = 'Rodriguez' OR 
        first_name = 'Adam';</code></pre>
<p class="c6 c10"><strong> <span class="c11">使用不等于(&lt; &gt;)的运算符。</span>T3】</strong></p>

<pre class="language-sql"><code>SELECT
        first_name,
        last_name
FROM
        customer
WHERE 
        first_name IN ('Ann','Anne','Annie');</code></pre>
<p class="c6 c10">上述查询返回一个表，其中包含first_name列中以“Bra”开头的值，以及last_name列中除“Motley”以外的所有其他值。</p>

<pre class="language-sql"><code>SELECT
        first_name,
        last_name
FROM
        customer
WHERE 
        first_name LIKE 'Ann%'</code></pre>
<p class="c6"><span class="c23"> 2。极限值</span></p>

<pre class="language-sql"><code>SELECT
        first_name,
        LENGTH(first_name) name_length
FROM
        customer
WHERE 
        first_name LIKE 'A%' AND
        LENGTH(first_name) BETWEEN 3 AND 5
ORDER BY
        name_length;</code></pre>
<p class="c6 c10">此子句将约束查询返回的行数。</p>
<ul class="c14 lst-kix_eld0bn4jh4j5-0 start">
<li class="c6 c7 li-bullet-0"><span class="c8">语法:</span></li>
</ul>
<pre class="language-sql"><code>SELECT 
        first_name,
        last_name
FROM 
        customer
WHERE 
        first_name LIKE 'Bra%' AND 
        last_name &lt;&gt; 'Motley';</code></pre>
<p class="c6 c10"><span class="c8">该语句返回查询生成的row_count行。如果row_count为零，查询将返回一个空集。如果row_count为NULL，查询将返回相同的结果集，因为它没有LIMIT子句。</span></p>
<h4 id="h-le3y1q6srxbp"><span class="c8">在返回row_count行之前，使用OFFSET子句跳过几行。</span></h4>
<p class="c6"><strong> <span class="c11">使用LIMIT来限制行数。</span>T3】</strong></p>
<p class="c6">该查询返回一个包含film_id、title和release_year的五行表，其中film_id按升序排序。</p>
<pre class="language-sql"><code>SELECT select_list
FROM table_name
ORDER BY sort_expression
LIMIT row_count</code></pre>
<p class="c6">该查询返回一个包含film_id、title和release_year的四行表，其中film_id按升序排序。它从film_id = 4开始计算值，而不是从头开始。</p>
<p class="c6"><strong> <span class="c11">使用偏移量获取顶/底行。</span>T3】</strong></p>
<pre class="language-sql"><code>SELECT select_list
FROM table_name
LIMIT row_count OFFSET row_to_skip;</code></pre>
<ul class="c14 lst-kix_vitkr4ng1fac-0 start">
<li class="c6 c7 li-bullet-0">具有film_id、title和rental_rate列的表包含十行，其中rental_rate按降序排列。</li>
</ul>
<pre class="language-sql"><code>SELECT
        film_id,
        title,
        release_year
FROM
        film
ORDER BY
        film_id
LIMIT 5;</code></pre>
<p class="c6 c10"><span class="c23"> 3。获取</span></p>

<pre class="language-sql"><code>SELECT
        film_id,
        title,
        release_year
FROM
        film
ORDER BY
        film_id
LIMIT 4 OFFSET 3;</code></pre>
<p class="c6 c10"><span class="c8"> PostgreSQL支持FETCH子句来检索查询返回的几行。</span></p>
<ul class="c14 lst-kix_pg38mxog2u6o-0 start">
<li class="c6 c7 li-bullet-0"><span class="c8">语法:</span></li>
</ul>
<pre class="language-sql"><code>SELECT
        film_id,
        title,
        rental_rate
FROM
        film
ORDER BY
        rental_rate DESC
LIMIT 10;</code></pre>
<p class="c6 c10">FETCH子句在功能上等同于LIMIT子句。如果您计划让您的应用程序与其他数据库系统兼容，您应该使用FETCH子句，因为它遵循标准SQL。</p>
<h4 id="h-vayxahi151y4"><span class="c23"> 4。在</span></h4>
<p class="c6">与“where”子句一起使用，t<span class="c8">this子句将检查一个值是否与值列表中的任何值匹配。</span></p>
<p class="c6"><span class="c8">您也可以使用选择查询来代替值:</span></p>
<pre class="language-sql"><code>OFFSET start { ROW | ROWS }
FETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY</code></pre>
<p class="c6 c10"><span class="c8">例如:</span></p>
<h4 id="h-f8l0foi76bdt">我们有1个和2个客户ID，上面的查询将返回一个包含客户ID为1或2的客户数据的表。</h4>
<p class="c6"><span class="c8">上面的查询将返回一个包含所有客户数据的表，除了客户ID为1或2的客户数据</span></p>
<pre class="language-sql"><code>value IN (value1,value2,...)</code></pre>
<p class="c6"><span class="c23"> 5。在</span>之间</p>
<pre class="language-sql"><code>value IN (SELECT column_name FROM table_name);</code></pre>
<p class="c6">此子句将一个值与一系列值进行匹配。</p>
<pre class="language-sql"><code>SELECT customer_id,
        rental_id,
        return_date
FROM
        rental
WHERE
        customer_id IN (1, 2)
ORDER BY
        return_date DESC;</code></pre>
<p class="c6 c10"><span class="c8">语法:</span></p>

<pre class="language-sql"><code>SELECT
        customer_id,
        rental_id,
        return_date
FROM
        rental
WHERE
        customer_id NOT IN (1, 2);</code></pre>
<p class="c6"><span class="c8">值&gt; =低，值&lt; =高</span></p>
<h4 id="h-nalve3xfpzd"><span class="c8">值&lt;低或值&gt;高</span></h4>
<p class="c6">上述查询返回包含customer_id、payment_id和amount的表，其中amount的范围在8和9之间。</p>
<p class="c6"><span class="c8">上面的查询返回带有customer_id、payment_id和amount的表，除了介于8和9之间的金额。</span></p>
<pre class="language-sql"><code>value BETWEEN low AND high;</code></pre>
<p class="c6">上面的查询返回包含customer_id、payment_id、amount和payment_date的表，其中日期范围在2007年2月7日和2007年2月15日之间。</p>
<pre class="language-sql"><code>value NOT BETWEEN low AND high;</code></pre>
<p class="c6"><span class="c23"> 6。比如</span></p>

<pre class="language-sql"><code>SELECT
        customer_id,
        payment_id,
        amount
FROM
        payment
WHERE
        amount BETWEEN 8 AND 9;</code></pre>
<p class="c6 c10"><span class="c8">该操作符将使用类似以下查询的字符串匹配客户的名字:</span></p>

<pre class="language-sql"><code>SELECT
        customer_id,
        payment_id,
        amount
FROM
        payment
WHERE
        amount NOT BETWEEN 8 AND 9;</code></pre>
<p class="c6">您将得到一个包含first_name和last_name列的表，其中first_name列中的值以“Jen”开头。</p>

<pre class="language-sql"><code>SELECT
        customer_id,
        payment_id,
        amount,
payment_date
FROM
        payment
WHERE
        payment_date BETWEEN '2007-02-07' AND '2007-02-15';</code></pre>
<p class="c6">通过组合文字值和通配符，并使用LIKE或NOT LIKE操作符来查找匹配项，可以匹配一个模式。PostgreSQL为您提供了两个通配符:</p>
<h4 id="h-o4frvrdyu5wa"><span class="c8">百分号(%)匹配零个或多个字符的任意序列。</span></h4>
<p class="c6"><span class="c8">下划线(_)匹配任何单个字符。</span></p>
<pre class="language-sql"><code>SELECT
        first_name,
       last_name
FROM
        customer
WHERE
        first_name LIKE 'Jen%';</code></pre>
<p class="c6 c10"><span class="c8">例如:</span></p>
<p class="c6"><span class="c8">选择</span></p>
<ul class="c14 lst-kix_b6x9bytz7ffz-0 start">
<li class="c6 c7 li-bullet-0"><span class="c8">‘福’像‘福’，-真</span></li>
<li class="c6 c7 li-bullet-0"><span class="c8">‘foo’像‘f %’，- true </span></li>
</ul>
<p class="c6"><span class="c8"> 'foo '像' _o_ '，- true </span></p>
<p class="c6"><span class="c8">‘杠’如‘b _’；-假</span></p>
<p class="c6">这将返回一个包含first_name和last_name列的表，其中first_name列中的值以后跟“her”的任何字母开头。</p>
<p class="c6">您将得到一个包含first_name和last_name列的表，其中first_name列包含不以“Jen”开头的值。</p>
<p class="c6"><strong> <span class="c11">使用ILIKE(检查区分大小写)</span> </strong></p>
<p class="c6"><span class="c8">该查询返回一个包含名字和姓氏列的表，其中名字中的值以BAR开头。</span></p>

<pre class="language-sql"><code>SELECT
        first_name,
        last_name
FROM
        customer
WHERE
        first_name LIKE '_her%'
ORDER BY 
       First_name;</code></pre>
<p class="c6 c10"><span class="c23"> 7。为空</span></p>

<pre class="language-sql"><code>SELECT
        first_name,
        last_name
FROM
        customer
WHERE
        first_name NOT LIKE 'Jen%'
ORDER BY 
       first_name</code></pre>
<p class="c6 c10">IS <span class="c8"> NULL条件用于测试SELECT、INSERT、UPDATE和DELETE语句中的NULL值。</span></p>
<ul class="c14 lst-kix_unv700va3ykx-0 start">
<li class="c6 c7 li-bullet-0"><span class="c8">语法:</span></li>
</ul>
<pre class="language-sql"><code>SELECT
        first_name,
        last_name
FROM
        customer
WHERE
        first_name ILIKE 'BAR%';</code></pre>
<p class="c6"><span class="c8">如果表达式为空，则条件评估为真。否则，条件评估为假。</span></p>
<h4 id="h-1wedsggb0fjg">上面的查询返回一个表，该表包含来自employee表中fisst_number为NULL的记录。</h4>
<p class="c6">上面的查询将新数据插入到雇员编号为空值的contacts表中。</p>
<p class="c6">上面的查询更新了employees表中姓氏为空值的记录。</p>
<pre class="language-sql"><code>expression IS NULL;</code></pre>
<p class="c6">上述查询将删除所有雇员编号为空的记录雇员表。</p>

<pre class="language-sql"><code>SELECT *
FROM employees
WHERE first_number is NULL;</code></pre>
<p class="c6"><span class="c22">第3节-连接多个表</span></p>

<pre class="language-sql"><code>INSERT INTO contacts
(first_name, last_name)
SELECT first_name, last_name
FROM employees
WHERE employee_number IS NULL;</code></pre>
<p class="c6">让我们讨论一下PostgreSQL中的‘JOIN ’:</p>

<pre class="language-sql"><code>UPDATE employees
SET status = 'Not Active'
WHERE last_name IS NULL;</code></pre>
<p class="c6 c10"><span class="c23"> 1。加入</span></p>

<pre class="language-sql"><code>DELETE FROM employees
WHERE employee_number IS NULL;</code></pre>
<p class="c6"><span class="c8">您可以根据相关表之间的公共列值，合并一个(自联接)或多个表中的列。公共列通常是第一个表的主键列和第二个表的外键列。</span></p>
<h3 id="h-p7w4bhun4wns" class="c57 c42">为了解释这个概念，我们将使用两个表来执行不同类型的连接。</h3>
<p class="c2"><span class="c8">下面的查询创建了表‘basket _ a:’</span></p>
<h4 id="h-3dnivt3870rl" class="c37">以下查询创建了表' basket_b:'</h4>
<p class="c6">使用以下查询将数据插入' basket_a:'</p>
<p class="c6">以下查询将数据插入' basket_b:'</p>
<p class="c6"><img title="" src="../Images/5de62e5f9078d0608dd533863fcdaf80.png" alt="" data-original-src="https://hackr.io/blog/media/inner-join-min.png"/></p>
<pre class="language-sql"><code>CREATE TABLE basket_a (
   a INT PRIMARY KEY,
   fruit_a VARCHAR (100) NOT NULL
);</code></pre>
<p class="c6 c10"><img title="" src="../Images/c53ff5048abf3941f269ef93937597f3.png" alt="" data-original-src="https://hackr.io/blog/media/left-join-min.png"/></p>
<pre class="language-sql"><code>CREATE TABLE basket_b (
   b INT PRIMARY KEY,
   fruit_b VARCHAR (100) NOT NULL
);</code></pre>
<p class="c6 c10"><img title="" src="../Images/4422691dd2819845f1749833a73772f2.png" alt="" data-original-src="https://hackr.io/blog/media/right-join-min.png"/></p>
<pre class="language-sql"><code>INSERT INTO basket_a (a, fruit_a)
VALUES
   (1, 'Apple'),
   (2, 'Orange'),
   (3, 'Banana'),
   (4, 'Cucumber');</code></pre>
<p class="c6 c10"><img title="" src="../Images/59a9b9a0119cc1d53ac098811aca272c.png" alt="" data-original-src="https://hackr.io/blog/media/full-outer-join-min.png"/></p>
<pre class="language-sql"><code>INSERT INTO basket_b (b, fruit_b)
VALUES
   (1, 'Orange'),
   (2, 'Apple'),
   (3, 'Watermelon'),
   (4, 'Pear');</code></pre>

<pre class="language-sql"><code>SELECT
   a,
   fruit_a,
   b,
   fruit_b
FROM
   basket_a
INNER JOIN basket_b
   ON fruit_a = fruit_b;</code></pre>
<p class="c2"><span class="c23"> 2。表格别名</span></p>

<pre class="language-sql"><code>SELECT
   a,
   fruit_a,
   b,
   fruit_b
FROM
   table_a
LEFT JOIN table_b
  ON fruit_a = fruit_b;</code></pre>
<p class="c2 c10">在查询执行期间，这些函数会临时为表指定新的名称。</p>

<pre class="language-sql"><code>SELECT
   a,
   fruit_a,
   b,
   fruit_b
FROM
   table_a
RIGHT JOIN table_b ON fruit_a = fruit_b;</code></pre>
<p class="c2"><span class="c23"> 3。自连接</span></p>

<pre class="language-sql"><code>SELECT
   a,
   fruit_a,
   b,
   fruit_b
FROM
   table_a
FULL OUTER JOIN table_b
   ON fruit_a = fruit_b;</code></pre>
<p class="c2 c10">自联接是将表联接到自身的常规联接。要形成自连接，需要用不同的表别名指定同一个表两次，并在ON关键字后提供连接谓词。</p>
<h4 id="h-49iz411oqwz" class="c32"><span class="c8">例如，这里有一个员工表，插入了一些数据:</span></h4>
<p class="c2"><img title="" src="../Images/18f1b3dde0ca4e9767d526285fe52f8f.png" alt="" data-original-src="https://hackr.io/blog/media/using-self-join-min.png"/></p>
<pre class="language-sql"><code>table_name AS alias_name;</code></pre>
<h4 id="h-n5u4zyxcnf83" class="c32"><span class="c23"> 4。交叉连接</span></h4>
<p class="c2">这个连接允许你在两个或更多的表中产生一个笛卡尔乘积。与左连接或内连接不同，交叉连接子句没有连接谓词:</p>
<p class="c2"><img title="" src="../Images/be3af9af159f3abf24ceff4f7a127731.png" alt="" data-original-src="https://hackr.io/blog/media/cross-join-min.png"/></p>
<pre class="language-sql"><code>CREATE TABLE employee_data (
        emp_id INT PRIMARY KEY,
        f_name VARCHAR (255) NOT NULL,
        l_name VARCHAR (255) NOT NULL,
        manager_id INT,
        FOREIGN KEY (manager_id)
        REFERENCES employee (emp_id)
        ON DELETE CASCADE
);</code></pre>
<pre class="language-sql"><code>INSERT INTO employee (
        emp_id,
        f_name,
        l_name,
        manager_id
)
VALUES
        (1, 'Sam', 'Dunes', NULL),
        (2, 'Ava', 'Mil', 1),
        (3, 'Harry', 'Man, 1),
        (4, 'Aman', 'Deep', 2),
        (5, 'Sunny', 'Rom', 2),
        (6, 'Kelly', 'Hans', 3),
        (7, 'Tony', 'Cliff, 3),
        (8, 'Sam', 'Lanne', 3);</code></pre>

<pre class="language-sql"><code>SELECT
   e.f_name || ' ' || e.l_name employee,
   m .f_name || ' ' || m .l_name manager
FROM
   employee_data e
INNER JOIN employee_data m ON m .emp_id = e.manager_id
ORDER BY manager;</code></pre>
<p class="c2 c10"><span class="c23"> 5。自然连接</span></p>
<h4 id="h-lnsfq7khjx2t" class="c32">这个<span class="c8">基于连接的表中相同的列名创建一个隐式连接。</span></h4>
<p class="c2"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>CREATE TABLE table_a (
   a INT PRIMARY KEY,
   fruit_a VARCHAR (100) NOT NULL
);​</code></pre>
<pre class="language-sql"><code>CREATE TABLE table_b (
   b INT PRIMARY KEY,
   fruit_b VARCHAR (100) NOT NULL
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO table_a (a, fruit_a)
VALUES
   (1, 'Apple'),
   (2, 'Orange'),
   (3, 'Melon'),
   (4, 'Carrot');​</code></pre>
<pre class="language-sql"><code>INSERT INTO table_b (b, fruit_b)
VALUES
   (1, 'Orange'),
   (2, 'Apple'),
   (3, 'Berry'),
   (4, 'Raddish');</code></pre>
<pre class="language-markup"><code>SELECT * FROM table_a cross join table_b;</code></pre>
<p class="c2"><span class="c8">例如，我们创建了一个表格并插入了一些行:</span></p>
<h4 id="h-xw5ganb5kn3v" class="c32"><img title="" src="../Images/1339a971b9e55a0efdad7406c974caa8.png" alt="" data-original-src="https://hackr.io/blog/media/using-natural-join-min.png"/></h4>
<p class="c2"><span class="c22">第4部分-分组数据</span></p>
<p class="c2"><span class="c23"> 1。Group by子句</span></p>
<pre class="language-sql"><code>SELECT select_list
FROM T1
NATURAL [INNER, LEFT, RIGHT] JOIN T2;</code></pre>
<p class="c2">这个<span class="c8">将SELECT语句返回的行分成几组。对于每个组，您可以应用聚合函数。</span></p>
<pre class="language-sql"><code>DROP TABLE IF EXISTS categories;
CREATE TABLE categories (
        cat_id serial PRIMARY KEY,
        cat_name VARCHAR (255) NOT NULL
);​</code></pre>
<pre class="language-sql"><code>DROP TABLE IF EXISTS products;
CREATE TABLE prod (
        prod_id serial PRIMARY KEY,
        prod_name VARCHAR (255) NOT NULL,
        cat_id INT NOT NULL,
        FOREIGN KEY (cat_id) REFERENCES categories (cat_id)
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO categories (cat_name)
VALUES
        ('Smart Phone'),
        ('Laptop'),
        ('Tablet');​</code></pre>
<pre class="language-sql"><code>INSERT INTO prod (prod_name, cat_id)
VALUES
        ('iPhone', 1),
        ('Samsung Galaxy', 1),
        ('HP Elite', 2),
        ('Lenovo Thinkpad', 2),
        ('iPad', 3),
        ('Kindle Fire', 3);</code></pre>

<pre class="language-sql"><code>SELECT * FROM prod
NATURAL JOIN categories;</code></pre>
<p class="c2 c10"><span class="c8">语法:</span></p>
<h3 id="h-txjvtios3r0s" class="c53 c42">PostgreSQL在FROM和WHERE子句之后、HAVING SELECT、DISTINCT、ORDER BY和LIMIT子句之前计算GROUP BY子句。</h3>
<h4 id="h-t473yz42xkkq" class="c37"><strong> <span class="c11">使用group by而不使用聚合函数</span> </strong></h4>
<p class="c6">您将得到一个错误:</p>
<p class="c6"><span class="c8">列“employee_data.emp_id”必须出现在GROUP BY子句中或用于聚合函数中。</span></p>
<pre class="language-sql"><code>SELECT 
  column_1,
  column_2,
  ...,
  aggregate_function(column_3)
FROM 
  table_name
GROUP BY 
  column_1,
  column_2,
  ...;</code></pre>
<p class="c6 c10"><strong> <span class="c11">用sum()函数分组</span> </strong></p>
<pre class="language-markup"><code>DROP TABLE IF EXISTS employee_data;</code></pre>
<pre class="language-markup"><code>CREATE TABLE employee_data (
        emp_id INT PRIMARY KEY,
        f_name VARCHAR (255) NOT NULL,
        l_name VARCHAR (255) NOT NULL,
        manager_id INT,
        Salary int,
        FOREIGN KEY (manager_id)
        REFERENCES employee_data (emp_id)
        ON DELETE CASCADE
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO employee_data (
        emp_id,
        f_name,
        L_name,
        salary,
        manager_id
)
VALUES
        (1, 'Sam', 'Dunes', 1000,NULL),
        (2, 'Ava', 'Mil', 2000, 1),
        (3, 'Harry', 'Man', 2400, 1),
        (4, 'Aman', 'Deep', 4500, 2),
        (5, 'Sunny', 'Rom', 3455, 2),
        (6, 'Kelly', 'Hans', 6733,  3),
        (7, 'Tony', 'Cliff', 4577, 3),
        (8, 'Sam', 'Lanne', 4533, 3);</code></pre>
<ul>
<li><img title="" src="../Images/367f5fbb992ea4839b61ba2290c52d6a.png" alt="" data-original-src="https://hackr.io/blog/media/group-by-with-sum-function-min.png"/></li>
</ul>
<pre class="language-sql"><code>SELECT
  emp_id
FROM
  employee_data
GROUP BY
  Manager_id;</code></pre>
<p class="c2 c10"><strong> <span class="c11">使用group by with join子句</span> </strong></p>
<p class="c2"><img title="" src="../Images/f5032a8cd91e53e554084f2a5a83c400.png" alt="" data-original-src="https://hackr.io/blog/media/using-group-by-with-join-clause-min.png"/></p>
<ul class="c14 lst-kix_a8h4jkze5dms-0 start">
<li class="c2 c7 li-bullet-0"><strong> <span class="c11">用count()函数分组</span> </strong></li>
</ul>
<pre class="language-sql"><code>SELECT
        emp_id,
        SUM (salary)
FROM
        employee_data
GROUP BY
        emp_id;</code></pre>
<p class="c2 c10"><img title="" src="../Images/aafbb3d0379fa21ee9991c7544201ad0.png" alt="" data-original-src="https://hackr.io/blog/media/group-by-with-count-function-min.png"/></p>
<ul class="c14 lst-kix_p4a8341tn8b1-0 start">
<li class="c2 c7 li-bullet-0"><strong> <span class="c11">用多列分组</span> </strong></li>
</ul>
<pre class="language-sql"><code>SELECT
        f_name || ' ' || l_name full_name,
        SUM (salary) amount
FROM
        employee_data           
GROUP BY
        full_name, employee_data.salary
ORDER BY salary DESC;        </code></pre>
<p class="c2 c10"><img title="" src="../Images/f5b8e03a3df1c08618fe446b16f3ba7d.png" alt="" data-original-src="https://hackr.io/blog/media/group-by-with-multiple-columns-min.png"/></p>
<ul class="c14 lst-kix_goc9d3widmyd-0 start">
<li class="c2 c7 li-bullet-0"><strong> <span class="c11">分组依据与日期列</span> </strong></li>
</ul>
<pre class="language-sql"><code>SELECT
        emp_id,
        COUNT (manager_id)
FROM
        employee_data
GROUP BY
        manager_id;</code></pre>
<p class="c2 c10">Having子句<img title="" src="../Images/6a207d621701782892147e6219dfb802.png" alt="" data-original-src="https://hackr.io/blog/media/group-by-with-date-column-min.png"/></p>
<ul class="c14 lst-kix_qjeo1tpytlw4-0 start">
<li class="c2 c7 li-bullet-0"><span class="c8">指定一个组或一个集合的搜索条件。HAVING子句通常与GROUP BY子句一起使用，根据指定的条件筛选组或聚合。</span></li>
</ul>
<pre class="language-sql"><code>SELECT 
        emp_id,
        manager_id,
        SUM(salary)
FROM 
        employee_data
GROUP BY 
        manager_id,
        emp_id
ORDER BY 
   emp_id;</code></pre>
<p class="c2 c10"><span class="c8">语法:</span></p>
<ul class="c14 lst-kix_u4pkaupb6czi-0 start">
<li class="c2 c7 li-bullet-0">PostgreSQL在FROM、WHERE、GROUP BY之后、SELECT、DISTINCT、ORDER BY和LIMIT子句之前计算HAVING子句。</li>
</ul>
<pre class="language-sql"><code>SELECT 
                emp_id, manager_id, SUM(salary) sum
FROM 
        employee_data
GROUP BY
        emp_id, manager_id,salary ;</code></pre>
<p class="c2"><strong> <span class="c11">使用具有求和功能的having</span></strong></p>
<p class="c2"><img title="" src="../Images/d7c9e9277d61bd3b2298f5c04e0f014d.png" alt="" data-original-src="https://hackr.io/blog/media/using-having-with-a-sum-function-min.png"/></p>
<p class="c2"><strong> <span class="c11">使用having子句与count函数</span> </strong></p>
<pre class="language-sql"><code>SELECT
        column1,
        aggregate_function (column2)
FROM
        table_name
GROUP BY
        column1
HAVING
        condition;</code></pre>
<p class="c2 c10"><img title="" src="../Images/375c9abb4b2d7767f4adaa0e34e5b84f.png" alt="" data-original-src="https://hackr.io/blog/media/using-the-having-clause-with-the-count-function-min.png"/></p>
<ul class="c14 lst-kix_hkz251rzkz0e-0 start">
<li class="c2 c7 li-bullet-0"><span class="c22">第5节-设定操作</span></li>
</ul>
<pre class="language-sql"><code>SELECT
        EMP_id,
        SUM (SALARY)
FROM
        EMPLOYEE_DATA
GROUP BY
        emp_id;</code></pre>
<p class="c2 c10">本节将带您了解PostgreSQL支持的不同集合操作。</p>
<ul class="c14 lst-kix_y25e737pci3w-0 start">
<li class="c2 c7 li-bullet-0"><span class="c23"> 1。工会</span></li>
</ul>
<pre class="language-sql"><code>SELECT
        manager_id,
        COUNT (emp_id)
FROM
        employee_data
GROUP BY
        manager_id;</code></pre>
<p class="c2 c10"><span class="c8">它将两个或多个SELECT语句的结果集合并成一个结果集。</span></p>
<h3 id="h-b4otnu7xw74" class="c57 c42"><span class="c8">语法:</span></h3>
<p class="c2">例如，我们创建了两个表，并在其中插入数据来执行union。</p>
<h4 id="h-bkxjy7o2ihvx" class="c32"><img title="" src="../Images/b3abd02cfc5c3360e0ef1abbb34bcd76.png" alt="" data-original-src="https://hackr.io/blog/media/union-min.png"/></h4>
<p class="c2"><img title="" src="../Images/71f78a0947f9c89148b51394ba5ad44e.png" alt="" data-original-src="https://hackr.io/blog/media/popular-films-min.png"/></p>
<p class="c2"><img title="" src="../Images/fdaa1b2840b6062c9123d476f4569cd9.png" alt="" data-original-src="https://hackr.io/blog/media/union-example-min.png"/></p>
<pre class="language-sql"><code>SELECT select_list_1
FROM table_expresssion_1
UNION
SELECT select_list_2
FROM table_expression_2</code></pre>
<p class="c2 c10"><img title="" src="../Images/eee8ec61a2af42f6777738ab42f6bf5c.png" alt="" data-original-src="https://hackr.io/blog/media/union-all-example-min.png"/></p>
<pre class="language-sql"><code>DROP TABLE IF EXISTS top_films;
CREATE TABLE top_films(
        title VARCHAR NOT NULL,
        release_year SMALLINT
);​</code></pre>
<pre class="language-sql"><code>DROP TABLE IF EXISTS popular_films;
CREATE TABLE popular_films(
        title VARCHAR NOT NULL,
        release_year SMALLINT
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO 
  top_films(title,release_year)
VALUES
  ('hello',1994),
  ('The Godfather',1972),
  ('james bond',1957);​</code></pre>
<pre class="language-sql"><code>INSERT INTO 
  popular_films(title,release_year)
VALUES
  ('shore',2020),
  ('The Godfather',1972),
  ('mickey mouse,2020);​</code></pre>
<pre class="language-sql"><code>SELECT * FROM top_films;</code></pre>
<p class="c2"><img title="" src="../Images/82bb61b31e9bf705c8ad31987a477ccb.png" alt="" data-original-src="https://hackr.io/blog/media/union-all-with-order-by-min.png"/></p>
<pre class="language-sql"><code>SELECT * FROM popular_films;</code></pre>
<p class="c2"><span class="c23"> 2。相交</span></p>

<pre class="language-sql"><code>SELECT * FROM top_films
UNION
SELECT * FROM popular_films;</code></pre>
<p class="c2"><span class="c8">该运算符将两个或多个SELECT语句的结果集组合成一个结果集。</span></p>

<pre class="language-sql"><code>SELECT * FROM top_films
UNION ALL
SELECT * FROM popular_films;</code></pre>
<p class="c2"><span class="c8">语法:</span></p>

<pre class="language-sql"><code>SELECT * FROM top_films
UNION ALL
SELECT * FROM popular_films
ORDER BY title;</code></pre>
<p class="c2 c10">请确保列数相同，并且具有要合并的兼容数据类型。</p>
<h4 id="h-3c54oz5s2k8s" class="c32"><strong> <span class="c11">与一个order by子句</span> </strong>相交</h4>
<p class="c2">例如，我们将交叉两个表:popular_films和top_films:</p>
<p class="c2"><img title="" src="../Images/2432cebcada0eb23a7dbefa4f365a81c.png" alt="" data-original-src="https://lh3.googleusercontent.com/3HHaASlg_tr7gFkW7bXuYNjeMtjRPXXytVhgR4XXUVqPo89IarBUtl-VzP1aAi0wseoGjdVkyZnlh1VdnLji8hbtITz3IWI3MgtKGsqT3vu9ZUvTrE_cSYh-bLP3GGem9oFBzRSH_5fvLVvn_w"/></p>
<pre class="language-sql"><code>SELECT select_list
FROM A
INTERSECT
SELECT select_list
FROM B;</code></pre>
<p class="c2 c10"><span class="c22">第6节-分组集、立方体和汇总</span></p>
<ul class="c14 lst-kix_aemzrl3ktazc-0 start">
<li class="c2 c7 li-bullet-0"><span class="c23"> 1。分组集合</span></li>
</ul>
<pre class="language-sql"><code>SELECT select_list
FROM A
INTERSECT
SELECT select_list
FROM B
ORDER BY sort_expression;</code></pre>
<p class="c2 c10">这可以在一个查询中生成多个分组集。为了解释，我们将创建销售表:</p>
<pre class="language-sql"><code>SELECT *
FROM popular_films
INTERSECT
SELECT *
FROM top_films;</code></pre>
<p class="c2"><img title="" src="../Images/cad31e3781a002babdef88c3992b4d98.png" alt="" data-original-src="https://hackr.io/blog/media/grouping-sets-1.png"/></p>
<h3 id="h-dvqkl980u0cx" class="c53 c42"><span class="c8">分组集是使用GROUP BY子句分组的一组列。分组集的语法由括号中的多列组成，用逗号分隔。</span></h3>
<h4 id="h-xvh2ikh7uzkd" class="c32"><span class="c8">语法:</span></h4>
<p class="c2"><img title="" src="../Images/fdd422d9a899ebbc911eb335ad991cd7.png" alt="" data-original-src="https://hackr.io/blog/media/column1-column2.png"/></p>
<pre class="language-sql"><code>DROP TABLE IF EXISTS sales;
CREATE TABLE sales (
   brand VARCHAR NOT NULL,
   segment VARCHAR NOT NULL,
   quantity INT NOT NULL,
   PRIMARY KEY (brand, segment)
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO sales (brand, segment, quantity)
VALUES
   ('zara', 'Premium', 100),
   ('hnm', 'Basic', 200),
   ('aldo', 'Premium', 100),
   ('baggit', 'Basic', 300);​</code></pre>
<pre class="language-sql"><code>SELECT * FROM sales;</code></pre>
<p class="c2"><img title="" src="../Images/1591dd3c9abf66c5a7cd7e4048fd2ae0.png" alt="" data-original-src="https://hackr.io/blog/media/sum-quantity.png"/></p>
<p class="c2"><img title="" src="../Images/d409d06c3f59bb82e055fd9f9445e639.png" alt="" data-original-src="https://hackr.io/blog/media/segment.png"/> <strong> <span class="c11">分组集合的一般语法</span> </strong></p>
<p class="c2">例如:</p>
<pre class="language-sql"><code>(column1, column2, ...)</code></pre>
<pre class="language-sql"><code>SELECT
   brand,
   segment,
   SUM (quantity)
FROM
   sales
GROUP BY
   brand,
   segment;</code></pre>
<p class="c2 c10"><img title="" src="../Images/84a60af208ed2a2c3033a34248f8ef12.png" alt="" data-original-src="https://hackr.io/blog/media/brand-segment-min.png"/></p>
<pre class="language-sql"><code>SELECT
   brand,
   SUM (quantity)
FROM
   sales
GROUP BY
   brand;</code></pre>
<p class="c2 c10"><span class="c23"> 2。立方体</span></p>
<pre class="language-sql"><code>SELECT
   segment,
   SUM (quantity)
FROM
   sales
GROUP BY
   segment;</code></pre>
<p class="c2 c10"><span class="c8"> CUBE是GROUP BY子句的子子句。多维数据集允许您生成多个分组集。</span></p>
<pre class="language-sql"><code>SELECT
   c1,
   c2,
   aggregate_function(c3)
FROM
   table_name
GROUP BY
   GROUPING SETS (
       (c1, c2),
       (c1),
       (c2),
       ()
);</code></pre>
<p class="c2 c10"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>SELECT
   brand,
   segment,
   SUM (quantity)
FROM
   sales
GROUP BY
   GROUPING SETS (
       (brand, segment),
       (brand),
       (segment),
       ()
   );</code></pre>
<p class="c2 c10">CUBE子子句是定义多个分组集的一种简单方法，因此下面的两个查询是等价的。</p>
<h4 id="h-uxwzugytvxmh" class="c32">我们将使用“sales”表来理解CUBE子句:</h4>
<p class="c2"><img title="" src="../Images/f041f8d139874d428a127901d733e554.png" alt="" data-original-src="https://hackr.io/blog/media/cube-min.png"/></p>
<p class="c2"><img title="" src="../Images/a24c53d4a333afb21add38b25e9d260b.png" alt="" data-original-src="https://hackr.io/blog/media/order-by-min.png"/></p>
<pre class="language-sql"><code>SELECT
   c1,
   c2,
   c3,
   aggregate (c4)
FROM
   table_name
GROUP BY
   CUBE (c1, c2, c3);</code></pre>
<p class="c2"><img title="" src="../Images/f431c5491b65e3527f375b0b1130fa86.png" alt="" data-original-src="https://hackr.io/blog/media/partial-cube-min.png"/></p>
<pre class="language-sql"><code>CUBE(c1,c2,c3)</code></pre>
<pre class="language-sql"><code>GROUPING SETS (
   (c1,c2,c3),
   (c1,c2),
   (c1,c3),
   (c2,c3),
   (c1),
   (c2),
   (c3),
   ()
)</code></pre>
<p class="c2 c10"><span class="c23"> 3。上卷</span></p>
<pre class="language-sql"><code>SELECT * FROM sales;</code></pre>
<p class="c2">ROLLUP是GROUP BY子句的一个子子句，它为定义多个分组集提供了一种快捷方式。u<span class="c27">n与CUBE subc </span> <span class="c8"> lause一样，ROLLUP不会基于指定的列生成所有可能的分组集。它只是组成了一个子集。</span></p>
<pre class="language-sql"><code>SELECT
   brand,
   segment,
   SUM (quantity)
FROM
   sales
GROUP BY
   CUBE (brand, segment)
ORDER BY
   brand,
   segment;</code></pre>
<p class="c2 c10"><span class="c11">语法:</span></p>

<pre class="language-sql"><code>SELECT
   brand,
   segment,
   SUM (quantity)
FROM
   sales
GROUP BY
   brand,
   CUBE (segment)
ORDER BY
   brand,
   segment;</code></pre>
<p class="c2 c10">例如，我们创建了“销售”表并插入数据:</p>
<h4 id="h-c4hazon9fae6" class="c32"><img title="" src="../Images/70b9698e9a9764a43bb6e0721b0b078a.png" alt="" data-original-src="https://hackr.io/blog/media/cube-min-1.png"/></h4>
<p class="c2"><img title="" src="../Images/b461718ce7209375cc38796194eedf65.png" alt="" data-original-src="https://hackr.io/blog/media/roll-up-example-min.png"/></p>
<p class="c2"><img title="" src="../Images/eee69205b3263b558cf6c59c0a16cdb1.png" alt="" data-original-src="https://hackr.io/blog/media/partial-roll-up-example-min.png"/></p>
<pre class="language-sql"><code>SELECT
   c1,
   c2,
   c3,
   aggregate(c4)
FROM
   table_name
GROUP BY
   ROLLUP (c1, c2, c3);</code></pre>

<pre class="language-sql"><code>SELECT
   c1,
   c2,
   c3,
   aggregate(c4)
FROM
   table_name
GROUP BY
   c1,
   ROLLUP (c2, c3);</code></pre>
<p class="c2 c10"><span class="c22">第7节-子查询</span></p>
<pre class="language-sql"><code>DROP TABLE IF EXISTS sales;
CREATE TABLE sales (
   brand VARCHAR NOT NULL,
   segment VARCHAR NOT NULL,
   quantity INT NOT NULL,
   PRIMARY KEY (brand, segment)
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO sales (brand, segment, quantity)
VALUES
   ('zara', 'Premium', 100),
   ('hnm', 'Basic', 200),
   ('aldo', 'Premium', 100),
   ('baggit', 'Basic', 300);</code></pre>
<pre class="language-sql"><code>SELECT * FROM sales:</code></pre>
<p class="c2"><span class="c26"> 1。子查询</span></p>

<pre class="language-sql"><code>SELECT
   brand,
   segment,
   SUM (quantity)
FROM
   sales
GROUP BY
   ROLLUP (brand, segment)
ORDER BY
   brand,
   segment;</code></pre>
<p class="c2 c10">检索特定的输出有时需要运行多个查询。为了减少步骤，我们使用子查询，即另一个查询中的一个查询。</p>

<pre class="language-sql"><code>SELECT
   segment,
   brand,
   SUM (quantity)
FROM
   sales
GROUP BY
   segment,
   ROLLUP (brand)
ORDER BY
   segment,
   brand;</code></pre>
<p class="c2 c10"><span class="c8">假设我们想知道出租率大于平均水平的电影。我们将创建“电影”表并将值插入其中:</span></p>
<h3 id="h-aaans0ytyemw" class="c57 c42"><img title="" src="../Images/4c92fc47172f31079d24eab1040e6f9c.png" alt="" data-original-src="https://hackr.io/blog/media/rental-rate-min.png"/></h3>
<h4 id="h-dof2vvlag43o" class="c37"><img title="" src="../Images/5e2d60377ab7e07caa5ed38b852cfec4.png" alt="" data-original-src="https://hackr.io/blog/media/avg-rental-rate-1.png"/></h4>
<p class="c2"><img title="" src="../Images/a61821e18b3643202f171642c984ae9a.png" alt="" data-original-src="https://hackr.io/blog/media/rental-rate-min-1.png"/></p>
<p class="c2"><span class="c8">我们使用子查询:</span></p>
<pre class="language-sql"><code>DROP TABLE IF EXISTS film;
CREATE TABLE film (
   film_id INT NOT NULL,
   film_title VARCHAR NOT NULL,
   rental_rate INT NOT NULL,
 
   PRIMARY KEY (film_id)
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO film (film_id, film_title, rental_rate)
VALUES
   (1, 'hunny', 100),
   (2, 'block', 200),
   (3, 'james bond', 300),
   (4, 'sunny', 400);​</code></pre>
<pre class="language-sql"><code>SELECT * FROM film;</code></pre>
<p class="c2"><img title="" src="../Images/99b737ec261f047b2325155b1c39f49d.png" alt="" data-original-src="https://hackr.io/blog/media/film-id-min.png"/></p>
<pre class="language-sql"><code>SELECT
        AVG (rental_rate)
FROM
        film;</code></pre>
<p class="c2 c10"><strong> <span class="c11">子查询带IN运算符</span> </strong></p>
<pre class="language-sql"><code>SELECT
        film_id,
        film_title,
        rental_rate
FROM
        film
WHERE
        rental_rate &gt; 2.98;</code></pre>
<p class="c2"><img title="" src="../Images/41613f884759dc89af558f427da7adf3.png" alt="" data-original-src="https://hackr.io/blog/media/subquery-with-in-operator.png"/></p>
<p class="c2"><span class="c8">上面的例子将只允许单列输出。要获取多个列，请使用子查询:</span></p>
<pre class="language-sql"><code>SELECT
        film_id,
        film_title,
        rental_rate
FROM
        film
WHERE
        rental_rate &gt; (
                SELECT
                        AVG (rental_rate)
                FROM
                        film
        );</code></pre>
<p class="c2 c10"><img title="" src="../Images/1d85dbd370d3f5189f4d4a8197383364.png" alt="" data-original-src="https://hackr.io/blog/media/film-title-min.png"/></p>
<ul class="c14 lst-kix_tmyyzybsq4ry-0 start">
<li class="c2 c7 li-bullet-0"><span class="c23"> 2。任何</span></li>
</ul>
<pre class="language-sql"><code>SELECT
        film_id
FROM
        film
WHERE
        salary BETWEEN '100'
AND '300';</code></pre>
<p class="c2 c10"><span class="c8"> ANY运算符将一个值与子查询返回的一组值进行比较。如果任何子查询值满足条件，则返回true否则，它返回false。</span></p>
<p class="c2"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>SELECT
        film_id,
        film_title
FROM
        film
WHERE
        film_id IN (
                SELECT
                        film_id
                FROM
                        film
                                WHERE
                        rental_rate BETWEEN '100'
                AND '400'
        );</code></pre>
<p class="c2 c10"><span class="c8">例如，查找长度大于或等于任何电影类别最大长度的电影:</span></p>
<h4 id="h-jg831zj7u93v" class="c32"><img title="" src="../Images/a38d06ba2873ca84d1238d77dd232250.png" alt="" data-original-src="https://hackr.io/blog/media/any.png"/></h4>
<p class="c2"><span class="c23"> 3。全部</span></p>
<p class="c2"><span class="c8"> ALL运算符允许您通过将一个值与子查询返回的值列表进行比较来查询数据。</span></p>
<pre class="language-sql"><code>expression operator ANY(subquery)</code></pre>
<p class="c2"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>SELECT film_title
FROM film
WHERE rental_rate &gt;= ANY(
   SELECT MAX( rental_rate )
   FROM film
      );</code></pre>
<p class="c2 c10"><span class="c8">要查找按电影分级分组的所有电影的平均长度，请运行以下查询:</span></p>
<h4 id="h-e47tt9u5deis" class="c32"><img title="" src="../Images/733bce94967b0f739205102737dd4994.png" alt="" data-original-src="https://hackr.io/blog/media/all.png"/></h4>
<p class="c2"><span class="c8">查找长度大于上述平均长度列表的所有影片:</span></p>
<p class="c2"><img title="" src="../Images/190619df9482a6c86b028ab7149b8347.png" alt="" data-original-src="https://hackr.io/blog/media/round-avg-rental-rate-2.png"/></p>
<pre class="language-sql"><code>comparison_operator ALL (subquery)</code></pre>
<p class="c2"><span class="c23"> 4。存在</span></p>
<pre class="language-sql"><code>SELECT
   ROUND(AVG(rental_rate), 2) avg_rate
FROM
   film
GROUP BY
   film_id
ORDER BY
   avg_rate DESC;</code></pre>
<p class="c2">这是一个布尔操作符，测试子查询中是否存在行。</p>
<p class="c2"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>SELECT
   film_id,
   film_title,
   rental_rate
FROM
   film
WHERE
   rental_rate &lt;= ALL (
           SELECT
               ROUND(AVG (rental_rate),2)
           FROM
               film
           GROUP BY
               film_id
   )
ORDER BY
   rental_rate;</code></pre>
<p class="c2 c10">它将接受子查询作为参数。如果子查询至少返回一行，EXISTS的结果为true。如果子查询不返回任何行，EXISTS的结果为false。EXISTS运算符通常与相关子查询一起使用。</p>
<h4 id="h-2ba8f61p33aq" class="c32"><strong> <span class="c11">至少有一笔付款金额大于11的客户</span> </strong></h4>
<p class="c2"><img title="" src="../Images/c95d570a6182e17bdcc4825c602e9c5a.png" alt="" data-original-src="https://hackr.io/blog/media/exists-min.png"/></p>
<p class="c2">没有结果集。</p>
<pre class="language-sql"><code>SELECT 
   column1
FROM 
   table_1
WHERE 
   EXISTS( SELECT 
               1 
           FROM 
               table_2
           WHERE 
               column_2 = table_1.column_1);</code></pre>
<p class="c2 c10"><span class="c22">第8节-常用表表达式</span></p>
<ul class="c14 lst-kix_ck3b4clnruoa-0 start">
<li class="c2 c7 li-bullet-0"><span class="c8">通用表表达式是一个临时结果集，可以在另一个SQL语句中引用，包括SELECT、INSERT、UPDATE或DELETE。公用表表达式是临时的，因为它们只在查询执行期间存在。</span></li>
</ul>
<pre class="language-sql"><code>SELECT f_name,
      l_name
FROM employee_data
WHERE EXISTS
   (SELECT 1
    FROM employee_data
    WHERE salary &gt; 2000 )
ORDER BY f_name,
        l_name;</code></pre>
<p class="c2 c10"><span class="c8">语法:</span></p>

<pre class="language-sql"><code>SELECT f_name,
      l_name
FROM employee_data
WHERE NOT EXISTS
   (SELECT 1
    FROM employee_data
    WHERE salary &lt; 3000)
ORDER BY f_name,
        l_name;</code></pre>
<p class="c2 c10">例如:</p>
<h3 class="c53 c42" id=""><img title="" src="../Images/0a9fffbe540d1e08ba8920d9fe0b95be.png" alt="" data-original-src="https://hackr.io/blog/media/film-id-min-1.png"/></h3>
<h3 id="h-4gpu87hndvw1" class="c53 c42"><img title="" src="../Images/c5d3477401de34bdcdc7befdaedc9636.png" alt="" data-original-src="https://hackr.io/blog/media/joining-cte-with-table-min.png"/></h3>
<p class="c2"><span class="c23"> 1。递归查询</span></p>
<p class="c2"><span class="c8">递归查询指的是递归CTE。它们在查询组织结构、物料清单等分层数据时很有用。</span></p>
<pre class="language-sql"><code>WITH cte_name (column_list) AS (
   CTE_query_definition
)
statement;</code></pre>
<p class="c2 c10"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>WITH cte_film AS (
   SELECT 
       film_id,
       Film_title, rental_rate
         FROM
       film
)​</code></pre>
<pre class="language-markup"><code>SELECT
   film_id,
   film_title,
   rental_rate
FROM 
   cte_film
WHERE
 rental_rate&gt;200
ORDER BY 
   film_title;</code></pre>
<p class="c2 c10">例如，我们创建了“雇员”表并插入了一些数据:</p>

<pre class="language-sql"><code>WITH cte_emp AS (
   SELECT emp_id,
       COUNT(salary) count
   FROM   employee_data
   GROUP  BY manager_id, emp_id
)
SELECT emp_id,
   f_name,
   l_name,
   salary
FROM employee_data;</code></pre>
<p class="c2 c10">要获取id为2的所有经理下属:</p>
<h4 id="h-heuu0c9g652c" class="c32">非递归项返回基本结果集R0，即id为2的雇员。</h4>
<p class="c2"><span class="c8">员工id |经理id |全名</span></p>
<p class="c2"><span class="c8"> - + - + - </span></p>
<pre class="language-sql"><code>WITH RECURSIVE cte_name AS(
   CTE_query_definition -- non-recursive term
   UNION [ALL]
   CTE_query definion  -- recursive term
) SELECT * FROM cte_name;</code></pre>
<p class="c2 c10">2 | 1 |梅根·贝瑞</p>
<pre class="language-sql"><code>CREATE TABLE employees (
        employee_id serial PRIMARY KEY,
        full_name VARCHAR NOT NULL,
        manager_id INT
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO employees (
        employee_id,
        full_name,
        manager_id
)
VALUES
        (1, 'Michael North', NULL),
        (2, 'Megan Berry', 1),
        (3, 'Sarah Berry', 1),
        (4, 'Zoe Black', 1),
        (5, 'Tim James', 1),
        (6, 'Bella Tucker', 2),
        (7, 'Ryan Metcalfe', 2),
        (8, 'Max Mills', 2),
        (9, 'Benjamin Glover', 2),
        (10, 'Carolyn Henderson', 3),
        (11, 'Nicola Kelly', 3),
        (12, 'Alexandra Climo', 3),
        (13, 'Dominic King', 3),
        (14, 'Leonard Gray', 4),
        (15, 'Eric Rampling', 4),
        (16, 'Piers Paige', 7),
        (17, 'Ryan Henderson', 7),
        (18, 'Frank Tucker', 8),
        (19, 'Nathan Ferguson', 8),
        (20, 'Kevin Rampling', 8);</code></pre>
<p class="c2 c10"><span class="c8">递归项的第一次迭代返回以下结果集:</span></p>
<pre class="language-sql"><code>WITH RECURSIVE subordinates AS (
        SELECT
                employee_id,
                manager_id,
                full_name
        FROM
                employees
        WHERE
                employee_id = 2
        UNION
                SELECT
                        e.employee_id,
                        e.manager_id,
                        e.full_name
                FROM
                        employees e
                INNER JOIN subordinates s ON s.employee_id = e.manager_id
) SELECT
        *
FROM
        subordinates;</code></pre>
<p class="c2 c10"><span class="c8">员工id |经理id |全名</span></p>
<p class="c2"><span class="c8"> - + - + - </span></p>
<p class="c2">6 | 2 |贝拉·塔克</p>
<p class="c2">瑞安·梅特卡夫</p>
<p class="c2"><span class="c8"> 8 | 2 |最大铣削量</span></p>
<p class="c2">本杰明·格洛弗</p>
<p class="c2"><span class="c8">递归成员的第二次迭代使用上述步骤的结果集作为输入值，并返回这个结果集。</span></p>
<p class="c2"><span class="c8">员工id |经理id |全名</span></p>
<p class="c2"><span class="c8"> - + - + - </span></p>
<p class="c2"><span class="c8"> 16 | 7 |皮尔斯·佩奇</span></p>
<p class="c2"><span class="c8"> 17 | 7 |瑞安·亨德森</span></p>
<p class="c2">弗兰克·塔克</p>
<p class="c2">19 | 8 |内森·弗格森</p>
<p class="c2">凯文·兰普林</p>
<p class="c2">第三次迭代返回一个空结果集，因为没有员工向id为16、17、18、19和20的员工报告。</p>
<p class="c2"><span class="c8">下面是最终结果集，它是由非递归项和递归项生成的第一次和第二次迭代中所有结果集的并集。</span></p>
<p class="c2"><img title="" src="../Images/3c461b76e1ccc427b39f8c41d5080f63.png" alt="" data-original-src="https://hackr.io/blog/media/recursive-query-min.png"/></p>
<p class="c2"><span class="c22">第9节-修改数据</span></p>
<p class="c2"><span class="c8">在本节中，您将学习如何:</span></p>
<p class="c2"><span class="c8">用insert语句将数据插入表格</span></p>
<p class="c2"><span class="c8">用更新语句</span>修改现有数据</p>
<h2 id="h-scmf6dgo1xtk" class="c42 c64"><span class="c8">用删除语句删除数据</span></h2>
<h3 id="h-rwv3geka3k9o" class="c53 c42"><span class="c8">用UPSERT语句合并数据</span></h3>
<p class="c2"><span class="c23">插入</span></p>
<ul class="c14 lst-kix_sdolr9l4z43l-0 start">
<li class="c2 c7 li-bullet-0">这个语句允许你在表格中插入一个新行。</li>
<li class="c2 c7 li-bullet-0"><span class="c8">语法:</span></li>
<li class="c2 c7 li-bullet-0">如果你想返回整个插入的行，你可以在RETURNING关键字后使用星号(*)。</li>
<li class="c2 c7 li-bullet-0">若要返回有关插入行的一些信息，可以在RETURNING子句后指定一列或多列。</li>
</ul>
<h4 id="h-e4xl97u8qcb8" class="c37"><strong> <span class="c11">插入包含单个字符的字符串</span> </strong></h4>
<p class="c6"><strong> <span class="c11">获取最后插入id </span> </strong></p>
<p class="c6"><span class="c23">插入多行</span></p>
<pre class="language-sql"><code>INSERT INTO table_name(column1, column2, ...)
VALUES (value1, value2, ...);</code></pre>

<p class="c6"><span class="c8">使用以下语法插入多行。</span></p>
<pre class="language-sql"><code>INSERT INTO table_name(column1, column2, ...)
VALUES (value1, value2, ...)
RETURNING *;</code></pre>
<p class="c6 c10">若要插入并返回多行，请使用returning子句:</p>
<pre class="language-sql"><code>INSERT INTO table_name(column1, column2, ...)
VALUES (value1, value2, ...)
RETURNING id;</code></pre>

<pre class="language-sql"><code>INSERT INTO links (url, name)
VALUES('https://www.xyz.com', 'data');</code></pre>
<ul>
<li>例如，我们将创建“链接”表并插入数据:</li>
</ul>
<pre class="language-sql"><code>INSERT INTO links (url, name)
VALUES('http://www.xyz.com','O''XYZ');</code></pre>

<pre class="language-sql"><code>INSERT INTO links (url, name, last_update)
VALUES('https://www.google.com','Google','2013-06-01');</code></pre>
<ul>
<li><strong> <span class="c11">使用下面的查询</span> </strong>插入多行</li>
</ul>
<pre class="language-sql"><code>INSERT INTO links (url, name)
VALUES('http://www.xyz.org','PostgreSQL')
RETURNING id;</code></pre>
<h4 id="h-2vw0b2hhljbh" class="c37"><img title="" src="../Images/69d1de235b34fe6c9d8989ea46887aec.png" alt="" data-original-src="https://hackr.io/blog/media/insert-multiple-rows-using-the-below-query-min.png"/></h4>
<p class="c6"><strong> <span class="c11">插入并返回多列</span> </strong></p>
<pre class="language-sql"><code>INSERT INTO table_name (column_list)
VALUES
   (value_list_1),
   (value_list_2),
   ...
   (value_list_n);</code></pre>
<p class="c6 c10"><img title="" src="../Images/1503983c3570c2c2131080c9e023167a.png" alt="" data-original-src="https://hackr.io/blog/media/insert-and-return-multiple-columns-min.png"/></p>
<pre class="language-sql"><code>INSERT INTO table_name (column_list)
VALUES
   (value_list_1),
   (value_list_2),
   ...
   (value_list_n)
RETURNING * | output_expression;</code></pre>
<p class="c6 c10"><span class="c23">更新</span></p>
<pre class="language-sql"><code>DROP TABLE IF EXISTS links;

CREATE TABLE links (
   id SERIAL PRIMARY KEY,
   url VARCHAR(255) NOT NULL,
   name VARCHAR(255) NOT NULL,
   description VARCHAR(255)
);</code></pre>
<ul>
<li>更新<span class="c8">允许你修改表格中的数据。</span></li>
</ul>
<pre class="language-sql"><code>INSERT INTO 
   links (url, name)
VALUES
   ('https://www.google.com','Google'),
   ('https://www.yahoo.com','Yahoo'),
   ('https://www.bing.com','Bing');</code></pre>
<pre class="language-sql"><code>SELECT * FROM links;</code></pre>
<p class="c2"><span class="c8">语法:</span></p>
<ul class="c14 lst-kix_ghy8xlsnxptq-0 start">
<li class="c6 c7 li-bullet-0">为了解释，我们将创建“课程”表并插入数据:</li>
</ul>
<pre class="language-sql"><code>INSERT INTO 
   links(url,name, description)
VALUES
   ('https://duckduckgo.com/','DuckDuckGo','Privacy &amp; Simplified Search Engine'),
   ('https://swisscows.com/','Swisscows','Privacy safe WEB-search')
RETURNING *;​</code></pre>
<pre class="language-sql"><code>SELECT * FROM links;</code></pre>
<p class="c2"><img title="" src="../Images/05881791862ee2b2cc4c2fcb68ce7160.png" alt="" data-original-src="https://hackr.io/blog/media/return-updated-rows-min.png"/></p>
<h4 id="h-rvak6qbotx31" class="c37"><img title="" src="../Images/477e9d5249937fe7e2b6b823abf7a5e7.png" alt="" data-original-src="https://hackr.io/blog/media/update-a-single-row-min.png"/></h4>
<p class="c6"><span class="c23">更新加入</span></p>
<p class="c6"><span class="c8">此语句用于根据一个表中的值更新另一个表中的数据。</span></p>
<pre class="language-sql"><code>UPDATE table_name
SET column1 = value1,
   column2 = value2,
   ...
WHERE condition;</code></pre>

<pre class="language-sql"><code>UPDATE table_name
SET column1 = value1,
   column2 = value2,
   ...
WHERE condition
RETURNING * | output_expression AS output_name;</code></pre>
<p class="c6 c10"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>DROP TABLE IF EXISTS courses;

CREATE TABLE courses(
        course_id serial primary key,
        course_name VARCHAR(255) NOT NULL,
        description VARCHAR(500),
        published_date date
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO 
        courses(course_name, description, published_date)
VALUES
        ('PostgreSQL for Developers','A complete PostgreSQL for Developers','2020-07-13'),
        ('PostgreSQL Admininstration','A PostgreSQL Guide for DBA',NULL),
        ('PostgreSQL High Performance',NULL,NULL),
        ('PostgreSQL Bootcamp','Learn PostgreSQL via Bootcamp','2013-07-11'),
        ('Mastering PostgreSQL','Mastering PostgreSQL in 21 Days','2012-06-30');</code></pre>
<pre class="language-sql"><code>SELECT * FROM courses:</code></pre>
<p class="c2">例如，我们创建了两个表，并向其中插入了数据。</p>

<pre class="language-sql"><code>UPDATE courses
SET published_date = '2020-08-01' 
WHERE course_id = 3;​</code></pre>
<pre class="language-sql"><code>SELECT * FROM COURSES WHERE COURSE_ID=3;</code></pre>
<p class="c2"><span class="c8">–表1 </span></p>
<h4 id="h-z8gfnvwfkhyj" class="c37">–表2</h4>
<p class="c2">现在，我们将运行更新连接查询:</p>
<p class="c2"><img title="" src="../Images/8d9cb0b482dc112a853178bcd013e0bc.png" alt="" data-original-src="https://hackr.io/blog/media/update-join-min.png"/></p>
<pre class="language-sql"><code>UPDATE t1
SET t1.c1 = new_value
FROM t2
WHERE t1.c2 = t2.c2;</code></pre>
<p class="c2"><span class="c23">删除</span></p>
<p class="c2">这个语句允许你从一个表中删除一行或多行。</p>
<pre class="language-sql"><code>CREATE TABLE prod (
   id SERIAL PRIMARY KEY,
   segment VARCHAR NOT NULL,
   discount NUMERIC (4, 2)
);</code></pre>
<pre class="language-sql"><code>INSERT INTO 
   Prod (segment, discount)
VALUES
   ('Grand Luxury', 0.05),
   ('Luxury', 0.06),
   ('Mass', 0.1);</code></pre>
<p class="c2 c10"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>DROP TABLE IF EXISTS product;
CREATE TABLE product(
   id SERIAL PRIMARY KEY,
   name VARCHAR NOT NULL,
   price NUMERIC(10,2),
   net_price NUMERIC(10,2),
   segment_id INT NOT NULL,
   FOREIGN KEY(segment_id) REFERENCES prod(id)
);</code></pre>
<pre class="language-sql"><code>INSERT INTO 
   product (name, price, segment_id)
VALUES 
   ('diam', 804.89, 1),
   ('vestibulum aliquet', 228.55, 3),
   ('lacinia erat', 366.45, 2),
   ('scelerisque quam turpis', 145.33, 3),
   ('justo lacinia', 551.77, 2),
   ('ultrices mattis odio', 261.58, 3),
   ('hendrerit', 519.62, 2),
   ('in hac habitasse', 843.31, 1)
  ;</code></pre>
<p class="c2 c10"><span class="c8">使用RETURNING子句将删除的行返回给客户端:</span></p>
<pre class="language-sql"><code>UPDATE product
SET net_price = price - price * discount
FROM prod
WHERE product.segment_id = prod.id;</code></pre>
<pre class="language-sql"><code>SELECT * FROM product;</code></pre>
<p class="c2"><strong> <span class="c11">删除并返回一行。</span>T3】</strong></p>
<h4 id="h-4uy0me2v6ee5" class="c32"><span class="c23">向上插入</span></h4>
<p class="c2">该语句将在现有行中插入或更新数据。其思想是，当您向表中插入一个新行时，PostgreSQL将更新已经存在的行；否则，它将插入新行。这就是为什么我们称这个行动为upsert。</p>
<p class="c2"><span class="c8">要使用PostgreSQL中的upsert功能，请使用INSERT ON CONFLICT语句。</span></p>
<pre class="language-sql"><code>DELETE FROM table_name
WHERE condition;</code></pre>
<p class="c2">例如，我们将创建“客户”表并将数据插入其中:</p>
<pre class="language-sql"><code>DELETE FROM table_name
WHERE condition
RETURNING (select_list | *)</code></pre>

<pre class="language-sql"><code>DELETE FROM links
WHERE id = 8;</code></pre>
<ul>
<li>现在我们可以使用以下查询来更改电子邮件:</li>
</ul>
<pre class="language-sql"><code>DELETE FROM links
WHERE id = 7
RETURNING *;</code></pre>

<pre class="language-sql"><code>DELETE FROM links
WHERE id IN (6,5)
RETURNING *;</code></pre>
<h4 class="c32" id="upsert"><img title="" src="../Images/92666cf418c42e2137eeafb3f6c56e2b.png" alt="" data-original-src="https://hackr.io/blog/media/upsert-min.png"/></h4>
<p class="c2"><span class="c22">第10节-交易</span></p>
<p class="c2">数据库事务是包含若干操作的单个工作单元。PostgreSQL事务是原子的、一致的、隔离的和持久的，表现为ACID属性。</p>
<pre class="language-sql"><code>INSERT INTO table_name(column_list)
VALUES(value_list)
ON CONFLICT target action;</code></pre>
<p class="c2 c10"><span class="c8">例如:</span></p>
<pre class="language-sql"><code>DROP TABLE IF EXISTS customers;</code></pre>
<pre class="language-sql"><code>CREATE TABLE customers (
        cust_id serial PRIMARY KEY,
        name VARCHAR UNIQUE,
        email VARCHAR NOT NULL,
        active bool NOT NULL DEFAULT TRUE
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO 
   customers (name, email)
VALUES 
   ('sam', 'sam@ibm.com'),
   ('Microsoft', 'contact@microsoft.com'),
   ('Harry', 'harry@intel.com');</code></pre>
<p class="c2 c10">在语句的开头使用BEGIN语句。</p>
<pre class="language-sql"><code>INSERT INTO customers (name, email)
VALUES('Microsoft','hotline@microsoft.com')
ON CONFLICT (name)
DO 
  UPDATE SET email = EXCLUDED.email || ';' || customers.email;</code></pre>
<p class="c2 c10">即使发生崩溃，这也会使你的更改永久生效。</p>
<h3 id="h-3tejoxa2f4zb" class="c57 c42"><span class="c8"> -开始交易。</span></h3>
<p class="c2"><span class="c8"> -在账户表中插入新的一行。</span></p>
<p class="c2">-提交更改(或稍后回滚)。</p>
<pre class="language-sql"><code>DROP TABLE IF EXISTS accounts;

CREATE TABLE accounts (
   id INT GENERATED BY DEFAULT AS IDENTITY,
   name VARCHAR(100) NOT NULL,
   balance DEC(15,2) NOT NULL,
   PRIMARY KEY(id)
);</code></pre>

<p class="c2">您可以回滚任何事务，直到最后一个提交语句。</p>
<pre class="language-sql"><code>BEGIN;

INSERT INTO accounts(name,balance)
VALUES('Alice',10000);</code></pre>

<p class="c2"><span class="c8"> -开始交易。</span></p>
<p class="c2"><span class="c8"> -从账户1中扣除金额。</span></p>
<pre class="language-sql"><code>BEGIN;</code></pre>
<p class="c2">-添加账户3的金额(而不是账户2)。</p>
<pre class="language-sql"><code>INSERT INTO accounts(name,balance)
VALUES('Alice',10000);</code></pre>
<p class="c2 c10">-回滚事务。</p>
<pre class="language-sql"><code>COMMIT;</code></pre>

<p class="c2"><span class="c22">第11节-将CSV文件导入PostgreSQL表</span></p>
<p class="c2"><span class="c8">我们现在将创建“persons”表，以了解如何将CSV文件导入PostgreSQL表。</span></p>
<pre class="language-sql"><code>BEGIN;</code></pre>
<p class="c2">使用以下格式创建CSV:</p>
<pre class="language-markup"><code>UPDATE accounts
SET balance = balance - 1500
WHERE id = 1;</code></pre>
<p class="c2 c10"><img title="" src="../Images/e4c764e2138bb0bf721632f5e3182b65.png" alt="" data-original-src="https://hackr.io/blog/media/section-11-import-csv-file-into-postgresql-table-min.png"/></p>
<pre class="language-sql"><code>UPDATE accounts
SET balance = balance + 1500
WHERE id = 3;</code></pre>
<p class="c2 c10"><strong> <span class="c11">用复制语句导入</span> </strong></p>
<pre class="language-sql"><code>ROLLBACK;</code></pre>
<h3 id="h-w11k2sahbeb3" class="c53 c42"><img title="" src="../Images/45907f923397c84da29dc20fb6509ee5.png" alt="" data-original-src="https://hackr.io/blog/media/importing-with-the-copy-statement-min.png"/></h3>
<p class="c2"><span class="c8">下面的查询将截断该表并重新开始:</span></p>
<pre class="language-sql"><code>CREATE TABLE persons (
 id SERIAL,
 f_name VARCHAR(50),
 l_name VARCHAR(50),
 dob DATE,
 email VARCHAR(255),
 PRIMARY KEY (id)
)</code></pre>
<p class="c2 c10"><img title="" src="../Images/7c93d11e8d546e825ed9c48d39e11af7.png" alt="Truncate table image" data-original-src="https://hackr.io/blog/media/using-pgadmin-min.png"/></p>
<p class="c2"> </p>
<ul class="c14 lst-kix_dsiwo7ow2aw9-0 start">
<li class="c2 c7 li-bullet-0"><img title="" src="../Images/ccbde3ab84d6456a5f0f646bc22a9a1b.png" alt="Import table file info boxes" data-original-src="https://hackr.io/blog/media/truncate-table-persons-min.png"/></li>
</ul>
<pre class="language-sql"><code>COPY persons(first_name, last_name, dob, email)
FROM 'C:\sampledb\persons.csv'
DELIMITER ','
CSV HEADER;​</code></pre>
<pre class="language-sql"><code>SELECT * FROM persons;</code></pre>
<p class="c2"><img title="" src="../Images/b79a429779d9734338493c2e61a28552.png" alt="Columns settings, including spaces for NULL strings and not null columns" data-original-src="https://hackr.io/blog/media/restart-min.png"/></p>

<p class="c2"><img title="" src="../Images/142540ba4fe1c1abb1ac47a5b045f03a.png" alt="Copy table data image" data-original-src="https://hackr.io/blog/media/identity-min.png"/></p>
<pre class="language-sql"><code>TRUNCATE TABLE persons
RESTART IDENTITY;</code></pre>
<p class="c2"> </p>
<p class="c2 c10"><span class="c22">第12节-在PostgreSQL中管理表</span></p>
<p class="c2"><span class="c23">数据类型</span></p>
<p class="c2"><span class="c26"> <strong>布尔</strong> : </span> <span class="c8">可以保存三个可能值之一:真、假或空。</span></p>
<p class="c2"><span class="c26"><strong>【CHAR(n)</strong>:</span><span class="c8">用空格填充的定长字符。</span></p>
<p class="c6 c10"><strong><span class="c26">ARCHAR(n</span></strong><span class="c8"><strong>)</strong>:可变长度字符串，最多可存储n个字符。</span></p>
<h3 id="h-6acaidmu194g" class="c57 c42"><strong> <span class="c26">文本</span> </strong> <span class="c8">:变长字符串。</span></h3>
<h4 id="h-8ub2dzrcj13t" class="c32"><span class="c26"><strong>【SMALLINT】</strong>:</span><span class="c8">2字节有符号整数，范围从-32768到32767。</span></h4>
<ul class="c14 lst-kix_9qqjh3wel1qs-0 start">
<li class="c2 c7 li-bullet-0"><span class="c26"><strong>【INT】</strong>:</span><span class="c8">4字节整数，取值范围为-2147483648到2147483647。</span></li>
<li class="c2 c7 li-bullet-0"><span class="c26"><strong>(n)</strong>:</span><span class="c8">浮点数，其精度至少为n，最多为8个字节。</span></li>
<li class="c2 c7 li-bullet-0"><span class="c26"><strong>realor float 8</strong>:</span><span class="c8">4字节浮点数。</span></li>
<li class="c2 c7 li-bullet-0"><span class="c26"> numeric或numeric(p，s) </span> <span class="c8">:小数点后有p位数字和s位数字的实数。数字(p，s)是精确的数字。</span></li>
<li class="c2 c7 li-bullet-0"><strong> <span class="c26">日期</span> </strong> <span class="c8">:只存储日期。</span></li>
<li class="c2 c7 li-bullet-0"><strong> <span class="c26">时间</span> </strong> <span class="c8">:存储一天中的时间值。</span></li>
<li class="c2 c7 li-bullet-0"><strong> <span class="c26">时间戳</span> </strong> <span class="c8">:存储日期和时间值。</span></li>
<li class="c2 c7 li-bullet-0"><strong> <span class="c26"> TIMESTAMPTZ </span> </strong> <span class="c8">:时区敏感时间戳数据类型。它是时间戳和时区的缩写。</span></li>
<li class="c2 c7 li-bullet-0"><strong><span class="c26"/></strong><span class="c8">:存储时间段。</span></li>
<li class="c2 c7 li-bullet-0"><span class="c23">创建表格</span></li>
<li class="c2 c7 li-bullet-0">使用<span class="c8">CREATE TABLE语句创建一个新表:</span></li>
<li class="c2 c7 li-bullet-0">语法:</li>
<li class="c2 c7 li-bullet-0"><span class="c23">选择进入</span></li>
<li class="c2 c7 li-bullet-0">该语句创建一个新表，并将查询返回的数据插入到该表中。新表将包含与查询结果集列同名的列。与常规SELECT语句不同，SELECT INTO语句不向客户端返回结果。</li>
</ul>
<h4 id="h-2qaexpsgxvf0" class="c32"><span class="c8">语法:</span></h4>
<p class="c2">例如:</p>
<p class="c2"><img title="" src="../Images/9516307a8078998c92557a8d5e2180c1.png" alt="" data-original-src="https://hackr.io/blog/media/film-id-min-2.png"/></p>
<pre class="language-sql"><code>CREATE TABLE [IF NOT EXISTS] table_name (
  column1 datatype(length) column_contraint,
  column2 datatype(length) column_contraint,
  column3 datatype(length) column_contraint,
  table_constraints
);</code></pre>
<h4 class="c32" id="select-into"><span class="c23">序列</span></h4>
<p class="c2">PostgreSQL中的序列是用户定义的模式绑定对象，它根据指定的规范生成整数序列。</p>
<p class="c2"><strong> <span class="c11">创建一个升序序列</span> </strong></p>
<pre class="language-sql"><code>SELECT
   select_list
INTO [ TEMPORARY | TEMP | UNLOGGED ] [ TABLE ] new_table_name
FROM
   table_name
WHERE
   search_condition;</code></pre>
<p class="c2 c10"><strong> <span class="c11">创建降序序列</span> </strong></p>
<pre class="language-sql"><code>SELECT
   film_id,
  film_ title,
   rental_rate
INTO TABLE film_r
FROM
   film
WHERE
  Rental_rate &gt; 200
ORDER BY
  film_ title;​</code></pre>
<pre class="language-sql"><code>SELECT * FROM film_r;</code></pre>
<p class="c2"><img title="" src="../Images/8bb03371cf2260f7fe324218524a5ebe.png" alt="" data-original-src="https://hackr.io/blog/media/sequence.png"/></p>
<h4 id="h-ca0qkkhem4jz" class="c32"><span class="c23">身份栏</span></h4>
<p class="c2"><span class="c8">它允许你自动给一个列分配一个唯一的编号。生成的AS IDENTITY约束是符合SQL标准的good old SERIAL列的变体。</span></p>
<pre class="language-sql"><code>CREATE SEQUENCE [ IF NOT EXISTS ] sequence_name
   [ AS { SMALLINT | INT | BIGINT } ]
   [ INCREMENT [ BY ] increment ]
   [ MINVALUE minvalue | NO MINVALUE ]
   [ MAXVALUE maxvalue | NO MAXVALUE ]
   [ START [ WITH ] start ]
   [ CACHE cache ]
   [ [ NO ] CYCLE ]
   [ OWNED BY { table_name.column_name | NONE } ]</code></pre>
<ul>
<li><strong> <span class="c11">生成总例</span> </strong></li>
</ul>
<pre class="language-sql"><code>CREATE SEQUENCE mysequence
INCREMENT 5
START 100;</code></pre>
<ul>
<li><strong> <span class="c11">默认生成为身份</span> </strong></li>
</ul>
<pre class="language-sql"><code>CREATE SEQUENCE three
INCREMENT -1
MINVALUE 1 
MAXVALUE 3
START 3
CYCLE;</code></pre>

<pre class="language-sql"><code>SELECT
   relname sequence_name
FROM 
   pg_class
WHERE 
   relkind = 'S';</code></pre>
<p class="c2 c10"><span class="c23">更改表格</span></p>

<pre class="language-sql"><code>DROP SEQUENCE [ IF EXISTS ] sequence_name [, ...]
[ CASCADE | RESTRICT ];</code></pre>

<pre class="language-sql"><code>DROP TABLE order_details;</code></pre>
<h4 id="h-otkkihcs28mc" class="c32"><span class="c8">要更改现有表的结构，请使用PostgreSQL ALTER TABLE语句。</span></h4>
<p class="c2"><strong> <span class="c11">改变</span>栏的默认值</strong></p>
<pre class="language-sql"><code>column_name type GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY[ ( sequence_option ) ]</code></pre>
<ul class="c14 lst-kix_28d9fz1pue1o-0 start">
<li class="c2 c7 li-bullet-0"><strong> <span class="c11">改变非空约束</span> </strong></li>
</ul>
<pre class="language-sql"><code>CREATE TABLE color (
   color_id INT GENERATED ALWAYS AS IDENTITY,
   color_name VARCHAR NOT NULL
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO color(color_name)
VALUES ('Red');</code></pre>
<ul>
<li><span class="c23">下降表</span></li>
</ul>
<pre class="language-sql"><code>DROP TABLE color;

CREATE TABLE color (
   color_id INT GENERATED BY DEFAULT AS IDENTITY,
   color_name VARCHAR NOT NULL
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO color (color_name)
VALUES ('White');</code></pre>
<h4 id="h-6y8xdod194p7" class="c32"><span class="c8">使用以下语法删除表:</span></h4>
<p class="c2"><span class="c26"> <strong>层叠</strong> </span> <span class="c8">选项允许您删除表格及其依赖对象。</span></p>
<pre class="language-sql"><code>ALTER TABLE table_name action;</code></pre>

<pre class="language-sql"><code>ALTER TABLE table_name
ADD COLUMN column_name datatype column_constraint;</code></pre>

<pre class="language-sql"><code>ALTER TABLE table_name
ADD COLUMN column_name datatype column_constraint;</code></pre>

<pre class="language-sql"><code>ALTER TABLE table_name
RENAME COLUMN column_name
TO new_column_name;</code></pre>
<ul class="c14 lst-kix_3ggnv1i6s6k6-0 start">
<li class="c2 c7 li-bullet-0"><strong> <span class="c26">限制</span> </strong> <span class="c8">选项拒绝移除任何对象，视表格而定。如果没有在DROP TABLE语句中显式指定，这是默认设置。</span></li>
</ul>
<pre class="language-sql"><code>ALTER TABLE table_name
ALTER COLUMN column_name
[SET DEFAULT value | DROP DEFAULT];</code></pre>
<ul class="c14 lst-kix_gfeb7u4s899r-0 start">
<li class="c2 c7 li-bullet-0"><span class="c8">您也可以删除多个用逗号分隔的表格:</span></li>
</ul>
<pre class="language-sql"><code>ALTER TABLE table_name
ALTER COLUMN column_name
[SET NOT NULL| DROP NOT NULL];</code></pre>

<pre class="language-sql"><code>ALTER TABLE table_name
ADD CHECK expression;</code></pre>

<pre class="language-sql"><code>ALTER TABLE table_name
RENAME TO new_table_name;</code></pre>
<h4 class="c32" id="drop-table"><strong> <span class="c11">删除不存在的表</span> </strong></h4>
<p class="c2"><strong> <span class="c11">删除带有依赖对象的表格</span> </strong></p>
<pre class="language-sql"><code>DROP TABLE [IF EXISTS] table_name
[CASCADE | RESTRICT];</code></pre>
<ul class="c14 lst-kix_8ydxkgbdav9e-0 start">
<li class="c2 c7 li-bullet-0"><strong> <span class="c26">错误</span> </strong> <span class="c8">:无法删除表格作者，因为其他对象依赖于它</span></li>
<li class="c2 c7 li-bullet-0"><strong> <span class="c26"> DETAIL </span> </strong> <span class="c8">:表格页面上的约束pages_author_id_fkey依赖于表格作者</span></li>
</ul>
<p class="c2"><strong> <span class="c26">提示</span> </strong> <span class="c8">:使用掉落...层叠以删除相关对象</span></p>
<pre class="language-sql"><code>DROP TABLE [IF EXISTS]
  table_name_1,
  table_name_2,
  ...
[CASCADE | RESTRICT];</code></pre>
<ul class="c14 lst-kix_pp05cj9v482u-0 start">
<li class="c2 c7 li-bullet-0"><strong> <span class="c26"> SQL状态</span> </strong> <span class="c8"> : 2BP01 </span></li>
</ul>
<pre class="language-sql"><code>DROP TABLE IF EXISTS author;</code></pre>
<ul class="c14 lst-kix_vc6gvfelq6ad-0 start">
<li class="c2 c7 li-bullet-0"><span class="c8">运行以下查询:</span></li>
</ul>
<pre class="language-sql"><code>CREATE TABLE authors (
       firstname VARCHAR (50),
          author_id INT PRIMARY KEY,
       lastname VARCHAR (50)
);​</code></pre>
<pre class="language-sql"><code>CREATE TABLE pages (
        page_id serial PRIMARY KEY,
        title VARCHAR (255) NOT NULL,
        contents TEXT,
        author_id INT NOT NULL,
        FOREIGN KEY (author_id)
         REFERENCES authors (author_id)
);
DROP TABLE IF EXISTS authors;</code></pre>
<p class="c2 c10"><span class="c23">截断表格</span></p>
<p class="c2">要从表中删除所有数据，使用DELETE语句。但是，您可以使用TRUNCATE TABLE语句来提高效率。</p>
<p class="c2"><strong> <span class="c11">截断多个表格</span> </strong></p>
<p class="c2"><strong> <span class="c11">截断带有外键引用的表</span> </strong></p>
<p class="c2"><span class="c23">临时表</span></p>
<pre class="language-sql"><code>DROP TABLE authors CASCADE;</code></pre>

<pre class="language-sql"><code>DROP TABLE tv shows, animes;</code></pre>
<h4 id="h-7cgwhnsxcl0h" class="c32">临时表是在数据库会话期间存在的短期表。PostgreSQL会在会话或事务结束时自动删除临时表。</h4>
<p class="c2"><span class="c22">第13节- PostgreSQL约束</span></p>
<pre class="language-sql"><code>TRUNCATE TABLE table_name;</code></pre>
<ul class="c14 lst-kix_7jowvtdg8m2z-0 start">
<li class="c2 c7 li-bullet-0"><span class="c8"> PostgreSQL包括以下列约束:</span></li>
</ul>
<pre class="language-sql"><code>TRUNCATE TABLE 
   table_name1,
   table_name2,
   ...;</code></pre>
<ul class="c14 lst-kix_4ua4dq4hu1qw-0 start">
<li class="c2 c7 li-bullet-0"><strong> <span class="c26">不为空</span></strong><span class="c26">:</span>E<span class="c8">n确保一列中的值不能为空。</span></li>
</ul>
<pre class="language-sql"><code>TRUNCATE TABLE table_name
CASCADE;</code></pre>
<h4 class="c32" id="temporary-table"><span class="c26"> <strong>唯一</strong>:</span>E<span class="c8">n一列中的保证值在同一表格的所有行中都是唯一的。</span></h4>
<p class="c2"><span class="c26"> <strong>主键</strong> : </span>标识一个表的主键。</p>
<pre class="language-sql"><code>CREATE TEMPORARY TABLE temp_table_name(
  column_list
);</code></pre>
<h3 class="c53 c42" id="section-13-postgresql-constraints"><span class="c26"> <strong>检查</strong> : </span> <span class="c8">确保数据满足布尔表达式。</span></h3>
<p class="c2"><span class="c26"> <strong>外键</strong> : </span> <span class="c8">确保一个表的一列或一组列中的值存在于另一个表的一列或一组列中。与主键不同，一个表可以有许多外键。</span></p>
<ul class="c14 lst-kix_o5eqhg4nns1r-0 start">
<li class="c2 c7 li-bullet-0"><span class="c22">第14节-条件表达式&amp;运算符</span></li>
</ul>
<pre class="language-sql"><code>CREATE TABLE table_name(
  ...
  column_name data_type NOT NULL,
  ...
);</code></pre>
<ul class="c14 lst-kix_ewenphdav8xa-0 start">
<li class="c2 c7 li-bullet-0"><span class="c23">案例</span></li>
</ul>
<pre class="language-sql"><code>CREATE TABLE person (
        id SERIAL PRIMARY KEY,
        first_name VARCHAR (50),
        last_name VARCHAR (50),
        email VARCHAR (50) UNIQUE
);</code></pre>
<ul class="c14 lst-kix_ewenphdav8xa-0">
<li class="c2 c7 li-bullet-0"><span class="c8"> CASE表达式与其他编程语言中的IF/ELSE语句相同。它允许您将if-else逻辑添加到查询中，以形成一个强大的查询。</span></li>
</ul>
<pre class="language-sql"><code>CREATE TABLE po_headers (
        po_no INTEGER PRIMARY KEY,
        vendor_no INTEGER,
        description TEXT,
        shipping_address TEXT
);</code></pre>
<ul class="c14 lst-kix_ewenphdav8xa-0">
<li class="c2 c7 li-bullet-0"><span class="c23">合并</span></li>
</ul>
<pre class="language-sql"><code>DROP TABLE IF EXISTS employees;
CREATE TABLE employees (
        id SERIAL PRIMARY KEY,
        first_name VARCHAR (50),
        last_name VARCHAR (50),
        birth_date DATE CHECK (birth_date &gt; '1900-01-01'),
        joined_date DATE CHECK (joined_date &gt; birth_date),
        salary numeric CHECK(salary &gt; 0)
);</code></pre>
<ul class="c14 lst-kix_ewenphdav8xa-0">
<li class="c2 c7 li-bullet-0">COALESCE函数接受无限数量的参数。它返回第一个不为空的参数。如果所有参数都为null，则COALESCE函数将返回null。</li>
</ul>
<pre class="language-sql"><code>[CONSTRAINT fk_name]
  FOREIGN KEY(fk_columns)
  REFERENCES parent_table(parent_key_columns)
  [ON DELETE delete_action]
  [ON UPDATE update_action]</code></pre>
<h3 class="c57 c42" id="section-14-conditional-expressions-operators"><span class="c8">该函数从左到右计算参数，直到找到第一个非空参数。不计算第一个非空参数的所有剩余参数。</span></h3>
<h4 id="h-4jzacw4iqoh2" class="c37"><span class="c8">语法:</span></h4>
<p class="c6"><span class="c8">例如:</span></p>
<pre class="language-sql"><code>CASE
     WHEN condition_1  THEN result_1
     WHEN condition_2  THEN result_2
     [WHEN ...]
     [ELSE else_result]
END</code></pre>
<h4 class="c37" id="coalesce"><img title="" src="../Images/70cdc93b13bd794d21dbfc61ae545086.png" alt="" data-original-src="https://hackr.io/blog/media/coalesce-min.png"/></h4>
<p class="c6"><span class="c23"> NULLIF </span></p>
<p class="c6">NULLIF函数是最常见的条件PostgreSQL表达式之一。</p>
<p class="c6"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>COALESCE (argument_1, argument_2, ...);</code></pre>
<p class="c6">例如:</p>
<pre class="language-sql"><code>CREATE TABLE items (
        ID serial PRIMARY KEY,
        product VARCHAR (100) NOT NULL,
        price NUMERIC NOT NULL,
        discount NUMERIC
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO items (product, price, discount)
VALUES
        ('A', 1000 ,10),
        ('B', 1500 ,20),
        ('C', 800 ,5),
        ('D', 500, NULL);

SELECT
        product,
        (price - COALESCE(discount,0)) AS net_price
FROM
        items;</code></pre>
<p class="c6 c10"><img title="" src="../Images/ede5513535868931a7c042eb5cdd8ace.png" alt="" data-original-src="https://hackr.io/blog/media/nullif-min.png"/></p>
<h4 id="h-kyav9lkhpcsf" class="c37"><span class="c23">剧组</span></h4>
<p class="c6">在很多情况下，你会想把一个值从一种数据类型转换成另一种数据类型。PostgreSQL为您提供了CAST操作符，允许您这样做。</p>
<p class="c6"><span class="c8">语法:</span></p>
<pre class="language-sql"><code>SELECT
        NULLIF (1, 1); -- return NULL

SELECT
        NULLIF (1, 0); -- return 1

SELECT
        NULLIF ('A', 'B'); -- return A</code></pre>
<p class="c6 c10"><strong> <span class="c11">将字符串转换为整数</span> </strong></p>
<pre class="language-sql"><code>CREATE TABLE posts (
 id serial primary key,
        title VARCHAR (255) NOT NULL,
        excerpt VARCHAR (150),
        body TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP
);​</code></pre>
<pre class="language-sql"><code>INSERT INTO posts (title, excerpt, body)
VALUES
     ('test post 1','test post excerpt 1','test post body 1'),
     ('test post 2','','test post body 2'),
     ('test post 3', null ,'test post body 3');​</code></pre>
<pre class="language-sql"><code>SELECT
        id,
        title,
        COALESCE (excerpt, LEFT(body, 40))
FROM
        posts;</code></pre>
<p class="c6 c10"><strong> <span class="c11">将字符串转换为布尔型</span> </strong></p>
<h4 id="h-7ota54qxlo9g" class="c37"><strong> <span class="c11">将字符串转换成时间戳</span> </strong></h4>
<p class="c6"><strong> <span class="c11">将字符串转换为音程</span> </strong></p>
<p class="c6"><span class="c22">第15节- Psql命令备忘单</span></p>
<pre class="language-sql"><code>CAST ( expression AS target_type );</code></pre>
<ul class="c14 lst-kix_t0yvlzetckkw-0 start">
<li class="c6 c7 li-bullet-0">下面是最常用的Psql命令:</li>
</ul>
<pre class="language-sql"><code>SELECT
        CAST ('100' AS INTEGER);</code></pre>

<pre class="language-sql"><code>SELECT
  CAST ('2015-01-01' AS DATE),
  CAST ('01-OCT-2015' AS DATE);</code></pre>

<pre class="language-sql"><code>SELECT
        CAST ('10.2' AS DOUBLE);</code></pre>
<ul class="c14 lst-kix_u3aq8f4gskw4-0 start">
<li class="c6 c7 li-bullet-0"><span class="c8"> psql -d数据库-U用户-W </span></li>
</ul>
<pre class="language-sql"><code>SELECT 
  CAST('true' AS BOOLEAN),
  CAST('false' as BOOLEAN),
  CAST('T' as BOOLEAN),
  CAST('F' as BOOLEAN);</code></pre>
<ul class="c14 lst-kix_jleqdc9bz12e-0 start">
<li class="c6 c7 li-bullet-0"><span class="c8"> \c数据库名用户名</span></li>
</ul>
<pre class="language-sql"><code>SELECT '2019-06-15 14:30:20'::timestamp;</code></pre>
<ul class="c14 lst-kix_il2zt23fj4t2-0 start">
<li class="c6 c7 li-bullet-0"><span class="c8"> \l </span></li>
</ul>
<pre class="language-sql"><code>SELECT '15 minute'::interval,
'2 hour'::interval,
'1 day'::interval,
'2 week'::interval,
'3 month'::interval;</code></pre>
<h3 class="c42 c57" id="section-15-psql-commands-cheat-sheet"><span class="c8"> \dt </span></h3>
<p class="c6"><span class="c8"> \d表名</span></p>

<p class="c6"><span class="c8"> \dn </span></p>

<p class="c6"><span class="c8"> \dv </span></p>

<p class="c6"><strong> <span class="c11">列出用户及其角色</span> </strong></p>

<p class="c6"><span class="c8">\杜</span></p>

<p class="c6"><strong> <span class="c11">执行之前的命令</span> </strong></p>

<p class="c6"><span class="c8">选择版本()；</span></p>

<p class="c6"><span class="c8"> \s </span></p>
<ul class="c14 lst-kix_5pcuu23776jl-0 start">
<li class="c6 c7 li-bullet-0"><span class="c8"> \i文件名</span></li>
</ul>
<p class="c6"><span class="c8"> \？</span></p>
<ul class="c14 lst-kix_x9p8o66catn-0 start">
<li class="c6 c7 li-bullet-0"><strong> <span class="c11">开启查询执行时间</span> </strong></li>
</ul>
<p class="c6"><span class="c8">DVD rental = # \计时</span></p>

<p class="c6"><span class="c8">计时开始。</span></p>

<p class="c6"><span class="c8">DVD rental = # select count(*)from film；</span></p>

<p class="c6"><span class="c8">计数</span></p>
<ul class="c14 lst-kix_w7nhv33rwo5x-0 start">
<li class="c6 c7 li-bullet-0"><span class="c8"> - </span></li>
</ul>
<p class="c6"><span class="c8"> 1000 </span></p>
<p class="c6"><span class="c8"> (1排)</span></p>
<p class="c6"><span class="c8">时间:1.495毫秒</span></p>
<p class="c6"><span class="c8"> dvdrental=# </span></p>
<p class="c6"><span class="c8"> \q </span></p>
<p class="c6"><span class="c54 c26">结论</span></p>
<p class="c6">在这个PostgreSQL备忘单中，我们已经涵盖了PostgreSQL的所有基本概念和一个快速PostgreSQL命令备忘单。无论你是初学者还是专业人士，你都可以在你的日常编程中找到这份备忘单的绝佳用途。</p>
<p class="c6">对其他编程小抄很好奇？<span class="c38"> <a class="c25" href="https://hackr.io/blog/java-cheat-sheet">探索我们的Java备忘单！</a>T3】</span></p>
<p class="c6"><span class="c26 c54">常见问题解答</span></p>

<p class="c6"><span class="c22"> 1。学习PostgreSQL最好的方法是什么？</span></p>
<h2 id="h-bu10hkoj7xpi" class="c46 c42"><span class="c8">有几个网上资源可以考虑:</span></h2>
<p class="c6"><span class="c8"> PostgreSQL for Developers-一个完整的PostgreSQL for Developers </span></p>
<p class="c6"><span class="c8"> PostgreSQL管理DBA的PostgreSQL指南</span></p>
<h2 id="h-vy0ntuk6fdqo" class="c42 c46"><span class="c8"> PostgreSQL高性能</span></h2>
<h4 id="h-gwsk9orppsry"><span class="c8"> PostgreSQL训练营-通过训练营学习PostgreSQL</span></h4>
<p class="c6"><span class="c8">掌握PostgreSQL </span></p>
<ul class="c14 lst-kix_12k03rpoya-0 start">
<li class="c6 c7 li-bullet-0"><span class="c22"> 2。Psql中的' #是什么意思？</span></li>
<li class="c6 c7 li-bullet-0"><span class="c8">提示符“postgres=#”是等待新命令开始的新提示符。“postgres-#”提示符是在键入不以分号结尾的命令后按enter键的结果。</span></li>
<li class="c6 c7 li-bullet-0"><span class="c22"> 3。如何查看PostgreSQL中的所有表？</span></li>
<li class="c6 c7 li-bullet-0"><span class="c23">使用SQL查询</span></li>
<li class="c6 c7 li-bullet-0"><span class="c8">运行以下查询:</span></li>
</ul>
<h4 id="h-w8lkq75r17p9"><span class="c8">或在特定模式中:</span></h4>
<p class="c6">使用Psql</p>
<h4 id="h-exgs5tqkk3zz"><span class="c8">列出所有表格:</span></h4>
<h4 id="h-abe7j9pkp7dr" class="c37"><span class="c8">在所有模式中:\dt *。* </span></h4>
<p class="c6"><span class="c8">在特定的模式中:\dt schema_name。* </span></p>
<pre class="language-sql"><code>SELECT * FROM information_schema.tables;</code></pre>
<p class="c6"><span class="c22"> 4。Postgres比MySQL快吗？</span></p>
<pre class="language-sql"><code>SELECT * FROM information_schema.tables WHERE table_schema = 'schema_name';</code></pre>
<p class="c6 c10">在决定使用哪个数据库时，速度很重要。PostgreSQL在处理海量数据集、复杂查询、读写操作时速度更快。另一方面，MySQL对于只读命令更快。</p>
<p class="c6"><span class="c22"> 5。PostgreSQL中的问号是什么？</span></p>
<p class="c6"><span class="c8">？在预处理语句中用作参数的占位符。因为原始的SQL查询实际上并没有准备好，所以我们可以切换执行它们的方式。</span></p>
<p class="c6"><span class="c22"> 6。我如何得到Postgres外壳？</span></p>
<h4 id="h-jaexf861ieg7" class="c42 c53">首先，s <span class="c8">选择运行PostgreSQL的服务器。默认情况下，选择localhost。如果它运行在不同的机器上，请在此处提供服务器名称。</span></h4>
<p class="c6"><span class="c8">接下来，选择一个数据库。在postgres安装过程中，会创建一个名为Postgres的数据库。</span></p>
<h4 id="h-k9ee5qauvy2e">默认情况下，PostgreSQL服务器运行在端口5432上，除非您在安装过程中更改它。如果您更改了端口号，请在此处提供相同的端口号。</h4>
<p class="c6"><span class="c8">提供用户名。我们将使用默认用户“postgres”</span></p>
<h4 id="h-omnp0v13rh5t"><span class="c8">输入用户密码，点击输入。</span></h4>
<p class="c6"><strong>人也在读:</strong></p>
<p class="c6"><span class="c8">Next, select a database. During the Postgres installation, a database is created with the name postgres.</span></p>
<p class="c6"><span class="c8">By default, the PostgreSQL server runs on port 5432, unless you change it during installation. If you changed the port number, provide the same here.</span></p>
<p class="c6"><span class="c8">Provide the username. We will go with the default user “postgres.”</span></p>
<p class="c6"><span class="c8">Type in the password for the user and click enter.</span></p>
<p><strong>People are also Reading:</strong></p>


									</div>

									</div>    
</body>
</html>