# 下载 Regex 备忘单 PDF 以供快速参考[更新]

> 原文：<https://hackr.io/blog/regex-cheat-sheet>

Regex 代表正则表达式。它是每种编程语言不可或缺的一部分。如果不使用正则表达式，就无法执行复杂的查询。正则表达式，有时也称为有理表达式，是定义文本中搜索模式的字符序列。

许多字符串搜索算法使用正则表达式对字符串进行“查找”和“查找并替换”操作。许多编程语言都有内置的正则表达式功能，而其他语言则通过插件提供。

正则表达式(regex)主要用于 Google Analytics 的 URL 匹配。正则表达式的一些其他流行的用例是词法分析、字处理器和文本编辑器的搜索和替换对话框，以及文本处理实用程序。

由于它的极端重要性，许多人渴望[学习正则表达式语法](https://hackr.io/tutorials/learn-regular-expressions-regex)和表达式，以便在面试中出现。作为快速参考，您可以简单地考虑这个[正则表达式备忘单 PDF](https://drive.google.com/file/d/1mYNyLO2J6GUnemtFYbG0eNs5ireo8jq_/view?usp=sharing) 。

在本正则表达式指南中，您将通过适当的示例了解各种正则表达式符号和正则表达式的工作原理。让我们从 Java regex 备忘单开始。

## **正则表达式备忘单**

### **1。字符转义**

下表中的反斜杠字符(\)表示它后面的字符是特殊字符。

| **转义字符** | **描述** | **图案** | **匹配** |
| \a | 匹配一个钟形字符\u0007。 | \a | “错误！”中的“u0004”+ '\u0004 ' |
| \b | 将匹配字符类中的退格键，\u0008。 | [\b]{3，} | “\b\b\b\b”中的“\b\b\b\b” |
| \t | 它将与选项卡 u0009 匹配。 | (\w+)\t | " i1\t "，" i1\ti\t "中的" i2\t " |
| \r | 它将匹配回车符\u000D。(\r 不等同于换行符，\n .) | \r\n(\w+) | \ r \ n 这些“in”有两行。 |
| \v | 它将匹配一个垂直制表符\u000B。 | [\v]{2，} | “\v\v\v”中的“v\v\v” |
| \f | 它将匹配一个换页符\u000C。 | [\f]{2，} | “\f\f\f”中的“f\f\f” |
| \n | 它将匹配一个新系列\ u000A。 | \r\n(\w+) | \ r \ n 这些“in”有两行。 |
| \e | 它将匹配一个转义符\u001B。 | \e | “\x001B”中的“x001B” |
| \ nnn | 它使用八进制表示来指定一个字符(nnn 由两个或三个数字组成)。 | \w\040\w | “公元前一世纪”中的“公元前一世纪” |
| \x nn | 它使用十六进制表示来指定一个字符(nn 正好由两位数字组成)。 | \w\x20\w | “公元前一世纪”中的“公元前一世纪” |
| \c X \c x | 它将匹配由 X 或 X 指定的 ASCII 控制字符，其中 X 或 X 是控制字符的字母。 | \抄送 | “\x0003”中的“\ x 0003”(Ctrl-C) |
| \u nnnn | 它将匹配一个使用十六进制表示的 Unicode 字符(正好是四位数字，用 nnnn 表示)。 | \w\u0020\w | “公元前一世纪”中的“公元前一世纪” |

### **2。字符分类**

一个字符类将匹配一组字符中的任何一个。字符类包括下表中列出的语言元素。

| **人物类** | **描述** | **图案** | **匹配** |
| [字符组] | 它将匹配 character_group 中的任何单个字符。默认情况下，匹配区分大小写。 | [ae] | “湾”中的“a”“a”“桩子”中的“e” |
| [^人物 _ 组] | 否定:它将匹配 character_group 中不存在的任何单个字符。默认情况下，character_group 中的字符区分大小写。 | [^aei] | “统治”中的“r”、“g”、“n” |
| [名字-姓氏] | 字符范围:它将匹配从第一个到最后一个范围内的任何单个字符。 | [A-Z] | “AB123”中的“A”、“B” |
| 。 | 通配符:它将匹配除\n .以外的任何单个字符。或\u002E)，您必须在它前面加上转义符(\。). | 阿拉伯语 | “ave”中的“have”在“hater”中的“eat” |
| \p{ name } | 它将匹配由 name 指定的 Unicode 常规类别或命名块中的任何单个字符。 | \p{Lu} \p{IsCyrillic} | 《城市之光》中的“c”，“l”，“д”，“джem”中的“ж” |
| \P{ name } | 它将匹配 Unicode 常规类别或 name 指定的命名块中不存在的任何单个字符。 | \P{Lu} \P{IsCyrillic} | “城市”中的“我”，“t”，“y”，“джem”中的“e”，“m” |
| \w | 它将匹配任何单词字符。 | \w | “ID A1.3”中的“我”、“D”、“A”、“1”、“3” |
| \W | 它将匹配任何非单词字符。 | \W | " ", "."在“ID A1.3”中 |
| \s | 它将匹配任何空白字符。 | \w\s | “ID A1.3”中的“D” |
| \S | 它将匹配任何非空白字符。 | \s\S | “int __ctr”中的“_” |
| \d | 它将匹配任何十进制数字。 | \d | “4 = IV”中的“4” |
| \D | 它将匹配除十进制数字以外的任何字符。 | \D | " "，" = "，" "，" 4 = IV "中的"我"，" V " |

### **3。字符类操作**

| 类操作 | 神话；传奇 | 例子 | 样本匹配 |
| […-[…]] | 。NET:是字符类减法。左侧一个字符，但不在减法类中。 | 【阿-z-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿 | 任何小写辅音 |
| […-[…]] | 。NET:是字符类减法。 | [\p{IsArabic}-[\D]] | 阿拉伯字符而不是非数字，即阿拉伯数字 |
| […&&[…]] | Java，Ruby 2+:是字符类交集。&类中左侧的一个字符。 | [\S&&[\D]] | 一个非空白字符和一个非数字。 |
| […&&[…]] | Java，Ruby 2+:字符类交集。 | [\ s &[\ d]&[^ a-za-z]] | 一个非数字而非字母的非空白字符。 |
| […&&[^…]] | Java，Ruby 2+:它是一个字符类减法是通过将一个类与一个被求反的类相交得到的 | [a-z【^ aeiou】 | 不是元音的英文小写字母。 |
| […&&[^…]] | Java，Ruby 2+:是字符类减法 | [\p{InArabic}&&[^\p{L}\p{N}]] | 阿拉伯字符，而不是字母或数字 |

### **4。锚**

锚也被称为[原子零宽度断言](https://subscription.packtpub.com/book/application-development/9781787288706/6/ch06lvl1sec24/zero-width-assertions#:~:text=Zero%2Dwidth%20or%20zero%2Dlength,pointer%20in%20the%20input%20string.)。它根据字符串中的当前位置决定匹配是成功还是失败。但是这些锚不能用于允许引擎通过字符串或字符前进。下表中列出的元字符是定位点。

| **断言** | **描述** | **图案** | **匹配** |
| ^ | 默认情况下，匹配从字符串的开头开始。此外，对于多线模式，它也将从线的开始处开始。 | ^\d{3} | “111-333”中的“111” |
| $ | 默认情况下，匹配将发生在字符串的末尾或字符串末尾之前。在多行模式的情况下，它将发生在行尾之前或\n 在行尾之前。 | -\d{3}$ | "-901-444 "中的"-444 " |
| \A | 匹配出现在字符串的开头。 | \A\d{3} | “222”中的“222-333——” |
| \Z | 匹配出现在字符串末尾或字符串末尾之前。 | -\d{3}\Z | "-555-111 "中的"-111 " |
| \z | 匹配出现在字符串的末尾。 | -\d{3}\z | "-901-111 "中的"-111 " |
| \G | 匹配发生在前一个匹配结束的点上。 | \G\(\d\) | “(1)”中的“(3)”，“5”中的“(1)(3)(5)(7)(9)” |
| \b | 匹配出现在\w(字母数字)和\W(非字母数字)字符的边界上。 | \b\w+\s\w+\b | “他们主题”，“他们他们”在“他们主题他们他们” |
| \B | 匹配不会出现在\b 边界上。 | \弯曲\w*\b | “ends”，“ender”在“end sends 忍让者”中 |

[面向初学者的完整正则表达式(Regex)课程](https://click.linksynergy.com/deeplink?id=jU79Zysihs4&mid=39197&murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fregular-expressions-mastery%2F)

### **5。分组结构**

分组构造描述正则表达式的子表达式，并捕获所提供字符串的子字符串。分组构造使用以下语言元素。

| **分组构造** | **描述** | **图案** | **匹配** |
| (子表达式) | 它将捕获匹配的子表达式，并给它分配一个从 1 开始的序号。 | (\w)\1 | “hello”中的“ll” |
| (?< name >子表达式)或(？名称'子表达式) | 它会将匹配的子表达式捕获到一个命名组中。 | (? <double>\w)\k</double> | “你好”中的“ll” |
| (?< name1 - name2 >子表达式)或(？“名称 1 -名称 2”子表达式) | 它将定义一个平衡组定义。 | (((?'Open'\()[^\(\)]*)+((？'Close-Open'\))[^\(\)]*)+)*(？(打开)(？！))$ | “3+2^((1-3)*(3-1”中的“((1-3)*(3-1))” |
| (?:子表达式) | 它将定义一个非捕获组。 | 写(？:行)？ | “控制台”中的“WriteLine”。WriteLine()“控制台”中的“写入”。写(值)” |
| (？imsx-imsx:子表达式) | 它将应用或禁用子表达式中的指定选项。 | A\d{2}(？i:\w+)\b | “A12XL”、“A12xl”中的“A12xl” |
| (?=子表达式) | 零宽度正向前瞻断言。 | \b\w+\b(？=.+和。+) | “老鼠”、“蝙蝠”中的“老鼠、蝙蝠和一些老鼠” |
| (?！子表达式) | 零宽度负前瞻断言。 | \b\w+\b(？！。+和。+) | “老鼠、蝙蝠和一些老鼠”中的“和”、“一些”、“老鼠” |
| (?< =子表达式) | 零宽度正后视断言。 | \b\w+\b(？<=.+和。+)——————————\ b \ w+\ b(？<=.+和。*) | “一些”，“老鼠”，“老鼠，蝙蝠和一些老鼠。”————————————“老鼠、蝙蝠和一些老鼠”中的“和”、“一些”、“老鼠” |
| (? | 零宽度负后视断言。 | \b\w+\b(？ | “老鼠”、“蝙蝠”和“老鼠、蝙蝠和一些老鼠”中的“老鼠”————————————“老鼠、蝙蝠和一些老鼠”中的“老鼠”、“蝙蝠” |
| (?>子表达式) | 原子团。 | (?> a&#124;ab)c | “ac”中的“ac”在“abc”中没有 |

### **6。环顾四周**

当 regex 引擎开始处理 lookaround 表达式时，它从当前位置到原始字符串的开始(lookbehind)或结束(lookahead)位置获取一个子字符串，然后运行 Regex。在 lookaround 模式帮助下，匹配选定的子字符串。您可以根据肯定或否定的断言来确定结果是否成功。

| **环顾四周** | **名称** | **例子** | **样本匹配** |
| (?=检查) | 积极前瞻 | (?=\d{10})\d{5} | 06678 在 0667856789 |
| (?< =检查) | 积极回顾 | (?< =\d)rat | 一垒打 |
| (?！检查) | 消极前瞻 | (?！剧院)的\w+ | 主题 |
| (? | 消极回顾 | \w{3}(？ | 蒙斯特 |

### 7 .**。量化器**

量词将简单地指定输入字符串中必须有多少个前一个元素的实例才能产生完全匹配。量词包括以下语言元素。

| **量词** | **描述** | **图案** | **匹配** |
| * | 它将零次或多次匹配前一个元素。 | \d*\。\d | ".0", "19.9", "219.9" |
| + | 它将一次或多次匹配前一个元素。 | " se+" | “见过”中的“见”，“送过”中的“se” |
| ? | 它将零次或一次匹配前一个元素。 | “阿婆？n " | “人”，“主” |
| { n } | 它将与前一个元素精确匹配 n 次。 | ，\d{3} | “1043.6”中的“、043”，“9876543210”中的“、876”、“543”、“210” |
| { n，} | 它将匹配前一个元素至少 n 次。 | \d{2，}。 | "166", "29", "1930" |
| { n，m } | 它将匹配前一个元素至少 n 次，但不超过 m 次。 | \d{3，5} | “166”、“17668”、“19302”中的“193024” |
| *? | 它将匹配前一个元素零次或多次，但次数越少越好。 | \d*？\.\d | ".0", "19.9", "219.9" |
| +? | 它将匹配前一个元素一次或多次，但次数越少越好。 | “se+？” | “见过”中的“se”，“送过”中的“se” |
| ?? | 它将匹配前一个元素零次或一次，但次数越少越好。 | “阿婆？？n " | “人”，“主” |
| { n }？ | 它将与前面的元素精确匹配 n 次。 | "，\d{3}？ | “1043.6”中的“、043”，“9876543210”中的“、876”、“543”、“210” |
| { n，}？ | 它将匹配前一个元素至少 n 次，但次数越少越好。 | \d{2，}？ | "166", "29", "1930" |
| { n，m }？ | 它将匹配前一个元素 n 到 m 次，但次数越少越好。 | \d{3，5}？ | “166”、“17668”、“193”、“024”中的“193024” |

### **8。反向引用结构**

通过反向引用，您可以简单地在同一个[正则表达式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)中识别后续的子表达式。下表突出显示了反向引用构造:

| **反向引用结构** | **描述** | **图案** | **匹配** |
| \数字 | 反向引用。它将匹配编号子表达式的值。 | (\w)\1 | “peek”中的“ee” |
| \k < name > | 命名反向引用。它将匹配命名表达式的值。 | (? <char>\w)\k<char></char></char> | “peek”中的“ee” |

### **9。变更构造**

交替构造将改变正则表达式，以实现“非此即彼”的匹配。这些构造带有下表中列出的语言元素。

| **交替构造** | **描述** | **图案** | **匹配** |
| &#124; | 它将匹配由竖线(&#124;)字符分隔的任何一个元素。 | th(e&#124;is&#124;at) | “就是这一天”中的“这个” |
| (?(表情)是&#124;不是)还是(？(表情)是) | 如果表达式指定的正则表达式模式匹配，它将匹配“是”；否则，它将匹配可选的“否”部分。提供的表达式被解释为零宽度断言。为了避免命名或编号捕获组的模糊性，必须使用可选的显式断言，例如(？( (?=表达式) )是&#124;否) | (?A\d{2}\b&#124;\b\d{3}\b) | “A10”、“A10 C103 910”中的“910” |
| (?(姓名)是&#124;否)还是(？(姓名)是) | 如果 name(一个已命名或编号的捕获组)有匹配项，它将匹配“yes ”;否则，它将匹配可选的否 | (?<quoted>)？(?(引用)。+?"&#124;\S+\s)</quoted> | " Dogs.jpg "，" Dogs.jpg \"Yiska playing.jpg\ " "中的\ " \ " Yiska playing . jpg \ " " |

### 10。替换

替换是在替换模式中使用的正则表达式语言元素。下表列出了作为原子零宽度断言的元字符。

| **字符** | **描述** | **图案** | **替换模式** | **输入字符串** | **结果字符串** |
| $ number | 它将替换由组号匹配的子串。 | \b(\w+)(\s)(\w+)\b | $3$2$1 | “一二” | “二一” |
| ${ name } | 它将替换与命名组名匹配的子字符串。 | \b(？ <word1>\w+)(\s)(？ <word2>\w+)\b</word2></word1> | ${word2} ${word1} | “一二” | “二一” |
| $$ | 它将替换文字“$”。 | \b(\d+)\s？美元 | $$$1 | " 44 美元" | "$44" |
| $& | 它将替代整个比赛的副本。 | \$?\d*\。？\d+ | **$&** | "$1.30" | "**$1.30**" |
| $` | 它将在匹配之前替换输入字符串的所有文本。 | B+ | $` | "DDBBCC" | "DDDDCC" |
| $' | 它将在匹配后替换输入字符串的所有文本。 | B+ | $' | " AADDCC " | " AACCCC " |
| $+ | 它将替换最后捕获的组。 | B+(C+) | $+ | " AABBCCDD " | "亚加共体" |
| $ u | 它将替换整个输入字符串。 | B+ | $ u | " AABBCC " | "啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊" |

### **11。内嵌选项**

以下是支持的内联选项。Net 正则表达式引擎:

| **选项** | **描述** | **图案** | **匹配** |
| 我 | 它用于不区分大小写的匹配。 | \b(？我)一(？-i)a\w+\b | 《食蚁兽》《食蚁兽 AAAuto aaaAuto 亚当早餐》中的“aaaaauto” |
| m | 在多线模式的情况下。^和$匹配一行的开始和结束，而不是一个字符串的开始和结束。 |
| n | 它不会捕获未命名的组。 |
| s | 它将使用单行模式。 |
| x | 它将忽略正则表达式模式中未转义的空白。 | \b(？x) \d+ \s \w+ | “1 只土豚”、“2 只猫”中的“1 只土豚 2 只猫 IV 百夫长” |

### **12。POSIX 字符类**

字符类将一个小的字符序列与一个大的字符集相匹配。我们只能在括号表达式中使用 POSIX 字符类。POSIX 标准支持以下字符类别来创建正则表达式。

| **字符** | **图例** | **例子** | **样本匹配** |
| [:alpha:] | PCRE (C，PHP，R…): ASCII 字母 a-z 和 A-Z | [8[:alpha:]]+ | 熟女 88 |
| [:alpha:] | Ruby 2: Unicode 字母或表意文字 | [:阿尔法:]\d]+ | 猫 99 |
| [:阿卢姆:] | PCRE (C，PHP，R…): ASCII 数字和字母 a-z 和 A-Z | [[:alnum:]]{10} | ABC1235251 |
| [:alnum:] | Ruby 2: Unicode 数字、字母或表意文字 | [:阿勒纳姆:]{10} | 猫 90210 |
| [:punct:] | PCRE (C，PHP，R…): ASCII 标点符号 | [[:punct:]]+ | ?!.,:; |
| [:punct:] | 拼音:Unicode 标点符号 | [[:punct:]]+ | ‽,:〽⁆ |

### 13。内嵌修饰符

在 [JavaScript](https://hackr.io/blog/what-is-javascript) 中不支持以下修饰符。如果您使用的是 Ruby，请确保小心使用“？s“和”？m”。

| 修改 | **图例** | **例子** | **样本匹配** |
| (?我) | 不区分大小写模式(JavaScript 除外) | (?一)星期一 | 星期一 |
| (?s) | DOTALL 模式(JS 和 Ruby 除外)。圆点(。)将匹配新行字符(\r\n)。您也可以称之为“单行模式”，因为点将整个输入视为一行 | (?s)从 A. *到 Z | 彻底地 |
| (?m) | 多行模式(除了 Ruby 和 JS) ^和$匹配在每一行的开头和结尾 | (?m)1\r\n^2$\r\n^3$ | 1 2 3 |
| (?m) | 在 Ruby 中:它与(？s)在其他引擎中，即 DOTALL 模式，即点匹配换行符 | (?m)从 A. *到 Z | 彻底地 |
| (?x) | 自由间距模式(JavaScript 除外)。你也可以称之为注释模式或空白模式 | (?x) #这是一个#注释 abc #写在多个#行[ ]d #空格必须用#括起来 | abc d |
| (?n) | 。NET，PCRE 10.30+:仅命名捕获 | 将所有(括号)变为非捕获组。若要捕获，请使用命名组。 |
| (?d) | [Java](https://hackr.io/blog/what-is-java) :仅 Unix 换行符 | 圆点、^和$锚点仅受\n |
| (?^) | PCRE 10.32+:未设置修改量 | 取消设置 ismnx 修改器 |

## **结论**

作为一个初学者，这个正则表达式备忘单可能很难理解。由于各种各样的字符和符号，可能很难在正确的地方记住所有这些表达。掌握正则表达式需要大量的练习。

好吧，如果你被困在某个地方，你可以简单地参考这个正则表达式备忘单。我们已经讨论了几乎所有使用正则表达式的表达式、字符和符号。我们希望这个备忘单能帮助你理解关于 regex 的一切。

## **常见问题解答**

#### **1。什么是正则表达式命令？**

Regex 命令根据给定的正则表达式过滤数据。

```
regex <field> [=|!= <regular expression>] | [IN | NOT IN (<regular expression> [(,<regular expression>)*])]
```

#### **2。在 regex 中*$是什么意思？**

正则表达式没有类似“*$”的内容。这是一个无效字符。“*”是一个正则表达式运算符，表示它前面的字符或子表达式出现了零次或多次。当“$”匹配被匹配字符串的末尾时，假设正则表达式中它前面的内容可以匹配字符串中前面的字符。

**例如:**

```
a*
```

它将匹配字符 a 出现零次或多次的任何序列。

```
a*$
```

它将在匹配的字符串末尾匹配零个或多个出现的。

#### **3。所有语言的 regex 都一样吗？**

所有编程语言的正则表达式语法可能略有不同，但大多数细节是相同的。一些 regex 实现在处理和某些特殊字符序列的含义上略有不同。

#### **4。正则表达式中的问号是什么？**

一个问号(？)regex 指定前面的元素出现零次或一次。

**比如:**
abc？d 表示匹配 ab 后跟 c(可选)带强制 d.
ab(cde)？f 表示匹配 ab 后跟 cde(可选),带有强制 f。

**人也在读:**