<html>
<head>
<title>Docker Cheat Sheet (Docker Commands + Free PDF)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Docker备忘单(Docker命令+免费PDF)</h1>
<blockquote>原文：<a href="https://hackr.io/blog/docker-cheat-sheet-docker-commands#0001-01-01">https://hackr.io/blog/docker-cheat-sheet-docker-commands#0001-01-01</a></blockquote><div><div class="content">
										<p>Docker是一个开源的容器化平台，用于在服务器和云上构建、运行和管理容器。它是创建和管理容器化应用程序的事实标准。Docker作为编排容器的行业标准于2013年推出。</p>
<p>容器是一个软件单元，它结合了应用程序的源代码和操作系统库(T2)以及依赖关系，因此应用程序可以在任何环境下工作。</p>
<p>今天，大多数公司使用Docker来管理和交付具有复杂需求的分布式应用程序。所以，对码头工人专家的需求也在以惊人的速度增长。</p>
<p>所以，如果你想涉足这个领域，你必须准备好应对面试的所有技术材料。我们创建了这个Docker命令备忘单，让您的生活更轻松。你可以参考这个Docker备忘单来复习你的知识。</p>

<h2 id="why-docker"><strong>为什么是Docker？</strong></h2>
<p>以前，开发人员创建具有多种依赖关系的复杂应用程序，并根据底层基础设施管理它们的运行时，是一件非常具有挑战性的事情。但是有了 <span> Docker </span> <span>，开发人员可以简单地将复杂的应用程序分解成更小的部分，将它们与运行该容器所需的所有依赖文件一起放入容器中，而与底层基础设施无关。</span></p>
<p><span>开发者可以在任何安装了Docker运行时的OS兼容主机(Linux或Windows)上快速运行Docker容器。</span></p>
<p><span>以下是</span> <span>码头工人</span> <span>的一些显著特征:</span></p>
<ul>
<li aria-level="1">Docker支持微服务架构。</li>
<li aria-level="1">便利的封装、隔离、可移植性和控制。</li>
<li aria-level="1">Docker容器很小(兆字节)。它们带有版本控制和组件重用的内置机制。</li>
<li aria-level="1">Docker允许你有效地利用所有容器中的资源。</li>
<li aria-level="1">它允许开发人员快速行动，提高开发和部署速度，以交付高端软件。</li>
<li aria-level="1">使用Docker，您可以轻松地使您的应用程序可移植，并可以在不同的基础设施上共享它来运行容器。</li>
</ul>
<p><span>信不信由你，通过消除对底层基础架构的依赖，多家公司已经从中受益，加快了SDLC流程并提高了性能。</span></p>
<h2 id="prerequisites-for-docker"><strong>Docker的先决条件</strong></h2>
<p><span>以下是不同操作系统安装docker的一些主要前提:</span></p>

<p><span>3.10 . x内核是Docker的最低要求。</span></p>


<p>需要10.8“山狮”或更新版本。</p>

<p>必须在BIOS中启用Hyper-V。</p>
<p>如果可用，还必须启用VT-D(英特尔处理器)。</p>

<p><span>您应该将Windows Server 2016作为安装docker和docker-compose的最低版本。这个版本有一些限制，比如多个虚拟网络和Linux容器。建议使用Windows Server 2019及更高版本，以获得更好的兼容性。</span></p>
<h2 id="installing-docker"><strong>安装对接器</strong></h2>
<p>要在您的系统上安装docker，您可以从系统的命令行终端执行简单的命令，如下所示。如果下面没有提到您的具体操作系统步骤，您可以在线了解。</p>

<p>运行下面的命令是在Linux操作系统上快速安装Docker的最简单的方法。</p>
<pre class="language-bash"><code>curl -sSL https://get.docker.com/ | sh</code></pre>

<p><span>下载并安装Docker社区版。对于家酿木桶，只需将酿造桶安装在码头上。或者你可以下载并安装Docker工具箱。苹果电脑</span></p>
<p><span>安装Docker Community Edition后，点击Launchpad中的Docker图标启动一个容器。</span></p>
<pre class="language-bash"><code>docker run hello-world</code></pre>

<p><span>可以安装<a href="https://docs.docker.com/desktop/windows/install/"> Docker for Windows 10 </a>。<span>安装完成后，双击Docker安装程序运行。完成安装过程后，转到指示Docker正在运行的通知中的鲸鱼图标，您可以通过终端访问它。</span> Windows 10 </span></p>
<p>您可以从终端运行以下命令来检查安装的Docker版本。</p>
<pre class="language-bash"><code>docker version</code></pre>

<p><span>借助OneGet提供商PowerShell模块，您可以轻松地在Windows Server上安装Docker EE。首先，您需要从PowerShell Gallery安装Docker-Microsoft package management提供程序模块。</span></p>
<pre class="language-bash"><code>Install-Module -Name DockerMsftProvider -Repository PSGallery -Force</code></pre>
<p><span>要查看已安装的软件包提供程序和Docker软件包，请键入以下命令:</span></p>
<pre class="language-bash"><code>Get-PackageProvider -ListAvailableget-packagesource -ProviderName DockerMsftProvider</code></pre>
<p><span>要安装最新版本的Docker，请使用以下命令</span></p>
<pre class="language-bash"><code>Install-Package -Name docker -ProviderName DockerMsftProvider</code></pre>
<p><span>要检查已安装的Docker版本，请运行以下命令:</span></p>
<p> </p>

<h2 id="architecture-of-docker"><strong>Docker的架构</strong></h2>
<p><span> DevOps架构有五大工作实体，分别是注册表、镜像、容器、守护进程、客户端。</span></p>
<ul>
<li aria-level="1"><strong>注册中心</strong> <span>:它托管Docker图像，包括公共图像和官方图像。Docker Hub是每个人都使用的默认Docker注册表。</span></li>
<li aria-level="1"><strong> Image </strong> <span>:你可以在启动一个容器的时候直接或者隐式的从注册表中下载Docker镜像。</span></li>
<li aria-level="1"><strong>容器</strong> <span>:是一个图像的实例。单个图像有几个可用的容器。</span></li>
<li aria-level="1">Docker守护进程 <span>:守护进程执行主要任务，比如创建、运行和监控容器，以及构建和存储映像。</span></li>
<li aria-level="1"><strong>客户端</strong> <span>:客户端借助HTTP与Docker守护进程通信。</span></li>
</ul>
<p>现在，让我们从Docker命令列表开始。我们将首先介绍上面提到的Docker体系结构的五个实体的Docker命令。</p>
<h2 id="docker-commands-cheat-sheet"><strong> Docker命令备忘单</strong></h2>
<p><strong> <a class="btn btn-primary btn-call-to-action " href="https://drive.google.com/file/d/1JCm0GKQkTOsuDW4jOStkeHVJZ1AkhMPT/view?usp=sharing" target="_blank" rel="noopener">下载备忘单</a> </strong></p>
<h3 id="registry-repository"><strong>注册处&amp;存储库</strong></h3>
<p><span>存储库是指为容器创建文件系统的映像的托管集合。Registry是指包含存储库并提供帮助管理存储库的HTTP API的主机。</span></p>
<p>Docker有一个包含数千个存储库的中央注册中心。但是在使用这个注册表中的图像之前，请确保验证它们以避免安全问题。</p>
<ul>
<li aria-level="1"><strong> docker登录</strong> <span>:登录注册表。</span></li>
<li aria-level="1"><strong> docker logout </strong> <span>:从注册表中注销。</span></li>
<li aria-level="1"><strong> docker搜索</strong> <span>:它会在注册表中搜索图片。</span></li>
<li aria-level="1"><strong> docker pull </strong> <span>:它将从注册表中提取一个图像到本地机器。</span></li>
<li aria-level="1"><strong>docker push</strong><span><span>: It will push an image to the registry from the local machine.</span></span>
<p><strong>图像</strong></p>
</li>
</ul>
<h3 id="images">您可以将图像作为Docker容器的模板。您可以运行以下命令来处理图像:</h3>
<p><strong> docker图片:</strong> <span>它会显示所有图片。</span></p>
<ul>
<li aria-level="1"><strong> docker导入:</strong> <span>你可以从一个tarball创建一个图像。</span></li>
<li aria-level="1"><strong> docker build: </strong> <span>你可以从Dockerfile创建一个镜像。</span></li>
<li aria-level="1"><strong> docker commit: </strong> <span>你可以从一个容器中创建一个映像，如果它正在运行，可以暂时暂停它。</span></li>
<li aria-level="1"><strong> docker rmi: </strong> <span>它会移除一个图像。</span></li>
<li aria-level="1"><strong> docker load </strong> <span>:它将从一个tar文档中加载一个图像作为STDIN，包括图像和标签。</span></li>
<li aria-level="1"><strong> docker: </strong> <span>它会将一个图像保存到一个tar存档流中，并输出所有的父层、标签、&amp;版本。</span></li>
<li aria-level="1"><strong> docker历史</strong> <span>:显示图像的历史</span></li>
<li aria-level="1"><strong> docker tag </strong> <span>:它会给图片贴上一个名字标签。</span></li>
<li aria-level="1"><strong>docker load&lt;my _ image . tar . gz</strong><span>:它会从所提到的文件中加载一张图片，并附上它的历史记录。</span></li>
<li aria-level="1"><strong>docker save my _ image:my _ tag | gzip&gt;my _ image . tar . gz</strong><span>:它会保存一个已经存在的文件。</span></li>
<li aria-level="1"><strong>cat my _ container . tar . gz | docker import-my _ image:my _ tag</strong><span>:它会从提到的文件中导入容器作为图像，而不包含它的历史；因此，文件很小。</span></li>
<li aria-level="1"><strong>docker export my _ container | gzip&gt;my _ container . tar . gz</strong><span>:会导出容器。</span></li>
<li aria-level="1"><strong> docker push repo[:tag] </strong> <span>:它将从注册表中推送一个映像或repo。</span></li>
<li aria-level="1"><strong>docker pull repo[:tag]:</strong><span>它会从注册表中拉出一个映像或repo。</span></li>
<li aria-level="1"><strong>集装箱</strong></li>
<li aria-level="1"><strong>docker search text:</strong><span><span> It will allow you to search for an image in the official registry.</span></span>
<p>容器是包含要执行的代码的独立Docker进程。</p>
</li>
</ul>
<h3 id="container"><strong> docker create: </strong> <span>它会创建一个容器而不启动它。</span></h3>
<p><strong>码头工人重命名</strong> <span>:重新制造集装箱。</span></p>
<ul>
<li aria-level="1"><strong> docker run </strong> <span>:它会在一个任务中创建并启动容器。</span></li>
<li aria-level="1"><strong> docker rm: </strong> <span>它会删除一个容器。</span></li>
<li aria-level="1"><strong> docker更新</strong> <span>:它将更新一个容器的资源限制。</span></li>
<li aria-level="1">通常，如果你在没有任何选项的情况下运行容器，它会立即启动和停止。</li>
<li aria-level="1"><strong>docker run-TD container _ id</strong><span>:它会保持容器运行，-t会分配一个伪TTY会话，-d会自动分离容器。</span></li>
</ul>
<p><strong> docker run - rm </strong> <span>:一旦停止就会把集装箱移走。</span></p>
<ul>
<li aria-level="1"><strong>docker run-v $ HOSTDIR:$ docker dir</strong><span>:将主机上的一个目录映射到docker容器。</span></li>
<li aria-level="1"><strong> docker rm -v </strong> <span>:它将删除与容器相关联的卷。</span></li>
<li aria-level="1"><strong>Docker run-log-driver = syslog</strong></li>
<li aria-level="1"><strong> docker start </strong> <span>:它会启动一个容器，所以它在运行。</span></li>
<li aria-level="1"><strong> docker stop </strong> <span>:停止正在运行的集装箱。</span></li>
<li aria-level="1"><strong> docker restart </strong> <span>:停止并启动一个集装箱。</span></li>
<li aria-level="1"><strong> docker pause: </strong> <span>它会暂停一个正在运行的容器，把它“冻结”在原地。</span></li>
<li aria-level="1"><strong> docker unpause </strong> <span>:将一个运行中的容器解包。</span></li>
<li aria-level="1"><strong> docker wait </strong> <span>:它会一直阻塞，直到正在运行的集装箱停止。</span></li>
<li aria-level="1"><strong> docker kill </strong> <span>:它向一个正在运行的容器发送一个SIGKILL。</span></li>
<li aria-level="1"><strong> docker attach </strong> <span>:它将连接到一个正在运行的容器。</span></li>
<li aria-level="1">docker run-It-c 512 agile ek/CPU set-test<span>:它让你限制CPU，要么使用所有CPU的百分比，要么使用特定的核心。1024意味着100%的CPU，因此如果您希望容器占用所有CPU核心的50%，您应该指定512。</span></li>
<li aria-level="1"><strong>docker run-it-cpuset-CPU = 0，4，6 agileek/cpuset-test </strong> <span>:使用cpuset-CPU的CPU核心。</span></li>
<li aria-level="1"><strong>docker run-it-m 300m Ubuntu:14.04/bin/bash</strong><span>:对Docker设置内存约束。</span></li>
<li aria-level="1"><strong>docker run-RM-it-cap-add SYS _ ADMIN-device/dev/fuse sshfs</strong><span>:使用cap-add设置Linux功能。它允许您挂载基于FUSE的文件系统，并且您需要将-- cap-add和-- device结合起来</span></li>
<li aria-level="1">docker run-it-device =/dev/ttyusb 0 debian bash<span>:提供对单个设备的访问。</span></li>
<li aria-level="1">docker run-it-privileged-v/dev/bus/USB:/dev/bus/USB debian bash<span>:提供对所有设备的访问。</span></li>
<li aria-level="1"><strong> docker ps </strong> <span>:显示正在运行的集装箱。</span></li>
<li aria-level="1"><strong> docker日志</strong> <span>:提供容器中的日志。(您可以使用定制的日志驱动程序，但是在1.10中，日志只适用于json-file和journald)。</span></li>
<li aria-level="1"><strong> docker inspect </strong> <span>:检查一个集装箱的所有信息(包括IP地址)。</span></li>
<li aria-level="1"><strong> docker事件</strong> <span>:从容器中获取事件。</span></li>
<li aria-level="1"><strong> docker port </strong> <span>:显示集装箱面向公众的港口。</span></li>
<li aria-level="1"><strong> docker top: </strong> <span>它会显示容器中正在运行的进程。</span></li>
<li aria-level="1"><strong> docker stats </strong> <span>:显示容器的资源使用统计。</span></li>
<li aria-level="1"><strong> docker diff: </strong> <span>它会显示容器的FS中发生变化的文件。</span></li>
<li aria-level="1"><strong> docker ps -a </strong> <span>:显示正在运行和停止的集装箱。</span></li>
<li aria-level="1"><strong> docker stats - all </strong> <span>:会显示所有容器的列表，默认显示刚刚运行。</span></li>
<li aria-level="1">docker cp  <span>:它会在容器和本地文件系统之间复制文件或文件夹。</span></li>
<li aria-level="1">docker export  <span>:它将把容器文件系统转换成一个tarball归档流输出到STDOUT。</span></li>
<li aria-level="1"><strong> docker exec </strong> <span>:执行一个容器中的命令。</span></li>
<li aria-level="1"><strong>docker exec-it foo/bin/bash</strong><span>:要进入一个正在运行的容器，在一个名为foo的正在运行的容器上附加一个新的shell进程。</span></li>
<li aria-level="1"> </li>
<li aria-level="1"><strong> Dockerfile备忘单</strong></li>
<li aria-level="1"><strong>docker commit container image:</strong><span><span> It will commit a new docker image.</span></span>
<p>这是一个配置文件，当你运行docker构建时，它将建立一个Docker容器。要创建docker文件，您可以使用以下任何文本编辑器及其语法突出显示模块。</p>

</li>
</ul>
<h3 id="dockerfile-cheat-sheet"><span>崇高文字2 </span></h3>
<p><span> Atom </span></p>
<ul>
<li aria-level="1"><span> Vim </span></li>
<li aria-level="1"><span> Emacs </span></li>
<li aria-level="1">文字</li>
<li aria-level="1"><span> VS代码</span></li>
<li aria-level="1"><span>以下是您在使用Dockerfile时可以使用的一些说明:</span></li>
<li aria-level="1"> <span>起<strong>:为后续指令设置基础图像。</strong></span></li>
</ul>
<p><strong> MAINTAINER </strong> <span>(已弃用——用标签代替):它将设置生成图像的作者字段。</span></p>
<ul>
<li aria-level="1"><strong>运行</strong> <span>:它将在当前图像之上的新图层中执行任何命令，然后提交结果。</span></li>
<li aria-level="1"><strong> CMD </strong> <span>:提供执行容器的默认值。</span></li>
<li aria-level="1"><strong> EXPOSE </strong> <span>:它会告诉Docker容器在运行时监听指定的网络端口。</span></li>
<li aria-level="1"><strong>添加</strong> <span>:将新文件、目录或远程文件复制到容器中。</span></li>
<li aria-level="1"><strong>复制</strong> <span>:将新的文件或目录复制到一个容器中。默认情况下，无论用户/WORKDIR设置如何，它都会以root用户身份进行复制。使用- chown= &lt;用户&gt; : &lt;组&gt;将所有权提供给另一个用户/组。</span></li>
<li aria-level="1"><strong>入口点</strong> <span>:它将配置一个作为可执行文件运行的容器。</span></li>
<li aria-level="1"><strong> VOLUME </strong> <span>:为外部挂载的卷或其他容器创建一个挂载点。</span></li>
<li aria-level="1"><strong>用户</strong> <span>:为后面的RUN / CMD / ENTRYPOINT命令设置用户名。</span></li>
<li aria-level="1"><strong>工作目录</strong> <span>:设置工作目录。</span></li>
<li aria-level="1"><strong> ARG </strong> <span>:它让你定义一个构建时变量。</span></li>
<li aria-level="1"><strong>网络</strong></li>
<li aria-level="1">Docker有一个特色网络，允许容器连接。您可以使用Docker创建三个网络接口，即网桥、主机和无。</li>
<li aria-level="1"><strong>ONBUILD</strong><span><span>: It will add a trigger instruction when the image is used as the base for another build.</span></span>
<p>默认情况下，新容器被发送到桥接网络中。为了在几个容器之间建立通信，您需要一个新的网络来启动其中的容器。它让容器在与未连接到网络的其他容器隔离的同时进行通信。 <span> </span></p>
</li>
</ul>
<h3 id="networks"><strong> docker网络创建名称</strong> <span>:默认情况下会创建一个新的网桥类型的网络。</span></h3>
<p><strong> docker network rm NAME </strong> <span>:它将删除一个或多个由NAME指定的网络，并确保没有容器连接到被删除的网络。</span></p>
<p><strong> docker network ls </strong> <span>:会列出所有的网络。</span></p>
<ul>
<li aria-level="1"><strong> docker网络监控名称</strong> <span>:显示一个或多个网络的详细信息。</span></li>
<li aria-level="1"><strong> docker网络连接网络容器</strong> <span>:将容器连接到网络</span></li>
<li aria-level="1"><strong>卷</strong></li>
<li aria-level="1">Docker的卷是自由浮动的文件系统。因此不需要连接到特定的容器。为了便于携带，您可以使用从纯数据容器装载的卷。根据Docker 1.9.0，它带有命名卷，取代了纯数据容器。</li>
<li aria-level="1"><strong> docker卷创建</strong> <span>:创建卷。</span></li>
<li aria-level="1"><strong>docker network disconnect NETWORK CONTAINER</strong><span><span>: It will disconnect a container from a network.</span></span>
<p><strong> docker卷rm </strong> <span>:移除卷。</span></p>
</li>
</ul>
<h3 id="volumes"><strong> docker卷ls </strong> <span>:列出卷。</span></h3>
<p><strong>编排</strong></p>
<ul>
<li aria-level="1">编排管理容器的生命周期，尤其是在动态环境中。您可以使用它来控制和自动化容器的几个任务。</li>
<li aria-level="1">在一长串Docker编排工具中，最常用的编排工具是Docker Swarm、Kubernetes和Mesos。在这个Docker备忘单中，我们使用了Docker Swarm命令。</li>
<li aria-level="1"><strong>Docker swarm init-advertise-addr 10 . 1 . 0 . 2</strong><span>:初始化swarm模式，监听特定接口。</span></li>
<li aria-level="1"><strong>docker volume inspect</strong><span><span>: To inspect the volumes.</span></span>
<p><strong>Docker swarm join-token&lt;manager-token&gt;10 . 1 . 0 . 2:2377</strong><span>:它将作为管理节点加入一个已有的swarm。</span></p>
</li>
</ul>
<h3 id="orchestrate"><strong>Docker swarm join-token&lt;worker-token&gt;10 . 1 . 0 . 2:2377</strong><span>:它将作为一个工作者节点加入一个swarm。</span></h3>
<p><strong> Docker node ls </strong> <span>:会列出群中的所有节点。</span></p>
<p><strong>Docker service create-replicas 3-p 80:80 name-webn gix</strong><span>:它将从现有端口上的映像创建一个服务，并部署三个实例。</span></p>

<ul>
<li aria-level="1"><strong> Docker service ls </strong> <span>:它会列出成群运行的服务。</span></li>
<li aria-level="1">Docker service scale web=5  <span>:它会对服务进行缩放。</span></li>
<li aria-level="1"> </li>
<li aria-level="1"><strong>与容器的交互</strong></li>
<li aria-level="1"><span>你可以使用以下命令与容器交互。</span></li>
<li aria-level="1"><strong>Docker exe-ti container _ name command . sh</strong><span>:它会在容器中运行一个命令。</span></li>
<li aria-level="1"><strong> Docker logs -ft集装箱名称</strong> <span>:跟随集装箱日志。</span></li>
<li aria-level="1"><strong>docker service ps web</strong><span><span>: It will list the tasks of service.</span></span>
<p><strong>建造</strong></p>

</li>
</ul>
<h3 id="interaction-with-container">您可以使用以下命令从Docker文件构建图像。</h3>
<p>Docker build-t myapp:1.0<span>-将从Docker文件构建一个图像并标记它。</span></p>
<ul>
<li aria-level="1"><strong> Docker images </strong> <span> -它将列出所有本地存储的图像</span></li>
<li aria-level="1"><strong>Docker RMI alpine:3.4</strong><span><span>会从Docker存储中删除一张图片。</span> </span></li>
<li aria-level="1"><strong>Docker commit -m “commit message” -a “author” container_name username/image_name: tag</strong><span><span>: It will save the running container as an image.</span></span>
<p><span><span><a class="btn btn-primary btn-call-to-action btn-block" href="https://click.linksynergy.com/link?id=jU79Zysihs4&amp;offerid=1045023.3490000&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fdocker-kubernetes-the-practical-guide%2F" target="_blank" rel="noopener">Docker&amp;Kubernetes:实用指南【2023版】</a> </span> </span></p>
</li>
</ul>
<h3 id="build"><strong>清理</strong></h3>
<p>为了优化资源的使用，您需要经常清理资源以保持性能。您可以运行以下命令来清理资源。</p>
<ul>
<li aria-level="1"><strong> Docker图像修剪</strong> <span>:它将清理一个未使用的/悬空的图像</span></li>
<li aria-level="1"><strong> Docker image prune -a </strong> <span>:它将删除一个没有在容器中使用的图像。</span></li>
<li aria-level="1">Docker系统修剪 <span>:它会修剪整个系统。</span></li>
</ul>
<p><strong> Docker蜂群离开</strong> <span>:它会离开蜂群。</span></p>
<h3 id="cleanup"><strong>docker stack RM stack _ name</strong><span>:会移除一个蜂群。</span></h3>
<p><strong> Docker杀$ (docker ps -q) </strong> <span>:会v. </span></p>
<ul>
<li aria-level="1"><strong>docker RM $(docker PS-a-q)</strong><span>:将删除所有停止的集装箱</span></li>
<li aria-level="1"><strong>服务</strong></li>
<li aria-level="1">现在让我们先睹为快，看看用于查看正在运行的服务、运行服务、查看所有服务日志以及扩展服务的命令。</li>
<li aria-level="1"><strong> Docker service ls </strong> <span>:它会列出一个群中运行的所有服务。</span></li>
<li aria-level="1"><strong>Docker stack services stack _ name</strong><span>:显示所有正在运行的服务。</span></li>
<li aria-level="1"><strong> Docker服务日志stack_name service_names </strong> <span>:显示所有服务日志。</span></li>
<li aria-level="1"> </li>
<li aria-level="1"><strong>docker rmi $(docker images -q)</strong><span><span>: It will delete all images.</span></span>
<p><strong>坞站-合成Cheat Sheet </strong></p>
</li>
</ul>
<h3 id="services">Compose是一个帮助你定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用YAML文件来配置应用程序服务。在以下命令的帮助下，您可以从您的配置中简单地创建和启动所有服务。</h3>
<p><strong> docker-compose start </strong> <span>:将启动容器。</span></p>
<ul>
<li aria-level="1"><strong> docker-compose stop </strong> <span>:停止集装箱。</span></li>
<li aria-level="1"><strong> docker-compose pause </strong> <span>:会暂停容器。</span></li>
<li aria-level="1"><strong>docker-compose un pause</strong><span>:将容器解包。</span></li>
<li aria-level="1"><strong>Docker service scale stack_name_service_name= replicas</strong><span><span>: It will scale a service across qualified nodes.</span></span>
<p><strong> docker-compose ps </strong> <span>:会列出所有的容器。</span></p>
</li>
</ul>
<h3 id="docker-compose-cheat-sheet"><strong> docker-compose up </strong> <span>:它聚合每个容器的输出(本质上是运行docker-compose logs - follow)。</span></h3>
<p><strong> Docker-compose down </strong> <span>:它停止容器并删除由up创建的容器、网络、卷和映像。</span></p>
<ul>
<li aria-level="1"><strong>Docker-compose-f&lt;Docker-compose-file&gt;up</strong><span>:它将启动你的应用</span></li>
<li aria-level="1"><strong>docker-compose stop-使用-d标志在分离模式下运行docker-compose </strong> <span>，然后你可以在任何需要的时候停止它。</span></li>
<li aria-level="1"><strong>基本示例</strong></li>
<li aria-level="1"><span> <a class="btn btn-primary btn-call-to-action btn-block" href="https://click.linksynergy.com/link?id=jU79Zysihs4&amp;offerid=1045023.2074534&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fdocker-certified-associate%2F" target="_blank" rel="noopener"> Docker认证助理:2023年硕士课程</a> </span></li>
<li aria-level="1"><strong>结论</strong></li>
<li aria-level="1">Docker是一款提供平台即服务服务的软件，通过将软件封装在容器中来创建和部署应用程序。</li>
<li aria-level="1">容器是轻量级的、可移植的实体，可以很容易地被共享，而不需要依赖底层的基础设施或者担心它们与几个系统的兼容性。由于docker容器的特性，许多公司现在都采用它来创建复杂的应用程序。</li>
<li aria-level="1">Docker附带了一系列与其服务相关的术语，例如Docker文件、图像、容器和其他Docker特有的词汇。一切都可以使用Docker命令来处理。在这个 <a href="https://drive.google.com/file/d/1JCm0GKQkTOsuDW4jOStkeHVJZ1AkhMPT/view?usp=sharing"> <strong> Docker备忘单PDF </strong> </a> <strong>，</strong> <span>中，你会得到一个你可以随时查阅的所有Docker命令的列表。</span></li>
<li aria-level="1"><strong>码头工人常见问题解答</strong></li>
</ul>
<p><h3 id="what-are-all-the-docker-commands"><strong>Docker命令都是什么？</strong>T3】</h3></p>

<pre class="language-go"><code># docker-compose.yml

version: '2'

services:

  web:

    build: .

    # build from Dockerfile

    context: ./Path

    dockerfile: Dockerfile

    ports:

     - "5000:5000"

    volumes:

     - .:/code

  redis:

    image: redis</code></pre>

<pre class="language-go"><code>Building

web:

  # build using the Dockerfile

  build: .

 # build using the custom Dockerfile

  build:

    context: ./dir

    dockerfile: Dockerfile.dev

 # build from image

  image: ubuntu

  image: ubuntu:14.04

  image: tutum/influxdb

  image: example-registry:4000/postgresql

  image: a4bc65fd</code></pre>

<pre class="language-go"><code> ports:

    - "3000"

    - "8000:80"  # guest:host

 # expose ports to linked services (not to host)

  expose: ["3000"]

Commands

 # commands to execute

  command: bundle exec thin -p 3000

  command: [bundle, exec, thin, -p, 3000]

 # overriding the entrypoint

  entrypoint: /app/start.sh

  entrypoint: [php, -d, vendor/bin/phpunit]</code></pre>

<pre class="language-go"><code># environment variables

  environment:

    RACK_ENV: development

  environment:

    - RACK_ENV=development

 # environment vars from the specified file

  env_file: .env

  env_file: [.env, .development.env]</code></pre>

<pre class="language-go"><code> # makes the `db` service available as the hostname `database`

  # (implies depends_on)

  links:

    - db:database

    - redis

 # make sure `db` is alive before starting

  depends_on:

    - db</code></pre>

<pre class="language-go"><code># make this service extend another

  extends:

    file: common.yml  # optional

    service: web app

 volumes:

    - /var/lib/mysql

    - ./_data:/var/lib/mysql</code></pre>
<p><strong>Docker命令都是什么？</strong></p>

<h2 id="conclusion">你可以点击这里下载我们的Docker命令备忘单PDF。T3】</h2>
<p><h3 id="what-is-the-env-command-in-docker"><strong>docker中的ENV命令是什么？</strong>T3】</h3></p>
<p><strong>docker中的ENV命令是什么？</strong></p>
<p><span>您可以使用ENV为容器中未来的环境变量提供默认值。您不能通过命令行更改ENV变量，但是如果您愿意，可以使用ARG变量。</span></p>
<h2 id="docker-faqs">在下面Dockerfile的例子中，我们创建了两个变量，一个作为ARG，一个作为ENV。</h2>
<ul>
<li aria-level="1"><strong>使用环境变量</strong>中的参数值</li>
</ul>
<p>【Dockerfile需要CMD吗？</p>
<ul>
<li aria-level="1"><span> CMD指令允许开发者设置一个默认命令，只有在运行一个容器而没有指定命令时才会执行。如果您使用命令运行Docker容器，它将忽略默认命令。如果Dockerfile有多个CMD指令，所有最后的CMD指令都会被忽略。</span></li>
</ul>
<p><span> CMD ["executable "，" param1 "，" param2"] (exec格式，首选)</span></p>
<p><span> CMD ["param1 "，" param2"](为exec表单中的入口点设置额外的默认参数)</span></p>
<p><span>命令参数1参数2(外壳形式)</span></p>
<pre class="language-go"><code>FROM alpine:3.7
ARG VARIABLE_1=5
ENV VARIABLE_2=$VARIABLE_1
RUN echo "print variable value:" $VARIABLE_1
RUN echo " print ENV variable : " $VARIABLE_2</code></pre>
<ul>
<li aria-level="1"><h3 id="how-do-i-learn-docker-commands"> <strong>如何学习Docker命令？</strong>T3】</h3></li>
</ul>
<p>有几个在线和离线的资源可以让你学习Docker命令。为此，您需要对命令行有深入的了解。此外，您可以浏览Docker命令备忘单，温习您的技能，以便快速参考。</p>
<p><h3 id="is-docker-cli-still-free"><strong>Docker CLI还免费吗？</strong>T3】</h3></p>
<ul>
<li aria-level="1">Docker CLI还免费吗？</li>
<li aria-level="1"><span>个人/学生/小企业仍可免费享受Docker。小企业的员工不到250人，年营业额不到1000万美元。</span></li>
<li aria-level="1"><a href="https://www.docker.com/pricing/"> <span>点击此处</span> </a> <span>查看完整定价详情。</span></li>
</ul>
<ul>
<li aria-level="1"><h3 id="how-do-i-execute-a-docker-container"> <strong>如何执行docker容器？</strong>T3】</h3></li>
</ul>
<p>要执行docker exec命令，您必须有一个正在运行的docker容器。如果没有，使用下面的docker run命令启动一个测试容器:</p>
<ul>
<li aria-level="1">这个命令从官方的alpine映像创建一个新的Docker容器。</li>
</ul>
<p>如果你愿意，你可以使用下面的命令重命名你的容器名。</p>
<p>如果你想在Docker容器中运行一个交互式shell，你需要运行带有"-i "(保持容器的输入开放)和"-t "(创建一个shell可以连接的伪终端)标志的" docker exec "。</p>
<ul>
<li aria-level="1">它将在指定的容器中运行sh shell，给出一个基本的shell提示符。若要退出容器，请运行以下命令。</li>
</ul>
<ul>
<li aria-level="1"><span>如果你想在你的容器中以不同的用户身份运行一个命令，运行下面的命令。</span></li>
</ul>
<pre class="language-bash"><code>docker run -d --name container-name alpine watch "date &gt;&gt; /var/log/date.log"</code></pre>
<p><span>为了将环境变量和要运行的命令一起传递到容器中，可以使用-e标志，如下所示。</span></p>
<ul>
<li aria-level="1"><span>为了设置多个变量，对每个变量重复-e标志。</span></li>
</ul>
<pre class="language-bash"><code>docker ps</code></pre>
<ul>
<li aria-level="1">首先，用文本编辑器制作文件。我们将在这里用nano打开一个新文件。</li>
</ul>
<pre class="language-bash"><code>docker rename container-name new-name</code></pre>
<ul>
<li aria-level="1">我们已经使用了。env作为文件名来管理版本控制之外的信息。</li>
</ul>
<pre class="language-bash"><code>docker exec -it container-name sh</code></pre>
<p>将您的KEY=value变量写入文件，每行一个，如下所示。</p>
<pre class="language-bash"><code>Exit</code></pre>
<ul>
<li aria-level="1"><span>保存并关闭文件。要保存文件并退出nano，请按CTRL+O，然后按ENTER保存，再按CTRL+X退出。</span></li>
</ul>
<pre class="language-bash"><code>docker exec --workdir /tmp container-name pwd</code></pre>
<ul>
<li aria-level="1"><span>现在运行docker exec命令，在- env-file之后指定正确的文件名</span></li>
</ul>
<pre class="language-bash"><code>docker exec --user guest container-name whoami</code></pre>
<ul>
<li aria-level="1"> </li>
</ul>
<ul>
<li aria-level="1">
<pre class="language-bash"><code>docker exec -e TEST=sammy container-name env</code></pre>
<p><span>坞站</span><span>【exec】</span><span>env文件。env容器名称env〔t5〕</span></p>
</li>
</ul>
<ul>
<li aria-level="1"> </li>
</ul>
<pre class="language-bash"><code>nano .env</code></pre>
<p><strong>人也在读:</strong></p>
<ul>
<li aria-level="1"><span>Write your KEY=value variables into the file, one per line, like the following.</span></li>
</ul>
<pre class="language-bash"><code>TEST=sammy
ENVIRONMENT=prod</code></pre>
<ul>
<li aria-level="1"><span>Save and close the file. To save the file and exit nano, press CTRL+O, then ENTER to save, then CTRL+X to exit.</span></li>
<li aria-level="1"><span>Now run the docker exec command, specifying the correct filename after --env-file</span></li>
</ul>
<p> </p>
<table>
<tbody>
<tr>
<td>
<p><span>docker </span><span>exec</span><span> --env-file .env container-name env</span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>People are also reading:</strong></p>


									</div>

									</div>    
</body>
</html>