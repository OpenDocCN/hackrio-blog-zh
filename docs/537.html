<html>
<head>
<title>The Ultimate TypeScript Cheat Sheet [2023]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>终极打字稿备忘单[2023]</h1>
<blockquote>原文：<a href="https://hackr.io/blog/typescript-cheat-sheet#0001-01-01">https://hackr.io/blog/typescript-cheat-sheet#0001-01-01</a></blockquote><div><div class="content">
										<p>TypeScript是一种<a href="https://hackr.io/blog/oops-concepts-in-java-with-examples">面向对象的</a>，经过编译的强类型语言。作为一个Javascript超集，它具有Javascript的许多特性，另外还有一些特性。因此，所有现有的JavaScript程序也是类型脚本程序。</p>
<p>TypeScript代码与任何可以运行JavaScript的浏览器、操作系统或环境兼容。因此，这种语言越来越受欢迎——许多科技巨头，如Meta、Google和微软都在利用TypeScript的强大功能。</p>
<p>学习打字可以带来许多薪水丰厚的工作机会。对学习命令的TypeScript列表感兴趣，或者想要快速参考任何TypeScript语法？我们已经为您准备了这份全面的打字稿备忘单。</p>
<p>我们的TypeScript React备忘单将涵盖TypeScript和React TypeScript类型。但是首先，让我们探索一下TypeScript是如何工作的，以及为什么它优于Javascript。</p>

<h2 id="setting-up-typescript"><strong>设置打字稿</strong></h2>
<p>安装TypeScript需要以下工具:</p>
<ul>
<li><a href="https://hackr.io/tutorial/nodejs-tutorial-for-beginners"> <strong> Node.js </strong> </a> <strong> : </strong>运行TypeScript编译器的环境——不需要任何技术知识！</li>
<li><strong> TypeScript编译器:</strong>将TypeScript代码转换成JavaScript的模块。</li>
<li><strong> Visual Studio代码或者VS代码</strong>:代码编辑器，用来写打字稿代码。VS代码优于其他选项，因为它允许您使用Live Server扩展来加速开发过程。</li>
</ul>
<p>让我们开始吧:</p>
<p>1.<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">安装</a> Node.js的最新版本Node.js，完成安装过程。您可以通过在终端上执行“node -v”命令来验证它。</p>
<p>2.之后，执行以下命令:</p>
<pre class="language-typescript"><code>npm install -g TypeScript</code></pre>
<p><img src="../Images/bb7962e5a3d445917746aadd2075e0cc.png" alt="" data-original-src="https://hackr.io/blog/media/npm-install-g-typescript-min.png"/></p>
<p>3.使用以下命令检查安装的版本:</p>

<pre class="language-typescript"><code>tsc --v</code></pre>
<p><img src="../Images/29a7d643339f171939ceee5e48f01592.png" alt="" data-original-src="https://hackr.io/blog/media/tsc-v-min.png"/></p>
<p>4.将以下路径添加到path变量中。</p>
<p><em> "C:\Users\ &lt;用户&gt; \AppData\Roaming\npm" </em></p>
<p>注意:对于这个备忘单，我们使用的是版本4.0.2。</p>
<p>5.使用以下命令全局安装“ts节点”模块:</p>
<pre class="language-typescript"><code>npm install -g ts-node</code></pre>
<p>6.根据您需要的平台安装VS代码并下载最新版本。安装过程完成后，启动VS代码。</p>
<p><img src="../Images/6f81bf7102eb74cea5d1d7557d7592aa.png" alt="" data-original-src="https://hackr.io/blog/media/install-vs-code-and-download-min.png"/></p>
<p>7.要安装live Server扩展，请转到“扩展”选项卡，搜索live Server并单击“安装”按钮。</p>
<p>都准备好了吗？现在，让我们进入编码。</p>
<h2 id="basic-typescript-example"><strong>基本打字稿示例</strong></h2>
<p>下面是我们如何创建一个基本的TypeScript示例。</p>
<p>1.创建一个文件夹来存储代码，命名为“helloworld”</p>
<p>2.现在，要编写代码，请在VS代码编辑器中打开文件夹。之后，创建一个名为“app.ts”的类型脚本文件。</p>
<pre class="language-typescript"><code>let message: string = 'Hello, User!';

console.log(message);</code></pre>
<p><img src="../Images/f868589a7d76d066647aed364edd3940.png" alt="" data-original-src="https://hackr.io/blog/media/basic-typescript-example-min.png"/></p>
<p>3.使用键盘快捷键“Ctrl+”从VS代码启动终端，或者转到VS代码上的终端选项卡并选择“新建终端:”</p>
<p><img src="../Images/b1545e466fa6fcaa010dcb475d94bcad.png" alt="" data-original-src="https://hackr.io/blog/media/launch-the-terminal-from-the-vs-code-using-the-keyboard-shortcut-min.png"/></p>
<p>4.现在，在终端上使用以下命令编译“app.ts”文件:</p>
<pre class="language-typescript"><code>tsc app.ts</code></pre>
<p><img src="../Images/670a109c81c200827b33affd844bc32b.png" alt="" data-original-src="https://hackr.io/blog/media/now-compile-the-app.png"/></p>
<p>5.“app.js”文件已创建，并列在helloworld文件夹下。使用belo命令执行app.js文件:</p>
<pre class="language-typescript"><code>node app.js</code></pre>
<p><img src="../Images/7116af7e57459a4cfe71a8fa364a57d2.png" alt="" data-original-src="https://hackr.io/blog/media/the-app.png"/></p>
<p>这是您的基本类型脚本示例。现在，让我们看看如何在web浏览器中运行TypeScript程序！</p>
<h3 id="running-typescript-program-in-a-web-browser">在web浏览器中运行TypeScript程序。</h3>
<p>1.创建index.html文件并包含app.js文件:</p>
<pre class="language-html"><code>&lt;!DOCTYPE html&gt;

&lt;html lang="en"&gt;

&lt;head&gt;

&lt;meta charset="UTF-8"&gt;

&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;

&lt;title&gt;TypeScript: Hello User!&lt;/title&gt;

&lt;/head&gt;

&lt;body&gt;

&lt;script src="app.js"&gt;&lt;/script&gt;

&lt;/body&gt;

&lt;/html&gt;</code></pre>
<p>2.更改app.ts代码:</p>
<pre class="language-typescript"><code>let message: string = 'Hello user!';

// create a new heading 1 element

let heading = document.createElement('h1');

heading.textContent = message;

// add the heading the document

document.body.appendChild(heading);</code></pre>
<p>3.使用以下代码编译app.ts文件:</p>
<pre class="language-typescript"><code>tsc app.ts</code></pre>
<p>4.右键单击index.html代码并使用实时服务器打开:</p>
<p><img src="../Images/370194f84aef442441b2795c334c15ea.png" alt="" data-original-src="https://hackr.io/blog/media/right-click-the-index.png"/></p>
<p>5.以下是输出。</p>

<p><img src="../Images/3fee918439167133820696e3050320e9.png" alt="" data-original-src="https://hackr.io/blog/media/the-following-will-be-the-output.png"/></p>
<p><a class="btn btn-primary btn-call-to-action " href="https://click.linksynergy.com/deeplink?id=jU79Zysihs4&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Funderstanding-typescript%2F" target="_blank" rel="noopener">了解TypeScript - 2023版</a></p>
<h2 id="typescript-cheat-sheet"><strong>打字稿备忘单</strong></h2>
<h3 id="toc-1-basic-types"><strong> 1。基本类型</strong></h3>
<p>类型有助于您引用值的不同属性和功能。该值是指可以赋给变量的任何东西，如数字、字符串、数组、对象和函数。例如，“Sam”指定值是字符串类型，因此将具有字符串的属性。</p>
<p>假设“Sam”值有一个名为<em> length </em>的属性，该属性将返回该值中存在的字符数。</p>
<pre class="language-typescript"><code>console.log(“Sam”.length); // 5

Code language: JavaScript (javascript)</code></pre>
<p>除了字符之外，它还可以有许多方法，如match()、indexOf()和toLocaleUpperCase()。</p>
<p>例如:</p>
<pre class="language-typescript"><code>console.log(‘Sam’.toLocaleUpperCase()); // SAM

Code language: JavaScript (javascript)</code></pre>
<p>因此，类型是描述值的不同属性和方法的标签，每个值都有一个类型。有两种不同类型的类型脚本类型:</p>
<ul>
<li><strong>原语类型:</strong>字符串、数字、布尔、空、未定义、符号。</li>
<li><strong>对象类型:</strong>函数、数组、类等。</li>
</ul>
<h3 id="type-annotations-in-typescript"><strong>在类型脚本中键入注释</strong></h3>
<p>TypeScript中的批注显式指定各种标识符的类型。这些标识符包括变量、函数、对象等。</p>
<p>语法:</p>
<pre class="language-typescript"><code>:Type </code></pre>
<p>在标识符名称后使用它。</p>

<p>一旦用某个类型注释了标识符，就只能用该类型来使用它。如果将该标识符用作不同的类型，TypeScript编译器将显示错误。</p>

<h4 id="variables-and-constants"><strong>变量和常数</strong></h4>
<p>您可以使用以下语法来指定变量和常量的注释类型。</p>
<pre class="language-typescript"><code>let variableName: type;

let variableName: type = value;

const constantName: type = value;

The following example specifies the number annotation for a variable:

let counter: number;

Code language: JavaScript (javascript)</code></pre>
<p>请记住，您只能为计数器变量分配一个数字:</p>
<pre class="language-typescript"><code>counter = 1;</code></pre>
<p>如果尝试将字符串赋给计数器变量，可能会遇到以下错误:</p>
<pre class="language-typescript"><code>let counter: number;

counter = 'Hello'; // compile error</code></pre>
<p>两种类型都可以使用以下语法来注释和初始化变量:</p>
<pre class="language-typescript"><code>let counter: number = 1;</code></pre>
<h4 id="arrays"><strong>数组</strong></h4>
<p>您可以像注释变量和常量一样注释数组类型，并添加方括号作为后缀。</p>
<pre class="language-typescript"><code>:type[]

let arrayName: type[];

Code language: JavaScript (javascript)</code></pre>
<p>下一个示例帮助您声明一个字符串数组:</p>
<pre class="language-typescript"><code>let names: string[] = ['Jolly', 'Jam', 'Pam', 'Dam', 'Sam'];</code></pre>
<h4 id="objects"><strong>物体</strong></h4>
<p>使用注释来定义对象的类型。</p>
<pre class="language-typescript"><code>let person: {

name: string;

age: number

};

person = {

name: 'John',

age: 25

}; // valid</code></pre>
<p>这里，我们创建了一个具有两个属性的对象“person ”:姓名(字符串)和年龄(数字)</p>
<h4 id="function-arguments-return-types"><strong>函数参数&amp;返回类型</strong></h4>
<p>这里我们将讨论带有函数参数和返回类型的注释:</p>
<pre class="language-typescript"><code>let greeting : (name: string) =&gt; string;</code></pre>
<p>对于返回类型，分配一个只接受和返回指定变量的函数。</p>

<pre class="language-typescript"><code>greeting = function (name: string) {

return `Hi ${name}`;

};</code></pre>
<p>在下面的代码中，我们分配给“greeting”的函数与函数类型不匹配。因此，它会导致错误。</p>

<pre class="language-typescript"><code>greeting = function () {

console.log('Hello');

};</code></pre>
<h3 id="typescript-number"><strong>打字稿号</strong></h3>
<p>要声明具有浮点值的变量，可以使用以下语法:</p>
<pre class="language-typescript"><code>let price: number;</code></pre>
<p>您也可以将变量初始化为一个数字:</p>
<pre class="language-typescript"><code>let price = 9.95;</code></pre>
<p>像任何其他语言一样，TypeScript也支持十进制、十六进制、二进制和八进制的数字文本。</p>
<h4 id="decimal-numbers"><strong>十进制数字</strong></h4>
<pre class="language-typescript"><code>let counter: number = 0;

let x: number = 150, 

y: number = 240;</code></pre>
<h4 id="binary-numbers"><strong>二进制数</strong></h4>
<pre class="language-typescript"><code>let bin = 0b100;

let anotherBin: number = 0B010;</code></pre>
<p>0b或0B后使用0或1必须是0或1。</p>
<h4 id="hexadecimal-numbers"><strong>十六进制数字</strong></h4>
<p>它们以零开始，后面是小写或大写字母x(0x或0X)。0x后面的数字应该在范围内(0123456789ABCDEF)。</p>
<p>例如:</p>
<pre class="language-typescript"><code>let hexadecimal: number = 0XA;

Code language: JavaScript (javascript)</code></pre>
<h4 id="big-integers"><strong>大整数</strong></h4>
<p>对于大整数，可以表示大于253的整数。您必须在大整数文字的末尾指定“n”字符。</p>
<p>例如:</p>
<pre class="language-typescript"><code>let big: bigint = 9007199254740991n;</code></pre>
<h3 id="typescript-string"><strong>打字字符串</strong></h3>
<p>我们可以利用双引号(")或单引号(')来表示字符串文字。</p>
<pre class="language-typescript"><code>let firstName: string = 'Linda';

let title: string = "Web Developer";

Code language: JavaScript (javascript)</code></pre>
<p>为了表示字符，TypeScript使用了反斜杠(')。利用模板字符串，我们可以创建多行字符串。</p>
<p>以下示例显示如何使用反勾号(')创建多行字符串。</p>
<pre class="language-typescript"><code>let description = `Welcome to Hackr.io

Get tutorials you need 

and master`;

Code language: JavaScript (javascript)</code></pre>
<p>要将变量合并到字符串中，您需要利用字符串。</p>
<p>例如:</p>
<pre class="language-typescript"><code>let firstName: string = `Sam`;

let title: string = `Content Writer`;

let profile: string = `I'm ${firstName}. 

I'm a ${title}`;

console.log(profile);</code></pre>
<h3 id=""><strong><img src="../Images/14181ce23a64f13af1b843063afec1fb.png" alt="" data-original-src="https://hackr.io/blog/media/to-incorporate-variables-into-strings-you-need-to-leverage-string.png"/>T2】</strong></h3>
<h3 id="typescript-boolean"><strong>打字稿布尔型</strong></h3>
<p>TypeScript boolean是一种基本类型，它允许使用两个值:true和false。</p>
<p>例如:</p>
<pre class="language-typescript"><code>let pending: boolean;

pending = true;

// after a while

// ..

pending = false;

Code language: JavaScript (javascript)</code></pre>
<p>布尔类型的字母B是大写的，这使它不同于布尔类型。我们的建议？避免使用布尔类型。</p>
<p>例如:</p>
<pre class="language-typescript"><code>let pending: boolean;

pending = true;

// after a while

// ..

pending = false;

Code language: JavaScript (javascript)</code></pre>
<p>JavaScript带有一个布尔类型，我们称之为非原始装箱对象。布尔类型不同于布尔类型，因为前者有大写的b。</p>
<h3 id="typescript-object-type"><strong>类型脚本对象类型</strong></h3>
<p>TypeScript对象类型表示所有基元类型值。</p>
<p>TypeScript中的基元类型:</p>
<ul>
<li>number</li>
<li>bigint</li>
<li>string</li>
<li>boolean</li>
<li>null</li>
<li>未定义符号</li>
<li>下面的示例指定如何声明保存对象的变量。</li>
</ul>
<p>例如:</p>
<p><img src="../Images/babaff6813730e4cdd6de090baa6d9f1.png" alt="" data-original-src="https://hackr.io/blog/media/the-following-example-specifies-how-to-declare-a-variable-that-holds-an-object.png"/></p>
<pre class="language-typescript"><code>let employee: object;

employee = {

firstName: 'Sam',

lastName: 'Will',

age: 25,

jobTitle: 'Writer'

};

console.log(employee);</code></pre>
<p>如果您想将一个基本值重新分配给employee对象，您将会收到一个错误:</p>
<p><img src="../Images/80ddb94a94a53ace9b5da5ca55bb236d.png" alt="" data-original-src="https://hackr.io/blog/media/if-you-want-to-reassign-a-primitive-value-to-the-employee-object-you-will-receive-an-error-min.png"/></p>
<pre class="language-typescript"><code>employee = "Jimmy";

Code language: JavaScript (javascript)</code></pre>
<p>这里的“雇员”是一个具有固定属性集的对象类型。如果访问“雇员”范围之外的属性，可能会遇到错误</p>
<p><img src="../Images/e6a5bd89a2b3cd8d6bf80b47a1bdc940.png" alt="" data-original-src="https://hackr.io/blog/media/here-employee-is-an-object-type-having-a-fixed-set-of-properties.png"/></p>
<pre class="language-typescript"><code>console.log(employee.hireDate);

Code language: CSS (css)</code></pre>
<p>以下语法允许您显式定义employee对象属性:</p>
<p>将employee对象分配给文字对象:</p>
<pre class="language-typescript"><code>let employee: {

firstName: string;

lastName: string;

age: number;

jobTitle: string;

};</code></pre>
<p>或者，您可以在同一语句中使用组合语法:</p>
<pre class="language-typescript"><code>employee = {

firstName: ‘Jimmy’,

lastName: ‘Will’,

age: 30,

jobTitle: 'Writer'

};</code></pre>
<p><strong>物体对物体</strong></p>
<pre class="language-typescript"><code>let employee: {

firstName: string;

lastName: string;

age: number;

jobTitle: string;

} = {

firstName: ‘Jimmy’,

lastName: ‘Will’,

age: 30,

jobTitle: 'Writer'

};</code></pre>
<h4 id="object-vs-object">TypeScript支持另一种名为Object的类型，其大写字母为O。</h4>
<p>我们知道对象类型表示所有非原始值。同时，<em> O </em>对象类型代表所有对象的功能。</p>
<p><strong>空型{} </strong></p>
<h4 id="the-empty-type">类似于对象类型，TypeScript具有由空类型{}指定的空类型。它描述一个没有属性的对象。如果您尝试使用这样的对象访问任何属性，将会收到以下编译时错误:</h4>
<p><img src="../Images/f1b2e06022854f8102fe4f1e38d10a61.png" alt="" data-original-src="https://hackr.io/blog/media/similar-to-the-object-type-typescript-has-an-empty-type-specified-by-the-empty-type-min.png"/></p>
<pre class="language-typescript"><code>let vacant: {};

vacant.firstName = 'John';</code></pre>
<p>但是，您可以轻松地访问对象类型上声明的所有属性和方法。例如:</p>
<p><strong><img src="../Images/87344cd351b260d2d6a222868208bee2.png" alt="" data-original-src="https://hackr.io/blog/media/but-you-can-easily-access-all-the-properties-and-methods-declared-on-the-object-type.png"/>T2】</strong></p>
<pre class="language-typescript"><code>let vacant: {} = {};

console.log(vacant.toString());</code></pre>
<h3 id="-1"><strong> TypeScript数组类型</strong></h3>
<h3 id="typescript-array-type">TypeScript数组被称为数据的有序列表。</h3>
<p>以下语法声明了一个具有特定类型值的数组:</p>
<p>例如，您可以使用以下语法来声明字符串数组:</p>
<pre class="language-typescript"><code>let arrayName: type[];</code></pre>
<p>此外，您可以向上述数组中添加多个字符串值:</p>
<pre class="language-typescript"><code>let skills: string[];</code></pre>
<p>或者可以使用push()方法向现有数组中输入新值:</p>
<pre class="language-typescript"><code>skills[0] = "Game";

skills[1] = "Study";</code></pre>
<p>在一行中定义一个数组:</p>
<pre class="language-typescript"><code>skills.push('Science');</code></pre>
<p><img src="../Images/6dc3e5ec4caac715e9b3521b74b5134b.png" alt="" data-original-src="https://hackr.io/blog/media/define-an-array-within-one-line-min.png"/></p>
<pre class="language-typescript"><code>let skills = ['Games','Study','Dance'];</code></pre>
<p>一旦定义了特定类型的数组，就不能向数组中添加任何不兼容的值，否则会收到一条错误消息:</p>
<p><img src="../Images/7939e5c6ea218d404f6849a24a77503e.png" alt="" data-original-src="https://hackr.io/blog/media/once-you-define-an-array-of-a-specific-type-you-cannot-add-any-incompatible-values-to-the-array-min.png"/></p>
<pre class="language-typescript"><code>skills.push(100);</code></pre>
<p>现在，让我们提取数组的第一个元素:</p>
<p>发生类型推断。</p>
<pre class="language-typescript"><code>let skill = skills[0];

console.log(typeof(skill));</code></pre>
<p>我们已经提取了“技能”数组的第一个元素。后来，我们把它赋给了变量‘skill’。</p>
<p><strong>存储混合类型的值</strong></p>
<h4 id="storing-values-of-mixed-types">现在让我们讨论如何将不同类型的值添加到数组中。</h4>
<p>上面的数组是混合类型的数组，即string | number:</p>
<pre class="language-typescript"><code>let scores = ['Programming', 5, 'Software Design', 4];</code></pre>
<p><strong><img src="../Images/ed55a307f9c65be0a00f559d373cb865.png" alt="" data-original-src="https://hackr.io/blog/media/let-us-now-discuss-how-to-add-values-of-different-types-to-an-array-min.png"/>T2】</strong></p>
<pre class="language-typescript"><code>let scores : (string | number)[];

scores = ['Programming', 5, 'Software Design', 4];</code></pre>
<h3 id="-2"> </h3>
<h3 id="-3"><strong>打字脚本元组</strong></h3>
<h3 id="typescript-tuple">元组的工作方式类似于数组，但有一些额外的考虑。一个元组有固定数量的元素，没有一个元素是相同的。例如，您可以使用元组将值指定为一对字符串和一个数字:</h3>
<p><img src="../Images/4b0dfcef1af075079dbe3dd43765db9c.png" alt="" data-original-src="https://hackr.io/blog/media/a-tuple-works-like-an-array-but-with-some-additional-considerations-min.png"/></p>
<pre class="language-typescript"><code>let skill: [string, number];

skill = [‘Sam’, 25];</code></pre>
<p>始终注意存储值的顺序。如果您错误地更改了顺序，您将得到一个错误:</p>
<p><strong><img src="../Images/00f6aced08e238e98dbbfb576be9186e.png" alt="" data-original-src="https://hackr.io/blog/media/always-take-care-of-the-order-in-which-you-have-your-values-stored-min.png"/>T2】</strong></p>
<pre class="language-typescript"><code>let skill: [string, number];

skill = [5, 'Programming'];</code></pre>
<h3 id="-4"><strong>类型脚本枚举</strong></h3>
<h3 id="typescript-enum">枚举(枚举类型)是指一组命名的常数值。enum关键字用于将enum定义为枚举名称的前缀。然后，为枚举定义常数值。</h3>
<p>下面是语法:</p>
<p>在这里，常数1、常数2等。是枚举成员。</p>
<pre class="language-typescript"><code>enum name {constant1, constant2, ...};</code></pre>
<p>示例:</p>
<p>在此示例中，枚举名称为Month，常量值为Jan、Feb、Mar等。</p>
<pre class="language-typescript"><code>enum Month { Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep, Oct,Nov,Dec};</code></pre>
<p>现在，我们将使用月份枚举作为参数来声明一个函数。</p>
<p><strong><img src="../Images/b49ad0403c74d622cc8b255790ce7d87.png" alt="" data-original-src="https://hackr.io/blog/media/now-we-will-declare-a-function-using-the-month-enum-as-the-parameter-min.png"/>T2】</strong></p>
<pre class="language-typescript"><code>function WhatMonth(month: Month) {

let SummerMon: boolean;

switch (month) {

case Month.Jun:

case Month.Jul:

case Month.Aug:

SummerMon = true;

break;

default:

SummerMon = false;

break;

}

return SummerMon;

}

console.log(SummerMon(Month.Jun)); </code></pre>
<h3 id="-5"><strong>打印任何类型</strong></h3>
<h3 id="typescript-any-type">在某些情况下，您可能需要在不知道变量类型的情况下将值存储在变量中。第三方API或用户输入可以提供该值。在这种情况下，可能需要进行类型检查，并且该值可以通过编译时检查。</h3>
<p>为此，我们使用“any”类型。</p>
<p>“任意”类型允许您为任意类型变量赋值。</p>
<p><img src="../Images/6a23fc6136d0f9d4e5e23d7c49814b85.png" alt="" data-original-src="https://hackr.io/blog/media/in-some-scenarios-you-may-need-to-store-a-value-in-a-variable-without-knowing-its-type-min.png"/></p>
<pre class="language-typescript"><code>// json may come from a third-party API

const json = `{"latitude": 10.11, "longitude":12.12}`;

// parse JSON to find location

const currentLocation = JSON.parse(json);

console.log(currentLocation);</code></pre>
<p>在本例中，JSON.parse()函数返回一个对象，我们将currentLocation变量赋给该对象。但是，当使用currentLocation访问对象属性时，TypeScript不会执行任何检查:</p>
<p><img src="../Images/1454fcea6d4d475a385d097b466039d1.png" alt="" data-original-src="https://hackr.io/blog/media/in-this-example-the-json.png"/></p>
<pre class="language-typescript"><code>console.log(currentLocation.x);</code></pre>
<p>编译时不会有问题。</p>
<p>如果您声明了一个变量而没有提到类型，TypeScript会将其假定为任何类型，这就是所谓的类型推断。这意味着TypeScript将猜测变量类型。</p>
<p><strong>打字稿作废类型</strong></p>
<h3 id="typescript-void-type">void类型指定没有特定的类型。它在某种程度上与“任何”类型相反。</h3>
<p>例如:</p>
<p>当任何函数不要求你返回值时，使用void类型。这将提高代码的清晰度，并确保类型安全。此外，不需要导航整个函数体来检查它是否返回任何东西。</p>
<pre class="language-typescript"><code>function log(message): void {

console.log(message);

}</code></pre>
<p>假设你对一个变量使用void类型，并赋值“undefined”这样的空类型是没有用的。例如:</p>
<p><img src="../Images/7c6455c7fb9af5d5b48a6f24cbba8b47.png" alt="" data-original-src="https://hackr.io/blog/media/suppose-you-use-the-void-type-for-a-variable-and-assign-min.png"/></p>
<pre class="language-typescript"><code>let useless: void = undefined;

useless = 1; // error</code></pre>
<p><img src="../Images/61bae4a519cfd863dcd603435f6e827a.png" alt="" data-original-src="https://hackr.io/blog/media/if-the-strictnullchecks-flag-is-not-specified-min.png"/></p>
<pre class="language-typescript"><code>If the --strictNullChecks flag is not specified, you can assign the useless to null:

useless = null; </code></pre>
<p><strong>打字稿从不打字</strong></p>
<h3 id="typescript-never-type">never类型意味着不包含任何值，因此不能将任何值赋给never类型的变量。当函数的返回类型抛出错误时，使用never类型。</h3>
<p>例如:</p>
<p>表达式包含无限循环的函数具有never类型。</p>
<pre class="language-typescript"><code>function raiseError(message: string): never {

throw new Error(message);

}

In this next example, the return type of the never type.

function reject() { 

return raiseError('Rejected');

}</code></pre>
<p>例如:</p>
<p><strong><img src="../Images/331bac06a51cf48263415f3921443d11.png" alt="" data-original-src="https://hackr.io/blog/media/a-function-with-an-expression-containing-indefinite-loop-has-the-never-type-min.png"/>T2】</strong></p>
<pre class="language-typescript"><code>let loop = function forever() {

while (true) {

console.log(‘Bye’);

}

}</code></pre>
<h3 id="-6"><strong>打印联合类型</strong></h3>
<h3 id="typescript-union-type">很多时候，您可能会遇到需要数字或字符串类型参数的函数。</h3>
<p>例如:</p>
<p>我们尚未在函数“add()”中指定参数的类型。因此，如果参数是数字，add()执行加法。如果它们是字符串，add()连接这些字符串。</p>
<pre class="language-typescript"><code>function add(x: any, y: any) {

if (typeof x === 'number' &amp;&amp; typeof y === 'number') {

return x+y;

}

if (typeof x === 'string' &amp;&amp; typeof y === 'string') {

return x.concat(y);

}

throw new Error('Parameters must be numbers or strings');

}</code></pre>
<p>但是，如果参数既不是数字也不是字符串，add()将抛出一个错误。</p>
<p>这就是TypeScript联合类型发挥作用的地方。使用联合类型，您可以将各种类型合并为一个。</p>
<pre class="language-typescript"><code>add(true, false);</code></pre>
<p>例如，以下变量属于数字或字符串类型:</p>
<p>联合类型描述可以是几种类型之一的值。</p>
<pre class="language-typescript"><code>let result: number | string;

result = 20; // OK

result = 'Bye'; // also OK

result = true; // a boolean value, not OK</code></pre>
<p><strong> TypeScript类型别名</strong></p>
<h3 id="typescript-type-aliases">类型别名允许您为现有类型创建新名称。但是，现有类型应该是有效的。</h3>
<p>下面让我们来看一个别名类型的例子。</p>
<pre class="language-typescript"><code>type alias = existingType;</code></pre>
<p>这里，我们将类型字符串赋给chars。</p>
<p><strong> TypeScript字符串文字类型</strong></p>
<pre class="language-typescript"><code>type chars = string;

let message: chars; // same as string type</code></pre>
<h3 id="typescript-string-literal-types">在字符串类型的帮助下，您可以定义一个只接受一个指定字符串的类型。</h3>
<p>在下面的代码中，我们定义了一个字符串文字类型，它接受一个文字字符串“click:”</p>
<p>这里，click是一个字符串类型，只接受字符串“click”</p>
<pre class="language-typescript"><code>let click: 'click';</code></pre>
<p>如果您将“单击”指定给单击，它将是有效的:</p>
<p><img src="../Images/a9ebfe2a783fd4d7707ae77fa7bf1493.png" alt="" data-original-src="https://hackr.io/blog/media/here-the-click-is-a-string-literal-type-that-accepts-only-the-string-literal-min.png"/></p>
<pre class="language-typescript"><code>click = 'click'; // valid</code></pre>
<p>如果将另一个字符串文字“dbclick”赋给click，它会给出一个编译时错误:</p>
<p><img src="../Images/1efd5a816e4e989d78dd4046874a616d.png" alt="" data-original-src="https://hackr.io/blog/media/if-you-assign-another-string-literal-dbclick-to-the-click-it-gives-a-compile-time-error-min.png"/></p>
<pre class="language-typescript"><code>click = 'dblclick'; </code></pre>
<p>当您希望在变量中限制一个可能的字符串值时，字符串文字类型就派上了用场。</p>
<p><strong>打字稿类型推断</strong></p>
<h3 id="typescript-type-inference">类型推断描述了TypeScript在没有显式批注的情况下推断类型的位置和方式。一般来说，我们使用注释来明确定义变量的类型。</h3>
<p>例如:</p>
<p>根据上面的代码，TypeScript将计数器类型视为数字。</p>
<pre class="language-typescript"><code>let counter: number;</code></pre>
<p>例如:</p>
<p>此外，无论何时设置任何函数的参数值，TypeScript都将其类型视为默认值类型。</p>
<pre class="language-typescript"><code>let counter = 0;

Or 

let counter: number = 0;</code></pre>
<p>例如:</p>
<p>在此示例中，TypeScript推断type max参数类型是一个数字。</p>
<pre class="language-typescript"><code>function setCounter(max=100) {

// ...

}</code></pre>
<p><strong> 2。控制流语句</strong></p>
<h2 id="toc-2-control-flow-statements">如果..其他</h2>
<h3 id="if-else">if语句根据条件执行一段代码。在下面的语法中，“if”中的主体仅在给定条件的计算结果为true时执行:</h3>
<p>示例:</p>
<pre class="language-typescript"><code>if(condition) {

// if-statement

}</code></pre>
<p><img src="../Images/6ccce3784fae91790c1b7fb3fcf04f92.png" alt="" data-original-src="https://hackr.io/blog/media/an-if-statement-executes-a-piece-of-code-based-on-a-condition-min.png"/></p>
<pre class="language-typescript"><code>const max = 20;

let counter = 0;

if (counter &lt; max) {

counter++;

}

console.log(counter); </code></pre>
<p>在上面的代码中，只有当counter的值小于max时，它的值才会增加。</p>
<p><strong>键入if…else语句</strong></p>
<h3 id="typescript-if-else-statement">如果“If”中的条件为false，则控制移至执行“else”中的主体。</h3>
<p>例如:</p>
<pre class="language-typescript"><code>if(condition) {

// if-statements

} else {

// else statements;

}</code></pre>
<p><strong><img src="../Images/d0ac1f94b5ebb655e62694c58fb0b472.png" alt="" data-original-src="https://hackr.io/blog/media/if-the-condition-in-if-is-false-the-control-moves-to-executing-the-body-inside-else-min.png"/>T2】</strong></p>
<pre class="language-typescript"><code>const max = 20;

let counter = 10;

if (counter &lt; max) {

counter++;

} else {

counter = 1;

}

console.log(counter);</code></pre>
<h3 id="-7"><strong>三元运算符？:</strong></h3>
<h3 id="ternary-operator">三元运算符(？:)用于使代码更短。是简单条件下if-else的替代。</h3>
<p>例如:</p>
<p><strong><img src="../Images/a85e14faf3e7e3a9b2da4864574ac5f3.png" alt="" data-original-src="https://hackr.io/blog/media/the-ternary-operator-is-used-to-make-the-code-shorter.png"/>T2】</strong></p>
<pre class="language-typescript"><code>const max = 100;

let counter = 100;

counter &lt; max ? counter++ : counter = 1;

console.log(counter);</code></pre>
<h3 id="-8"><strong>键入if…else if…else语句</strong></h3>
<h3 id="typescript-if-else-if-else-statement">如果...否则如果...当您想要检查多个条件时，else语句是理想的。</h3>
<p>示例:</p>
<p><strong><img src="../Images/a074026a8b3f9f090dbcd8d936f3cc88.png" alt="" data-original-src="https://hackr.io/blog/media/the-if.png"/>T2】</strong></p>
<pre class="language-typescript"><code>let dis: number;

let n = 11;

if (n &gt; 0 &amp;&amp; n &lt;= 5) {

dis = 5; // 5% dis

} else if (n &gt; 5 &amp;&amp; n &lt;= 10) {

dis = 10; // 10% dis 

} else {

dis = 15; // 15%

}

console.log(`You got ${dis}% dis. `);</code></pre>
<h3 id="-9"><strong>打字开关盒</strong></h3>
<h3 id="typescript-switch-case">当您希望根据多个值检查expression的值并对找到的匹配项执行代码时，switch case非常有用。</h3>
<p>语法:</p>
<p>示例:</p>
<pre class="language-typescript"><code>switch ( expression ) {

case value1:

// statement 1

break;

case value2:

// statement 2

break;

case valueN:

// statement N

break;

default: 

// 

break;

}</code></pre>
<p><strong><img src="../Images/d604b73d3a0e13ff92902314a977c499.png" alt="" data-original-src="https://hackr.io/blog/media/the-switch-case-is-useful-when-you-want-to-check-the-value-of-expression-against-multiple-values-min.png"/>T2】</strong></p>
<pre class="language-typescript"><code>let tId = 'btnDelete';

switch (tId) {

case 'btnUpdate':

console.log('Update');

break;

case 'btnDelete':

console.log('Delete');

break;

case 'btnNew':

console.log('New');

break;

}</code></pre>
<h3 id="-10"><strong>为</strong>打字稿</h3>
<h3 id="typescript-for">下面是使用“for”循环语句的语法。</h3>
<p>在for循环中，有三个可选表达式，用分号(；)并用括号括起来。</p>
<pre class="language-typescript"><code>for(initialization; condition; expression) {

// statement

}</code></pre>
<p>初始化</p>
<ul>
<li>情况</li>
<li>表示</li>
<li>这三个表达式都是可选的，这意味着您可以使用for循环语句:</li>
</ul>
<p><em>例如:</em></p>
<pre class="language-typescript"><code>for(;;) {

// do something

}</code></pre>
<p><strong><img src="../Images/50f9a4e8c64717f8fa0caf02e4eb63fa.png" alt="" data-original-src="https://hackr.io/blog/media/below-is-the-syntax-for-using-the-for-loop-statements.png"/>T2】</strong></p>
<pre class="language-typescript"><code>for (let i = 0; i &lt; 10; i++) {

console.log(i);

}</code></pre>
<h3 id="-11"><strong>打字稿，而</strong></h3>
<h3 id="typescript-while">使用while语句，您可以创建一个循环，只要条件为真，该循环就会执行一段代码。</h3>
<p>下面是while循环的语法。</p>
<p>要根据另一个条件不成熟地中断循环，需要使用break语句:</p>
<pre class="language-typescript"><code>while(condition) {

// do something

}</code></pre>
<p>例如:</p>
<pre class="language-typescript"><code>while(condition) {

// do something

// ...

if(anotherCondition) 

break;

}</code></pre>
<p><strong><img src="../Images/67e1b1f5b24e5519f6f076c4593a8d12.png" alt="" data-original-src="https://hackr.io/blog/media/using-the-while-statement-you-can-create-a-loop-that-will-execute-a-block-of-code-as-long-as-a.png"/>T2】</strong></p>
<pre class="language-typescript"><code>let counter = 0;

while (counter &lt; 5) {

console.log(counter);

counter++;

}</code></pre>
<h3 id="-12">打字稿做什么..而</h3>
<h3 id="typescript-do-while">下面显示了do的语法...while语句。</h3>
<p>这将运行代码块，直到条件评估为false。该语句总是至少执行一次循环体，因为条件将在代码末尾执行。</p>
<pre class="language-typescript"><code>do {

// do something

} while(condition);</code></pre>
<p>例如:</p>
<p><strong><img src="../Images/41245588c1f2a9fc41f96e215cf25f6d.png" alt="" data-original-src="https://hackr.io/blog/media/the-following-shows-the-syntax-of-the-do.png"/>T2】</strong></p>
<pre class="language-typescript"><code>let i = 0;

do {

console.log(i);

i++

} while (i &lt; 10);</code></pre>
<h3 id="-13"><strong>打字稿中断</strong></h3>
<h3 id="typescript-break">break语句用于终止任何循环，并将程序流传递给下一个立即语句。for、while和do...while语句支持使用break语句。</h3>
<p>例如:</p>
<p><strong><img src="../Images/8da38c6e3211cb7533bbeca2eb9342fa.png" alt="" data-original-src="https://hackr.io/blog/media/the-break-statement-is-used-to-terminate-any-loop-and-pass-the-program-flow-min.png"/>T2】</strong></p>
<pre class="language-typescript"><code>let products = [

{ name: ‘car’, price: 70000 },

{ name: ‘scooter’, price: 9000 },

{ name: ‘cycle’, price: 1200 }

];

for (var i = 0; i &lt; products.length; i++) {

if (products[i].price == 9000)

break;

}

// show the products

console.log(products[i]);</code></pre>
<h3 id="-14"><strong>打字稿继续</strong></h3>
<h3 id="typescript-continue">此语句有助于控制循环，如for循环、while循环或do循环...while循环。它跳到循环的末尾，继续下一次迭代。</h3>
<p>例如，您可以在For循环中应用continue语句:</p>
<p><strong><img src="../Images/950f60aa305ce76d1e81d86ad9c02165.png" alt="" data-original-src="https://hackr.io/blog/media/this-statement-helps-you-control-loops-such-as-a-for-loop-a-while-loop-or-a-do.png"/>T2】</strong></p>
<pre class="language-typescript"><code>for (let index = 0; index &lt; 10; index++) {




// if index is odd, skip it

if (index % 2)

continue;

// the following code will be skipped for odd numbers

console.log(index);

}</code></pre>
<h2 id="-15"><strong> 3。功能</strong></h2>
<h2 id="toc-3-functions">TypeScript函数是执行特定任务的任何代码块。若要声明函数，请使用关键字“function”</h2>
<p>您还可以在函数的函数参数返回值中使用类型批注。</p>
<pre class="language-typescript"><code>function name(parameter: type, parameter:type,...): returnType {

// do something

}</code></pre>
<p>例如:</p>
<p>在上面的例子中，add()函数将接受两个number类型的参数。</p>
<pre class="language-typescript"><code>function add(a: number, b: number): number {

return a + b;

}</code></pre>
<p>每当您在程序中调用add()函数时，TypeScript编译器都会验证每个参数是否为数字。如果您传递任何其他类型的衣服号码，它会抛出一个错误:</p>
<p><img src="../Images/6ec7117593d0dfd5c56a2a4858e905b5.png" alt="" data-original-src="https://hackr.io/blog/media/a-typescript-function-is-any-block-of-code-that-executes-a-specific-task.png"/></p>
<pre class="language-typescript"><code>let sum = add('10', '20');</code></pre>
<p>返回类型由括号后面的:号表示。在这种情况下，add()函数将返回数字类型的值。编译器将检查每个返回语句，以确保返回值与函数的返回类型(如果存在)兼容。</p>
<p>如果函数返回null，则可以指定void类型。如关键字void所示，该函数不返回值。</p>
<p>例如:</p>
<p>在下面的示例中，TypeScript编译器尝试将add()函数的返回类型推断为number类型，这是所期望的。</p>
<pre class="language-typescript"><code>function echo(message: string): void {

console.log(message.toUpperCase());

}</code></pre>
<p><strong>可选参数</strong></p>
<pre class="language-typescript"><code>function add(a: number, b: number) {

return a + b;

}</code></pre>
<h3 id="optional-parameters">与JavaScript不同，在TypeScript中，编译器将检查每个函数调用，如果实参的数量与函数中列出的参数数量不同，将会产生错误。此外，如果参数的类型和函数参数的类型不兼容，将会返回错误。</h3>
<p>您必须注释可选参数，以指示编译器在您丢失任何参数时不产生错误，因为编译器会仔细检查传递的参数。使用？符号，使函数参数成为可选的。</p>
<p>例如:</p>
<p><img src="../Images/07c1a2165cbb95100847b9337d2bb8aa.png" alt="" data-original-src="https://hackr.io/blog/media/unlike-javascript-in-typescript-every-function-call-will-be-examined-by-the-compiler-min.png"/></p>
<pre class="language-typescript"><code>function multiply(a: number, b: number, c?: number): number {

if (typeof c !== 'undefined') {

return a * b * c;

}

return a * b;

}</code></pre>
<p>你需要使用？在c参数之后。然后，您需要使用表达式typeof c！检查参数是否传递给了函数！== '未定义'。</p>
<p>可选参数列表后面是必需参数列表。</p>
<p>例如，如果您将b参数设为可选，而c参数设为必需，您将得到一个错误:</p>
<p><strong><img src="../Images/7b6b94ec39c9a3f6c9ba64244a01f30c.png" alt="" data-original-src="https://hackr.io/blog/media/the-list-of-required-parameters-follows-the-list-of-the-optional-parameters.png"/>T2】</strong></p>
<pre class="language-typescript"><code>function multiply(a: number, b?: number, c: number): number {

if (typeof c !== 'undefined') {

return a * b * c;

}

return a * b;

}</code></pre>
<h3 id="-16"><strong>默认参数</strong></h3>
<h3 id="default-parameters">自ES2015(或ES6)以来，JavaScript支持默认参数，语法如下:</h3>
<p>调用函数时，如果没有传递任何参数或传递未定义的参数，它将采用默认的初始化值。</p>
<pre class="language-typescript"><code>function name(parameter1=defaultValue1,...) {

// do something

}</code></pre>
<p>例如:</p>
<p><img src="../Images/63949ad9cc3c0f19b47686af4ba0d47a.png" alt="" data-original-src="https://hackr.io/blog/media/javascript-has-supported-the-default-parameters-since-es2015-or-es6-with-the-following-syntax-min.png"/></p>
<pre class="language-typescript"><code>function applyDiscount(price, discount = 0.05) {

return price * (1 - discount);

}

console.log(applyDiscount(230)); </code></pre>
<p>这里，折扣参数是默认参数。如果在调用applyDiscount()函数时没有传递Discount参数，它将使用默认值0.05。</p>
<p>如果在函数类型定义中传递默认参数，将会出现错误。</p>
<p><strong><img src="../Images/e3211c665966cfa802d528aee9336949.png" alt="" data-original-src="https://hackr.io/blog/media/you-will-get-an-error-if-you-pass-the-default-parameters-in-function-type-definitions-min.png"/>T2】</strong></p>
<pre class="language-typescript"><code>let promotion: (price: number, discount: number = 0.05) =&gt; number.</code></pre>
<h3 id="-17"> </h3>
<h3 id="-18"><strong>函数重载</strong></h3>
<h3 id="function-overloading">使用函数重载，可以创建函数的参数类型和结果类型之间的关系。</h3>
<p>例如:</p>
<p>第一个函数返回两个数的和，而后一个函数连接两个字符串。</p>
<pre class="language-typescript"><code>function addNumbers(a: number, b: number): number {

return a + b;

}

function addStrings(a: string, b: string): string {

return a + b;

}</code></pre>
<p>4.班级</p>
<h2 id="toc-4-class"><strong>打字稿类</strong></h2>
<h3 id="typescript-class">构造函数和原型继承允许你创建一个“类”</h3>
<p>例如，我们使用构造函数创建了一个具有三个属性的Person类:</p>
<p>要访问一个人的详细信息，请定义一个原型方法:</p>
<pre class="language-typescript"><code>function Person( firstName, lastName) {

this.firstName = firstName;

this.lastName = lastName;

}</code></pre>
<p>然后，为“person”类创建一个对象并使用它。</p>
<pre class="language-typescript"><code>Person.prototype.getFullName = function () {

return `${this.firstName} ${this.lastName}`;

}</code></pre>
<p>但是，在ES6中，您可以定义一个类来创建构造函数和原型继承:</p>
<pre class="language-typescript"><code>let person = new Person('Jimmy','Dwell');

console.log(person.getFullName());</code></pre>
<p>这里，我们已经在类内部定义了构造函数。现在，让我们向同一个类添加getFullName()方法</p>
<pre class="language-typescript"><code>class Person {

firstName;

lastName;

constructor( firstName, lastName) {

this.firstName = firstName;

this.lastName = lastName;

}

}</code></pre>
<p><img src="../Images/4645573b802950c948e76e6e819d16d8.png" alt="" data-original-src="https://hackr.io/blog/media/a-constructor-function-and-prototype-inheritance-lets-you-create-a-class-1.png"/></p>
<pre class="language-typescript"><code>class Person {

firstName;

lastName;

constructor(firstName, lastName) {

this.firstName = firstName;

this.lastName = lastName;

}

getFullName() {

return `${this.firstName} ${this.lastName}`;

}

}</code></pre>
<p>Person构造函数的功能与“Person”类相同:</p>
<p><img src="../Images/98faff1f04d5b195ba9ea820193d094b.png" alt="" data-original-src="https://hackr.io/blog/media/the-person-constructor-function-functions-the-same-as-the-person-class-min.png"/></p>
<pre class="language-typescript"><code>let person = new Person('Jimmy','Dwell');

console.log(person.getFullName());</code></pre>
<p>下面的代码将类型批注添加到类的属性和方法中:</p>
<p><img src="../Images/dc65ef8ad384d0b220d5affba2a5e07a.png" alt="" data-original-src="https://hackr.io/blog/media/the-following-code-adds-type-annotations-to-the-class-s-properties-and-methods-min.png"/></p>
<pre class="language-typescript"><code>class Person {

firstName: string;

lastName: string;

constructor( firstName: string, lastName: string) {

this.firstName = firstName;

this.lastName = lastName;

}

getFullName(): string {

return `${this.firstName} ${this.lastName}`;

}

}</code></pre>
<p>TypeScript编译器将在对属性、构造函数和方法进行类型注释后执行类型检查。</p>
<p><strong>类型脚本访问修饰符</strong></p>
<h3 id="typescript-access-modifiers">类的属性和方法的可见性是由访问修饰符决定的。私有、受保护和公共是三个类别。在编译期间而不是运行时，访问在逻辑上由TypeScript控制。</h3>
<p><strong>私有修改器</strong></p>
<h4 id="the-private-modifier">当对类中的任何属性或方法使用private修饰符时，可以在同一个类中访问它们，但不能在类外访问它们。</h4>
<p><strong>公共修饰符</strong></p>
<pre class="language-typescript"><code>For example:

class Person {

private firstName: string;

private lastName: string;

// ...

}</code></pre>
<h4 id="the-public-modifier">它是所有方法和属性的默认访问修饰符。它允许您从程序中的任何位置访问类的属性和方法。</h4>
<p>示例:</p>
<p><strong>受保护的修饰符</strong></p>
<pre class="language-typescript"><code>class Person {

// ...

public getFullName(): string {

return `${this.firstName} ${this.lastName}`; 

}

// ...

}</code></pre>
<h4 id="the-protected-modifier">当您将属性和方法定义为protected时，它们只能在同一个类及其子类中访问。如果试图从其他位置访问受保护的属性或方法，将会出现错误。</h4>
<p><strong>打字稿只读</strong></p>
<pre class="language-typescript"><code>class Person {

protected ssn: string;




// other code

}</code></pre>
<h3 id="typescript-readonly">TypeScript支持readonly修饰符，它将类的属性标记为不可变的。您可以在属性声明或同一类的构造函数中声明readonly属性。</h3>
<p>例如:</p>
<p>在这个例子中，我们在Person类构造函数中将birthdate属性初始化为readonly属性。</p>
<pre class="language-typescript"><code>class Person {

readonly birthDate: Date;

constructor(birthDate: Date) {

this.birthDate = birthDate;

}

}</code></pre>
<p>如果重新分配birthDate属性，将会出现错误:</p>
<p><strong><img src="../Images/ab153efbcba1ef67869b1be3082ea497.png" alt="" data-original-src="https://hackr.io/blog/media/typescript-supports-the-readonly-modifier-which-marks-the-properties-of-a-class-immutable-min.png"/>T2】</strong></p>
<pre class="language-typescript"><code>let person = new Person(new Date(1993, 11, 22));

person.birthDate = new Date(1994, 02, 21); </code></pre>
<h3 id="-19"><strong>getter和setter</strong></h3>
<h3 id="getters-and-setters">考虑下面的代码，其中用户输入一个人的年龄。</h3>
<p>在代码中到处应用检查是相当令人畏惧的。这就是getters和setters出现的原因。它们允许您控制对类属性的访问。</p>
<pre class="language-typescript"><code>class Person {

public age: number;

}

person.age = inputAge;

The inputAge can take any valid number. However, we will apply a condition for age:

if( inputAge &gt; 0 &amp;&amp; inputAge &lt; 50 ) {

person.age = inputAge;

}</code></pre>
<p><strong>打字稿继承</strong></p>
<pre class="language-typescript"><code>class Person {

private _age: number;

public get age() {

return this._age;

}

public set age(theAge: number) {

if (theAge &lt;= 0 || theAge &gt;= 50) {

throw new Error('The age is invalid');

}

this._age = theAge;

}

public getFullName(): string {

return `${this._age}`;

}

}</code></pre>
<h3 id="typescript-inheritance">一个类可以通过继承使用其父类的属性。为了做到这一点，子类必须继承父类。术语“子类”是指将继承另一个类的类，而“父类”是指另一个类。</h3>
<p>例如:</p>
<p>如果希望子类继承父类，则需要像任何其他编程语言一样使用extends关键字:</p>
<pre class="language-typescript"><code>class Person {

constructor(private firstName: string, private lastName: string) {

this.firstName = firstName;

this.lastName = lastName;

}

getFullName(): string {

return `${this.firstName} ${this.lastName}`;

}

describe(): string {

return `This is ${this.firstName} ${this.lastName}.`;

}

}</code></pre>
<p><strong>构造器</strong></p>
<pre class="language-typescript"><code>class Employee extends Person {

//..code

}</code></pre>
<h3 id="constructor">在上一节的示例中，您可以看到person类带有一个初始化属性的构造函数，比如firstName和lastName属性。</h3>
<p>之后，在Employee类的构造函数中初始化这些属性。这个类调用person类的构造函数来扩展它。</p>
<p>使用super()访问父类的构造函数。</p>
<p>下面的代码将为employee类创建实例:</p>
<pre class="language-typescript"><code>class Employee extends Person {

constructor(

firstName: string,

lastName: string,

) {




// calling person’s class constructor

super(firstName, lastName);

}

}</code></pre>
<p>使用employee类的实例，您可以访问persons类方法:</p>
<pre class="language-typescript"><code>let employee = new Employee('Jimmy','Dwell');</code></pre>
<p><strong><img src="../Images/17d2fcdb104088856644e8f354bbdb70.png" alt="" data-original-src="https://hackr.io/blog/media/in-the-previous-section-s-example-you-can-see-that-the-person-class-comes-with-a-constructor.png"/>T2】</strong></p>
<pre class="language-typescript"><code>let employee = new Employee('Jimmy', 'Dwell');

console.log(employee.getFullName());

console.log(employee.describe());</code></pre>
<h3 id="-20"><strong>静态属性</strong></h3>
<h3 id="static-properties">静态属性在所有类之间共享，要求您使用Static关键字。此外，如果您想访问静态属性，您必须提到类名或属性名:</h3>
<p>在上面的例子中，我们已经提到人数静态初始化为零。每当创建一个对象，人数就会增加一。</p>
<pre class="language-typescript"><code>class Employee {

static headcount: number = 0;

constructor(

private firstName: string,

private lastName: string,

) {

Employee.headcount++;

}

}</code></pre>
<p>现在，我们将创建两个雇员对象:</p>
<p>输出将是2。</p>
<pre class="language-typescript"><code>let john = new Employee('Jam', 'Dam');

let jane = new Employee('Sam', 'Gam');

console.log(Employee.headcount);</code></pre>
<p><img src="../Images/7f08086ae2f8a447819a32b8d8069ca8.png" alt="" data-original-src="https://hackr.io/blog/media/static-properties-are-shared-among-all-the-classes-requiring-you-to-use-a-static-keyword-min.png"/></p>
<p>静态方法</p>
<h3 id="static-methods">静态方法类似于静态属性，因为它也是跨类实例共享的。要指定一个静态方法，必须在方法名前使用static关键字。</h3>
<p>例如:</p>
<p><strong>抽象类</strong></p>
<pre class="language-typescript"><code>class Employee {

private static headcount: number = 0;

constructor(

private firstName: string,

private lastName: string,

) {

Employee.headcount++;

}

public static getHeadcount() {

return Employee.headcount;

}

}</code></pre>
<h3 id="abstract-class">抽象类定义了派生类要扩展的公共行为。abstract关键字用于声明抽象类。</h3>
<p>更有趣的是，抽象类包含没有实现的方法。扩展抽象类的类包含这些方法的实现。</p>
<pre class="language-typescript"><code>abstract class Employee {

//...

}</code></pre>
<p>以下代码将“Employee”作为抽象类，将“getSum”作为抽象方法:</p>
<p>您不能创建“Employee”类的对象，因为它是一个抽象类。</p>
<pre class="language-typescript"><code>abstract class Employee {

constructor(private firstName: string, private lastName: string) {

}

abstract getSum(): number

get fullName(): string {

return `${this.firstName} ${this.lastName}`;

}

compensationStatement(): string {

return `${this.fullName} makes ${this.getSum()} a month.`;

}

}</code></pre>
<p>您将得到一个错误。</p>
<pre class="language-typescript"><code>let employee = new Employee('Jimmy','Dwell');</code></pre>
<p><img src="../Images/ecc7191a196fff3460743af2a6feddaf.png" alt="" data-original-src="https://hackr.io/blog/media/the-abstract-class-defines-the-common-behaviors-for-derived-classes-to-extend.png"/></p>
<p>Emp类继承了Employee类:</p>
<p><strong> 5。接口</strong></p>
<pre class="language-typescript"><code>class Emp extends Employee {

constructor(firstName: string, lastName: string, private salary: number) {

super(firstName, lastName);

}

getSum(): number {

return this.salary;

}

}

let jim = new FullTimeEmployee('Jim', 'Dim', 3400);

console.log(john.compensationStatement());</code></pre>
<h2 id="toc-5-interfaces"><strong>接口</strong></h2>
<h3 id="interfaces">如果希望在TypeScript代码中定义协定，可以使用接口。它允许您使用显式名称进行类型检查。例如:</h3>
<p><img src="../Images/ae45b1d3849eb5bf5e25db4208f2f350.png" alt="" data-original-src="https://hackr.io/blog/media/if-you-want-to-define-contracts-within-your-typescript-code-you-can-use-the-interfaces.png"/></p>
<pre class="language-typescript"><code>function getFullName(person: {

firstName: string;

lastName: string

}) {

return `${person.firstName} ${person.lastName}`;

}

let person = {

firstName: 'Jam',

lastName: 'Dam'

};

console.log(getFullName(person));</code></pre>
<p>编译器将检查getFullName函数传递的参数。如上所述，传递的参数应该是字符串。</p>
<p>如果它们中的任何一个不匹配，就会导致错误。但是，正如您看到的，由于类型注释，代码变得复杂和难以阅读。因此，我们使用接口来克服这个可读性问题。</p>
<p>我们创建了一个名为“Person”的接口，它有两个属性:</p>
<p>您可以使用上面的接口来定义其他类或方法。</p>
<pre class="language-typescript"><code>interface Person {

firstName: string;

lastName: string;

}</code></pre>
<p><strong>可选属性</strong></p>
<h3 id="optional-properties">通过接口，您还可以拥有可选的属性。问号(？)在声明部分的属性名的末尾:</h3>
<p>在上面的例子中，中间名被声明为可选参数。如果用户不传递此变量的参数，将不会出现编译错误。</p>
<pre class="language-typescript"><code>interface Person {

firstName: string;

middleName?: string;

lastName: string;

}</code></pre>
<p><strong>接口扩展一个接口</strong></p>
<pre class="language-typescript"><code>function getFullName(person: Person) {

if (person.middleName) {

return `${person.firstName} ${person.middleName} ${person.lastName}`;

}

return `${person.firstName} ${person.lastName}`;

}</code></pre>
<h3 id="interfaces-extending-one-interface">对于这个概念，我们使用一个名为person的接口，它包含两个名为male()和female()的方法:</h3>
<p>假设这个接口已经被几个类实现了。也许我们想在“人”的界面上增加一个方法女孩。</p>
<pre class="language-typescript"><code>interface Person {

male(g: string): boolean

female(g: string): boolean

}</code></pre>
<p>但是，它会破坏当前的代码。为了避免这种情况，我们将创建一个新界面，并将其扩展到“Person”界面:</p>
<pre class="language-typescript"><code>girl(g: string): void</code></pre>
<p>我们使用extend关键字将一个接口扩展到另一个接口:</p>
<pre class="language-typescript"><code>interface family extends Person {

girl(g: string): boolean

}</code></pre>
<p><strong> 6。高级类型</strong></p>
<pre class="language-typescript"><code>interface A {

a(): void

}

interface B extends A {

b(): void

}</code></pre>
<h2 id="toc-6-advanced-types"><strong>打字稿交集类型</strong></h2>
<h3 id="typescript-intersection-types">如果要通过组合几个现有类型来创建新类型，可以在TypeScript中使用交集类型。新创建的类型将具有现有类型的功能。要组合这些类型，您需要使用&amp;运算符:</h3>
<p>新的typeAB将同时具有A和b的特性。此外，联合类型(|)确保变量可以具有A或b类型的值。</p>
<pre class="language-typescript"><code>type typeAB = typeA &amp; typeB;</code></pre>
<p>为了解释这个概念，我们使用三个接口:业务伙伴、身份和联系。</p>
<pre class="language-typescript"><code>let varName = typeA | typeB; // union type</code></pre>
<p>下面是两种不同的交叉点类型:</p>
<pre class="language-typescript"><code>interface BusinessPartner {

name: string;

credit: number;

}

interface Identity {

id: number;

name: string;

}

interface Contact {

email: string;

phone: string;

}</code></pre>
<p><strong>类型员工</strong> =身份&amp;联系人；//包含标识和联系类型的属性。例如:</p>
<p><strong>类型客户</strong> =业务伙伴&amp;联系人；//包含业务伙伴和联系人类型的所有属性。例如:</p>
<pre class="language-typescript"><code>let e: Employee = {

id: 10,

name: 'ping pong',

email: 'ping.pong@example.com',

phone: '(408)-897-5684'

};</code></pre>
<p><strong>打字稿型防护罩</strong></p>
<pre class="language-typescript"><code>type Customer = BusinessPartner &amp; Contact;

let c: Customer = {

name: 'ABC Inc.',

credit: 10000,

email:’hello@abcinc.com',

phone: '(408)-897-5735'

};</code></pre>
<h3 id="typescript-type-guard">如果想缩小条件块中变量的类型，可以使用类型保护。</h3>
<p><strong>类型</strong></p>
<h4 id="typeof"><img src="../Images/c6f73cf9f1a742ba506342681ee81f0e.png" alt="" data-original-src="https://hackr.io/blog/media/if-you-want-to-narrow-down-the-types-of-variables-within-a-conditional-block-you-can-use-type-guards.png"/></h4>
<pre class="language-typescript"><code>type alphanumeric = string | number;

function add(a: alphanumeric, b: alphanumeric) {

if (typeof a === 'number' &amp;&amp; typeof b === 'number') {

return a + b;

}

if (typeof a === 'string' &amp;&amp; typeof b === 'string') {

return a.concat(b);

}

throw new Error('Invalid arguments. Both arguments must be either numbers or strings.');

}</code></pre>
<p>上面的函数检查两个参数类型是否都是数字并且都使用了typeof运算符。如果这两个参数使用typeof，它将计算它们的总和。</p>
<p>字符串类型参数也是如此。但是，它将连接两个参数，而不是执行求和。</p>
<p>如果参数既不是数字也不是字符串，您将得到一个错误。</p>
<p><strong> 7。仿制药</strong></p>
<h2 id="toc-7-generics">为了创建可重用和通用形式的函数、类和接口，TypeScript提供了泛型。</h2>
<p>下面是一个从R类型数组返回随机元素的通用函数的示例:</p>
<p>上述函数将使用R类型数组，该数组在调用函数时捕获所提供的类型。此外，该函数的返回类型为getRandomElement()函数作为泛型工作，因为它可以处理任何数据类型。你可以用任何字母代替r。</p>
<pre class="language-typescript"><code>function getRandomElement&lt;R&gt;(items: R[]): R {

let randomIndex = Math.floor(Math.random() * items.length);

return items[randomIndex];

}</code></pre>
<p><strong>调用通用函数</strong></p>
<h3 id="calling-a-generic-function">getRandomElement()也可以处理数组:</h3>
<p>上面的代码将数字作为R类型传递给getRandomElement()函数。</p>
<pre class="language-typescript"><code>let numbers = [1, 5, 7, 4, 2, 9];

let randomEle = getRandomElement&lt;number&gt;(numbers); 

console.log(randomEle);</code></pre>
<p>这里，我们对参数使用类型推断，因此TypeScript编译器可以根据您将传递的参数类型自动设置R的值。</p>
<p>这里，我们没有指定函数的返回类型，这将由编译器通过查看传递的参数来完成。getRandomElement()函数现在也是类型安全的。但是，如果指定字符串变量，将会出现错误。</p>
<pre class="language-typescript"><code>let numbers = [1, 5, 7, 4, 2, 9];

let randomEle = getRandomElement(numbers); 

console.log(randomEle);</code></pre>
<p><strong>类型脚本泛型类</strong></p>
<pre class="language-typescript"><code>let numbers = [1, 5, 7, 4, 2, 9];

let returnElem: string;

returnElem = getRandomElement(numbers);</code></pre>
<h3 id="typescript-generic-classes">泛型类由泛型类型参数列表组成。类名跟在尖括号&lt;&gt;内的参数列表后面。</h3>
<p>一个参数列表中可以有多个泛型类型。</p>
<pre class="language-typescript"><code>class className&lt;T&gt;{

//... 

}</code></pre>
<p>例如:</p>
<p><strong>类型脚本通用接口</strong></p>
<pre class="language-typescript"><code>class className&lt;K,T&gt;{

//...

}</code></pre>
<h3 id="typescript-generic-interface">您还可以创建一个通用接口，就像我们对类所做的那样。泛型接口由泛型类型参数列表组成。接口名称遵循尖括号&lt;&gt;内的参数列表。</h3>
<p>接口的所有成员都可以看到类型参数r，类型参数列表中可以有更多的类型。</p>
<pre class="language-typescript"><code>interface interfaceName&lt;R&gt; {

// ...

}</code></pre>
<p>例如:</p>
<p><strong> 8。类型脚本模块</strong></p>
<pre class="language-typescript"><code>interface interfaceName&lt;U,V&gt; {

// ...

}</code></pre>
<h2 id="toc-8-typescript-modules"><strong>创建模块</strong></h2>
<h3 id="creating-modules">您可以在TypeScript中创建模块。下面我们用声明的接口检查创建Check.ts:</h3>
<p>我们在接口之前使用了export关键字，因此其他模块可以使用这个接口。否则，check接口将是Check.ts模块的私有接口。</p>
<pre class="language-typescript"><code>export interface Check {

isValid(s: string): boolean

}</code></pre>
<p><strong>导出报表</strong></p>
<h3 id="export-statements">要从模块中导出声明，可以使用export语句:</h3>
<p>您还可以重命名模块的声明:</p>
<pre class="language-typescript"><code>interface Check {

isValid(s: string): boolean

}

export { Check };</code></pre>
<p>另一个模块可以使用Check接口作为StringCheck接口。</p>
<pre class="language-typescript"><code>interface Check {

isValid(s: string): boolean

}

export { Check as StringCheck };</code></pre>
<p><strong>导入新模块</strong></p>
<h3 id="importing-a-new-module">在代码中使用import语句来使用新模块。在以下代码中，我们使用Check.ts模块创建了一个新的模块校验和:</h3>
<p>导入模块时，您可以对其进行重命名:</p>
<pre class="language-typescript"><code>import { Check } from './Check';

class CheckSum implements Check {

isValid(s: string): boolean {

const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

return emailRegex.test(s);

}

}

export { CheckSum };</code></pre>
<p>在校验和模块内部，您使用Check接口作为StringCheck接口:</p>
<pre class="language-typescript"><code>import { Check as StringCheck } from './Check';</code></pre>
<p><strong>从模块导入所有内容</strong></p>
<pre class="language-typescript"><code>import { Check as StringCheck } from './Check';

class CheckSum implements StringCheck {

isValid(s: string): boolean {

const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

return emailRegex.test(s);

}

}

export { CheckSum };</code></pre>
<h4 id="importing-everything-from-a-module">要从模块中导入所有内容，可以使用以下语法:</h4>
<p><strong>再出口</strong></p>
<pre class="language-typescript"><code>import * from 'module_name';</code></pre>
<h3 id="re-exports">下面，我们将使用Check.ts模块创建一个名为CheckSal.ts的新模块:</h3>
<p><strong>打字稿反应备忘单</strong></p>
<pre class="language-typescript"><code>import { Check } from './Check';

class CheckSal implements Check {

isValid(s: string): boolean {

const numberRegexp = /^[0-9]+$/;

return s.length === 5 &amp;&amp; numberRegexp.test(s);

}

}

export { CheckSal };</code></pre>
<h2 id="typescript-react-cheatsheet">在这份react打字稿备忘单中，我们将学习react打字稿类型。要导入React，请使用以下命令:</h2>
<p><strong>功能组件</strong></p>
<pre class="language-typescript"><code>import * as React from "react";

import * as ReactDOM from "react-dom";</code></pre>
<h3 id="function-components">您可以将它们用作普通函数，接受props参数并返回JSX元素:</h3>
<p><strong>结论</strong></p>
<pre class="language-typescript"><code>// Declaring type of props

type AppProps = {

message: string;

}; 

// Declare a Function Component; return type is inferred.

const App = ({ message }: AppProps) =&gt; &lt;div&gt;{message}&lt;/div&gt;;

// Annotate the return type 

const App = ({ message }: AppProps): JSX.Element =&gt; &lt;div&gt;{message}&lt;/div&gt;;

// Inline the type declaration

const App = ({ message }: { message: string }) =&gt; &lt;div&gt;{message}&lt;/div&gt;;</code></pre>
<h2 id="conclusion">在这个React TypeScript备忘单中，我们已经用简单的语法和运行VS代码编辑器输出的例子涵盖了每个方面。</h2>
<p>与任何其他面向对象的编程语言一样，TypeScript是一种简单的交互式语言，它允许您使用对象、类、模块、接口、继承等。你可以把这份打字稿备忘单放在手边，为即将到来的面试做准备。</p>
<p>有兴趣用React学习TypeScript吗？</p>
<p><strong> <a class="btn btn-primary btn-call-to-action " href="https://hackr.io/blog/react-interview-questions">查看我们的React面试问题</a> </strong></p>
<p><strong>人也在读:</strong></p>
<p><strong>People are also reading:</strong></p>


									</div>

									</div>    
</body>
</html>