<html>
<head>
<title>Download Regex Cheat Sheet PDF for Quick Reference [Updated]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>下载Regex备忘单PDF以供快速参考[更新]</h1>
<blockquote>原文：<a href="https://hackr.io/blog/regex-cheat-sheet#0001-01-01">https://hackr.io/blog/regex-cheat-sheet#0001-01-01</a></blockquote><div><div class="content">
										<p>Regex代表正则表达式。它是每种编程语言不可或缺的一部分。如果不使用正则表达式，就无法执行复杂的查询。正则表达式，有时也称为有理表达式，是定义文本中搜索模式的字符序列。</p>
<p>许多字符串搜索算法使用正则表达式对字符串进行“查找”和“查找并替换”操作。许多编程语言都有内置的正则表达式功能，而其他语言则通过插件提供。</p>
<p>正则表达式(regex)主要用于Google Analytics的URL匹配。正则表达式的一些其他流行的用例是词法分析、字处理器和文本编辑器的搜索和替换对话框，以及文本处理实用程序。</p>
<p>由于它的极端重要性，许多人渴望<a href="https://hackr.io/tutorials/learn-regular-expressions-regex" target="_blank" rel="noopener">学习正则表达式语法</a>和表达式，以便在面试中出现。作为快速参考，您可以简单地考虑这个<a href="https://drive.google.com/file/d/1mYNyLO2J6GUnemtFYbG0eNs5ireo8jq_/view?usp=sharing" target="_blank" rel="noopener">正则表达式备忘单PDF </a>。</p>

<p>在本正则表达式指南中，您将通过适当的示例了解各种正则表达式符号和正则表达式的工作原理。让我们从Java regex备忘单开始。</p>
<h2 id="regex-cheat-sheet"><strong>正则表达式备忘单</strong></h2>
<h3 id="toc-1-characters-escapes"><strong> 1。字符转义</strong></h3>
<p>下表中的反斜杠字符(\)表示它后面的字符是特殊字符。</p>
<table>
<tbody>
<tr>
<td><strong>转义字符</strong></td>
<td><strong>描述</strong></td>
<td><strong>图案</strong></td>
<td><strong>匹配</strong></td>
</tr>
<tr>
<td>\a</td>
<td>匹配一个钟形字符\u0007。</td>
<td>\a</td>
<td>“错误！”中的“u0004”+ '\u0004 '</td>
</tr>
<tr>
<td>\b</td>
<td>将匹配字符类中的退格键，\u0008。</td>
<td>[\b]{3，}</td>
<td>“\b\b\b\b”中的“\b\b\b\b”</td>
</tr>
<tr>
<td>\t</td>
<td>它将与选项卡u0009匹配。</td>
<td>(\w+)\t</td>
<td>" i1\t "，" i1\ti\t "中的" i2\t "</td>
</tr>
<tr>
<td>\r</td>
<td>它将匹配回车符\u000D。(\r不等同于换行符，\n .)</td>
<td>\r\n(\w+)</td>
<td>\ r \ n这些“in”有两行。</td>
</tr>
<tr>
<td>\v</td>
<td>它将匹配一个垂直制表符\u000B。</td>
<td>[\v]{2，}</td>
<td>“\v\v\v”中的“v\v\v”</td>
</tr>
<tr>
<td>\f</td>
<td>它将匹配一个换页符\u000C。</td>
<td>[\f]{2，}</td>
<td>“\f\f\f”中的“f\f\f”</td>
</tr>
<tr>
<td>\n</td>
<td>它将匹配一个新系列\ u000A。</td>
<td>\r\n(\w+)</td>
<td>\ r \ n这些“in”有两行。</td>
</tr>
<tr>
<td>\e</td>
<td>它将匹配一个转义符\u001B。</td>
<td>\e</td>
<td>“\x001B”中的“x001B”</td>
</tr>
<tr>
<td>\ nnn</td>
<td>它使用八进制表示来指定一个字符(nnn由两个或三个数字组成)。</td>
<td>\w\040\w</td>
<td>“公元前一世纪”中的“公元前一世纪”</td>
</tr>
<tr>
<td>\x nn</td>
<td>它使用十六进制表示来指定一个字符(nn正好由两位数字组成)。</td>
<td>\w\x20\w</td>
<td>“公元前一世纪”中的“公元前一世纪”</td>
</tr>
<tr>
<td>\c X \c x</td>
<td>它将匹配由X或X指定的ASCII控制字符，其中X或X是控制字符的字母。</td>
<td>\抄送</td>
<td>“\x0003”中的“\ x 0003”(Ctrl-C)</td>
</tr>
<tr>
<td>\u nnnn</td>
<td>它将匹配一个使用十六进制表示的Unicode字符(正好是四位数字，用nnnn表示)。</td>
<td>\w\u0020\w</td>
<td>“公元前一世纪”中的“公元前一世纪”</td>
</tr>
</tbody>
</table>
<h3 id="toc-2-character-classes"><strong> 2。字符分类</strong></h3>
<p>一个字符类将匹配一组字符中的任何一个。字符类包括下表中列出的语言元素。</p>
<table>
<tbody>
<tr>
<td><strong>人物类</strong></td>
<td><strong>描述</strong></td>
<td><strong>图案</strong></td>
<td><strong>匹配</strong></td>
</tr>
<tr>
<td>[字符组]</td>
<td>它将匹配character_group中的任何单个字符。默认情况下，匹配区分大小写。</td>
<td>[ae]</td>
<td>“湾”中的“a”“a”“桩子”中的“e”</td>
</tr>
<tr>
<td>[^人物_组]</td>
<td>否定:它将匹配character_group中不存在的任何单个字符。默认情况下，character_group中的字符区分大小写。</td>
<td>[^aei]</td>
<td>“统治”中的“r”、“g”、“n”</td>
</tr>
<tr>
<td>[名字-姓氏]</td>
<td>字符范围:它将匹配从第一个到最后一个范围内的任何单个字符。</td>
<td>[A-Z]</td>
<td>“AB123”中的“A”、“B”</td>
</tr>
<tr>
<td>。</td>
<td>通配符:它将匹配除\n .以外的任何单个字符。或\u002E)，您必须在它前面加上转义符(\。).</td>
<td>阿拉伯语</td>
<td>“ave”中的“have”在“hater”中的“eat”</td>
</tr>
<tr>
<td>\p{ name }</td>
<td>它将匹配由name指定的Unicode常规类别或命名块中的任何单个字符。</td>
<td>\p{Lu} \p{IsCyrillic}</td>
<td>《城市之光》中的“c”，“l”，“д”，“джem”中的“ж”</td>
</tr>
<tr>
<td>\P{ name }</td>
<td>它将匹配Unicode常规类别或name指定的命名块中不存在的任何单个字符。</td>
<td>\P{Lu} \P{IsCyrillic}</td>
<td>“城市”中的“我”，“t”，“y”，“джem”中的“e”，“m”</td>
</tr>
<tr>
<td>\w</td>
<td>它将匹配任何单词字符。</td>
<td>\w</td>
<td>“ID A1.3”中的“我”、“D”、“A”、“1”、“3”</td>
</tr>
<tr>
<td>\W</td>
<td>它将匹配任何非单词字符。</td>
<td>\W</td>
<td>" ", "."在“ID A1.3”中</td>
</tr>
<tr>
<td>\s</td>
<td>它将匹配任何空白字符。</td>
<td>\w\s</td>
<td>“ID A1.3”中的“D”</td>
</tr>
<tr>
<td>\S</td>
<td>它将匹配任何非空白字符。</td>
<td>\s\S</td>
<td>“int __ctr”中的“_”</td>
</tr>
<tr>
<td>\d</td>
<td>它将匹配任何十进制数字。</td>
<td>\d</td>
<td>“4 = IV”中的“4”</td>
</tr>
<tr>
<td>\D</td>
<td>它将匹配除十进制数字以外的任何字符。</td>
<td>\D</td>
<td>" "，" = "，" "，" 4 = IV "中的"我"，" V "</td>
</tr>
</tbody>
</table>
<h3 id="toc-3-character-class-operations"><strong> 3。字符类操作</strong></h3>
<table>
<tbody>
<tr>
<td>类操作</td>
<td>神话；传奇</td>
<td>例子</td>
<td>样本匹配</td>
</tr>
<tr>
<td>[…-[…]]</td>
<td>。NET:是字符类减法。左侧一个字符，但不在减法类中。</td>
<td>【阿-z-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿-阿</td>
<td>任何小写辅音</td>
</tr>
<tr>
<td>[…-[…]]</td>
<td>。NET:是字符类减法。</td>
<td>[\p{IsArabic}-[\D]]</td>
<td>阿拉伯字符而不是非数字，即阿拉伯数字</td>
</tr>
<tr>
<td>[…&amp;&amp;[…]]</td>
<td>Java，Ruby 2+:是字符类交集。&amp;类中左侧的一个字符。</td>
<td>[\S&amp;&amp;[\D]]</td>
<td>一个非空白字符和一个非数字。</td>
</tr>
<tr>
<td>[…&amp;&amp;[…]]</td>
<td>Java，Ruby 2+:字符类交集。</td>
<td>[\ s &amp;[\ d]&amp;[^ a-za-z]]</td>
<td>一个非数字而非字母的非空白字符。</td>
</tr>
<tr>
<td>[…&amp;&amp;[^…]]</td>
<td>Java，Ruby 2+:它是一个字符类减法是通过将一个类与一个被求反的类相交得到的</td>
<td>[a-z【^ aeiou】</td>
<td>不是元音的英文小写字母。</td>
</tr>
<tr>
<td>[…&amp;&amp;[^…]]</td>
<td>Java，Ruby 2+:是字符类减法</td>
<td>[\p{InArabic}&amp;&amp;[^\p{L}\p{N}]]</td>
<td>阿拉伯字符，而不是字母或数字</td>
</tr>
</tbody>
</table>
<h3 id="toc-4-anchors"><strong> 4。锚</strong></h3>
<p>锚也被称为<a href="https://subscription.packtpub.com/book/application-development/9781787288706/6/ch06lvl1sec24/zero-width-assertions#:~:text=Zero%2Dwidth%20or%20zero%2Dlength,pointer%20in%20the%20input%20string." target="_blank" rel="noopener">原子零宽度断言</a>。它根据字符串中的当前位置决定匹配是成功还是失败。但是这些锚不能用于允许引擎通过字符串或字符前进。下表中列出的元字符是定位点。</p>
<table>
<tbody>
<tr>
<td><strong>断言</strong></td>
<td><strong>描述</strong></td>
<td><strong>图案</strong></td>
<td><strong>匹配</strong></td>
</tr>
<tr>
<td>^</td>
<td>默认情况下，匹配从字符串的开头开始。此外，对于多线模式，它也将从线的开始处开始。</td>
<td>^\d{3}</td>
<td>“111-333”中的“111”</td>
</tr>
<tr>
<td>$</td>
<td>默认情况下，匹配将发生在字符串的末尾或字符串末尾之前。在多行模式的情况下，它将发生在行尾之前或\n在行尾之前。</td>
<td>-\d{3}$</td>
<td>"-901-444 "中的"-444 "</td>
</tr>
<tr>
<td>\A</td>
<td>匹配出现在字符串的开头。</td>
<td>\A\d{3}</td>
<td>“222”中的“222-333——”</td>
</tr>
<tr>
<td>\Z</td>
<td>匹配出现在字符串末尾或字符串末尾之前。</td>
<td>-\d{3}\Z</td>
<td>"-555-111 "中的"-111 "</td>
</tr>
<tr>
<td>\z</td>
<td>匹配出现在字符串的末尾。</td>
<td>-\d{3}\z</td>
<td>"-901-111 "中的"-111 "</td>
</tr>
<tr>
<td>\G</td>
<td>匹配发生在前一个匹配结束的点上。</td>
<td>\G\(\d\)</td>
<td>“(1)”中的“(3)”，“5”中的“(1)(3)(5)(7)(9)”</td>
</tr>
<tr>
<td>\b</td>
<td>匹配出现在\w(字母数字)和\W(非字母数字)字符的边界上。</td>
<td>\b\w+\s\w+\b</td>
<td>“他们主题”，“他们他们”在“他们主题他们他们”</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不会出现在\b边界上。</td>
<td>\弯曲\w*\b</td>
<td>“ends”，“ender”在“end sends忍让者”中</td>
</tr>
</tbody>
</table>
<p><a class="btn btn-primary btn-call-to-action " href="https://click.linksynergy.com/deeplink?id=jU79Zysihs4&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fregular-expressions-mastery%2F" target="_blank" rel="noopener">面向初学者的完整正则表达式(Regex)课程</a></p>
<h3 id="toc-5-grouping-constructs"><strong> 5。分组结构</strong></h3>
<p>分组构造描述正则表达式的子表达式，并捕获所提供字符串的子字符串。分组构造使用以下语言元素。</p>

<table>
<tbody>
<tr>
<td><strong>分组构造</strong></td>
<td><strong>描述</strong></td>
<td><strong>图案</strong></td>
<td><strong>匹配</strong></td>
</tr>
<tr>
<td>(子表达式)</td>
<td>它将捕获匹配的子表达式，并给它分配一个从1开始的序号。</td>
<td>(\w)\1</td>
<td>“hello”中的“ll”</td>
</tr>
<tr>
<td>(?&lt; name &gt;子表达式)或(？名称'子表达式)</td>
<td>它会将匹配的子表达式捕获到一个命名组中。</td>
<td>(?<double> \w)\k <double/></double></td>
<td>“你好”中的“ll”</td>
</tr>
<tr>
<td>(?&lt; name1 - name2 &gt;子表达式)或(？“名称1 -名称2”子表达式)</td>
<td>它将定义一个平衡组定义。</td>
<td>(((?'Open'\()[^\(\)]*)+((？'Close-Open'\))[^\(\)]*)+)*(？(打开)(？！))$</td>
<td>“3+2^((1-3)*(3-1”中的“((1-3)*(3-1))”</td>
</tr>
<tr>
<td>(?:子表达式)</td>
<td>它将定义一个非捕获组。</td>
<td>写(？:行)？</td>
<td>“控制台”中的“WriteLine”。WriteLine()“控制台”中的“写入”。写(值)”</td>
</tr>
<tr>
<td>(？imsx-imsx:子表达式)</td>
<td>它将应用或禁用子表达式中的指定选项。</td>
<td>A\d{2}(？i:\w+)\b</td>
<td>“A12XL”、“A12xl”中的“A12xl”</td>
</tr>
<tr>
<td>(?=子表达式)</td>
<td>零宽度正向前瞻断言。</td>
<td>\b\w+\b(？=.+和。+)</td>
<td>“老鼠”、“蝙蝠”中的“老鼠、蝙蝠和一些老鼠”</td>
</tr>
<tr>
<td>(?！子表达式)</td>
<td>零宽度负前瞻断言。</td>
<td>\b\w+\b(？！。+和。+)</td>
<td>“老鼠、蝙蝠和一些老鼠”中的“和”、“一些”、“老鼠”</td>
</tr>
<tr>
<td>(?&lt; =子表达式)</td>
<td>零宽度正后视断言。</td>
<td>\b\w+\b(？&lt;=.+和。+)——————————\ b \ w+\ b(？&lt;=.+和。*)</td>
<td>“一些”，“老鼠”，“老鼠，蝙蝠和一些老鼠。”————————————“老鼠、蝙蝠和一些老鼠”中的“和”、“一些”、“老鼠”</td>
</tr>
<tr>
<td>(?</td>
<td>零宽度负后视断言。</td>
<td>\b\w+\b(？</td>
<td>“老鼠”、“蝙蝠”和“老鼠、蝙蝠和一些老鼠”中的“老鼠”————————————“老鼠、蝙蝠和一些老鼠”中的“老鼠”、“蝙蝠”</td>
</tr>
<tr>
<td>(?&gt;子表达式)</td>
<td>原子团。</td>
<td>(?&gt; a|ab)c</td>
<td>“ac”中的“ac”在“abc”中没有</td>
</tr>
</tbody>
</table>
<h3 id="toc-6-lookarounds"><strong> 6。环顾四周</strong></h3>
<p>当regex引擎开始处理lookaround表达式时，它从当前位置到原始字符串的开始(lookbehind)或结束(lookahead)位置获取一个子字符串，然后运行Regex。在lookaround模式帮助下，匹配选定的子字符串。您可以根据肯定或否定的断言来确定结果是否成功。</p>
<table>
<tbody>
<tr>
<td><strong>环顾四周</strong></td>
<td><strong>名称</strong></td>
<td><strong>例子</strong></td>
<td><strong>样本匹配</strong></td>
</tr>
<tr>
<td>(?=检查)</td>
<td>积极前瞻</td>
<td>(?=\d{10})\d{5}</td>
<td>06678在0667856789</td>
</tr>
<tr>
<td>(?&lt; =检查)</td>
<td>积极回顾</td>
<td>(?&lt; =\d)rat</td>
<td>一垒打</td>
</tr>
<tr>
<td>(?！检查)</td>
<td>消极前瞻</td>
<td>(?！剧院)的\w+</td>
<td>主题</td>
</tr>
<tr>
<td>(?</td>
<td>消极回顾</td>
<td>\w{3}(？</td>
<td>蒙斯特</td>
</tr>
</tbody>
</table>
<h3 id="toc-7-quanitfiers">7 .<strong>。量化器</strong></h3>
<p>量词将简单地指定输入字符串中必须有多少个前一个元素的实例才能产生完全匹配。量词包括以下语言元素。</p>
<table>
<tbody>
<tr>
<td><strong>量词</strong></td>
<td><strong>描述</strong></td>
<td><strong>图案</strong></td>
<td><strong>匹配</strong></td>
</tr>
<tr>
<td>*</td>
<td>它将零次或多次匹配前一个元素。</td>
<td>\d*\。\d</td>
<td>".0", "19.9", "219.9"</td>
</tr>
<tr>
<td>+</td>
<td>它将一次或多次匹配前一个元素。</td>
<td>" se+"</td>
<td>“见过”中的“见”，“送过”中的“se”</td>
</tr>
<tr>
<td>?</td>
<td>它将零次或一次匹配前一个元素。</td>
<td>“阿婆？n "</td>
<td>“人”，“主”</td>
</tr>
<tr>
<td>{ n }</td>
<td>它将与前一个元素精确匹配n次。</td>
<td>，\d{3}</td>
<td>“1043.6”中的“、043”，“9876543210”中的“、876”、“543”、“210”</td>
</tr>
<tr>
<td>{ n，}</td>
<td>它将匹配前一个元素至少n次。</td>
<td>\d{2，}。</td>
<td>"166", "29", "1930"</td>
</tr>
<tr>
<td>{ n，m }</td>
<td>它将匹配前一个元素至少n次，但不超过m次。</td>
<td>\d{3，5}</td>
<td>“166”、“17668”、“19302”中的“193024”</td>
</tr>
<tr>
<td>*?</td>
<td>它将匹配前一个元素零次或多次，但次数越少越好。</td>
<td>\d*？\.\d</td>
<td>".0", "19.9", "219.9"</td>
</tr>
<tr>
<td>+?</td>
<td>它将匹配前一个元素一次或多次，但次数越少越好。</td>
<td>“se+？”</td>
<td>“见过”中的“se”，“送过”中的“se”</td>
</tr>
<tr>
<td>??</td>
<td>它将匹配前一个元素零次或一次，但次数越少越好。</td>
<td>“阿婆？？n "</td>
<td>“人”，“主”</td>
</tr>
<tr>
<td>{ n }？</td>
<td>它将与前面的元素精确匹配n次。</td>
<td>"，\d{3}？</td>
<td>“1043.6”中的“、043”，“9876543210”中的“、876”、“543”、“210”</td>
</tr>
<tr>
<td>{ n，}？</td>
<td>它将匹配前一个元素至少n次，但次数越少越好。</td>
<td>\d{2，}？</td>
<td>"166", "29", "1930"</td>
</tr>
<tr>
<td>{ n，m }？</td>
<td>它将匹配前一个元素n到m次，但次数越少越好。</td>
<td>\d{3，5}？</td>
<td>“166”、“17668”、“193”、“024”中的“193024”</td>
</tr>
</tbody>
</table>
<h3 id="toc-8-backreference-constructs"><strong> 8。反向引用结构</strong></h3>
<p>通过反向引用，您可以简单地在同一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">正则表达式</a>中识别后续的子表达式。下表突出显示了反向引用构造:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>反向引用结构</strong></p>
</td>
<td>
<p><strong>描述</strong></p>
</td>
<td>
<p><strong>图案</strong></p>
</td>
<td>
<p><strong>匹配</strong></p>
</td>
</tr>
<tr>
<td>
<p>\数字</p>
</td>
<td>
<p>反向引用。它将匹配编号子表达式的值。</p>
</td>
<td>
<p>(\w)\1</p>
</td>
<td>
<p>“peek”中的“ee”</p>
</td>
</tr>
<tr>
<td>
<p>\k &lt; name &gt;</p>
</td>
<td>
<p>命名反向引用。它将匹配命名表达式的值。</p>
</td>
<td>
<p>(?<char> \w)\k <char/></char></p>
</td>
<td>
<p>“peek”中的“ee”</p>
</td>
</tr>
</tbody>
</table>
<h3 id="toc-9-alteration-constructs"><strong> 9。变更构造</strong></h3>
<p>交替构造将改变正则表达式，以实现“非此即彼”的匹配。这些构造带有下表中列出的语言元素。</p>
<table>
<tbody>
<tr>
<td><strong>交替构造</strong></td>
<td><strong>描述</strong></td>
<td><strong>图案</strong></td>
<td><strong>匹配</strong></td>
</tr>
<tr>
<td>|</td>
<td>它将匹配由竖线(|)字符分隔的任何一个元素。</td>
<td>th(e|is|at)</td>
<td>“就是这一天”中的“这个”</td>
</tr>
<tr>
<td>(?(表情)是|不是)还是(？(表情)是)</td>
<td>如果表达式指定的正则表达式模式匹配，它将匹配“是”；否则，它将匹配可选的“否”部分。提供的表达式被解释为零宽度断言。为了避免命名或编号捕获组的模糊性，必须使用可选的显式断言，例如(？( (?=表达式) )是|否)</td>
<td>(?A\d{2}\b|\b\d{3}\b)</td>
<td>“A10”、“A10 C103 910”中的“910”</td>
</tr>
<tr>
<td>(?(姓名)是|否)还是(？(姓名)是)</td>
<td>如果name(一个已命名或编号的捕获组)有匹配项，它将匹配“yes ”;否则，它将匹配可选的否</td>
<td>(?<quoted>)？(?(引用)。+?"|\S+\s)</quoted></td>
<td>" Dogs.jpg "，" Dogs.jpg \"Yiska playing.jpg\ " "中的\ " \ " Yiska playing . jpg \ " "</td>
</tr>
</tbody>
</table>
<h3 id="toc-10-substitutions">10。替换</h3>
<p>替换是在替换模式中使用的正则表达式语言元素。下表列出了作为原子零宽度断言的元字符。</p>
<table>
<tbody>
<tr>
<td><strong>字符</strong></td>
<td><strong>描述</strong></td>
<td><strong>图案</strong></td>
<td><strong>替换模式</strong></td>
<td><strong>输入字符串</strong></td>
<td><strong>结果字符串</strong></td>
</tr>
<tr>
<td>$ number</td>
<td>它将替换由组号匹配的子串。</td>
<td>\b(\w+)(\s)(\w+)\b</td>
<td>$3$2$1</td>
<td>“一二”</td>
<td>“二一”</td>
</tr>
<tr>
<td>${ name }</td>
<td>它将替换与命名组名匹配的子字符串。</td>
<td>\b(？<word1> \w+)(\s)(？<word2> \w+)\b</word2></word1></td>
<td>${word2} ${word1}</td>
<td>“一二”</td>
<td>“二一”</td>
</tr>
<tr>
<td>$$</td>
<td>它将替换文字“$”。</td>
<td>\b(\d+)\s？美元</td>
<td>$$$1</td>
<td>" 44美元"</td>
<td>"$44"</td>
</tr>
<tr>
<td>$&amp;</td>
<td>它将替代整个比赛的副本。</td>
<td>\$?\d*\。？\d+</td>
<td>**$&amp;**</td>
<td>"$1.30"</td>
<td>"**$1.30**"</td>
</tr>
<tr>
<td>$`</td>
<td>它将在匹配之前替换输入字符串的所有文本。</td>
<td>B+</td>
<td>$`</td>
<td>"DDBBCC"</td>
<td>"DDDDCC"</td>
</tr>
<tr>
<td>$'</td>
<td>它将在匹配后替换输入字符串的所有文本。</td>
<td>B+</td>
<td>$'</td>
<td>" AADDCC "</td>
<td>" AACCCC "</td>
</tr>
<tr>
<td>$+</td>
<td>它将替换最后捕获的组。</td>
<td>B+(C+)</td>
<td>$+</td>
<td>" AABBCCDD "</td>
<td>"亚加共体"</td>
</tr>
<tr>
<td>$ u</td>
<td>它将替换整个输入字符串。</td>
<td>B+</td>
<td>$ u</td>
<td>" AABBCC "</td>
<td>"啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊"</td>
</tr>
</tbody>
</table>
<h3 id="toc-11-inline-options"><strong> 11。内嵌选项</strong></h3>
<p>以下是支持的内联选项。Net正则表达式引擎:</p>
<table>
<tbody>
<tr>
<td><strong>选项</strong></td>
<td><strong>描述</strong></td>
<td><strong>图案</strong></td>
<td><strong>匹配</strong></td>
</tr>
<tr>
<td>我</td>
<td>它用于不区分大小写的匹配。</td>
<td>\b(？我)一(？-i)a\w+\b</td>
<td>《食蚁兽》《食蚁兽AAAuto aaaAuto亚当早餐》中的“aaaaauto”</td>
</tr>
<tr>
<td>m</td>
<td>在多线模式的情况下。^和$匹配一行的开始和结束，而不是一个字符串的开始和结束。</td>
</tr>
<tr>
<td>n</td>
<td>它不会捕获未命名的组。</td>
</tr>
<tr>
<td>s</td>
<td>它将使用单行模式。</td>
</tr>
<tr>
<td>x</td>
<td>它将忽略正则表达式模式中未转义的空白。</td>
<td>\b(？x) \d+ \s \w+</td>
<td>“1只土豚”、“2只猫”中的“1只土豚2只猫IV百夫长”</td>
</tr>
</tbody>
</table>
<h3 id="toc-12-posix-character-classes"><strong> 12。POSIX字符类</strong></h3>
<p>字符类将一个小的字符序列与一个大的字符集相匹配。我们只能在括号表达式中使用POSIX字符类。POSIX标准支持以下字符类别来创建正则表达式。</p>
<table>
<tbody>
<tr>
<td><strong>字符</strong></td>
<td><strong>图例</strong></td>
<td><strong>例子</strong></td>
<td><strong>样本匹配</strong></td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>PCRE (C，PHP，R…): ASCII字母a-z和A-Z</td>
<td>[8[:alpha:]]+</td>
<td>熟女88</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>Ruby 2: Unicode字母或表意文字</td>
<td>[:阿尔法:]\d]+</td>
<td>猫99</td>
</tr>
<tr>
<td>[:阿卢姆:]</td>
<td>PCRE (C，PHP，R…): ASCII数字和字母a-z和A-Z</td>
<td>[[:alnum:]]{10}</td>
<td>ABC1235251</td>
</tr>
<tr>
<td>[:alnum:]</td>
<td>Ruby 2: Unicode数字、字母或表意文字</td>
<td>[:阿勒纳姆:]{10}</td>
<td>猫90210</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>PCRE (C，PHP，R…): ASCII标点符号</td>
<td>[[:punct:]]+</td>
<td>?!.,:;</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>拼音:Unicode标点符号</td>
<td>[[:punct:]]+</td>
<td>‽,:〽⁆</td>
</tr>
</tbody>
</table>
<h3 id="toc-13-inline-modifiers">13。内嵌修饰符</h3>
<p>在<a href="https://hackr.io/blog/what-is-javascript"> JavaScript </a>中不支持以下修饰符。如果您使用的是Ruby，请确保小心使用“？s“和”？m”。</p>
<table>
<tbody>
<tr>
<td>修改</td>
<td><strong>图例</strong></td>
<td><strong>例子</strong></td>
<td><strong>样本匹配</strong></td>
</tr>
<tr>
<td>(?我)</td>
<td>不区分大小写模式(JavaScript除外)</td>
<td>(?一)星期一</td>
<td>星期一</td>
</tr>
<tr>
<td>(?s)</td>
<td>DOTALL模式(JS和Ruby除外)。圆点(。)将匹配新行字符(\r\n)。您也可以称之为“单行模式”，因为点将整个输入视为一行</td>
<td>(?s)从A. *到Z</td>
<td>彻底地</td>
</tr>
<tr>
<td>(?m)</td>
<td>多行模式(除了Ruby和JS) ^和$匹配在每一行的开头和结尾</td>
<td>(?m)1\r\n^2$\r\n^3$</td>
<td>1 2 3</td>
</tr>
<tr>
<td>(?m)</td>
<td>在Ruby中:它与(？s)在其他引擎中，即DOTALL模式，即点匹配换行符</td>
<td>(?m)从A. *到Z</td>
<td>彻底地</td>
</tr>
<tr>
<td>(?x)</td>
<td>自由间距模式(JavaScript除外)。你也可以称之为注释模式或空白模式</td>
<td>(?x) #这是一个#注释abc #写在多个#行[ ]d #空格必须用#括起来</td>
<td>abc d</td>
</tr>
<tr>
<td>(?n)</td>
<td>。NET，PCRE 10.30+:仅命名捕获</td>
<td>将所有(括号)变为非捕获组。若要捕获，请使用命名组。</td>
</tr>
<tr>
<td>(?d)</td>
<td><a href="https://hackr.io/blog/what-is-java"> Java </a>:仅Unix换行符</td>
<td>圆点、^和$锚点仅受\n</td>
</tr>
<tr>
<td>(?^)</td>
<td>PCRE 10.32+:未设置修改量</td>
<td>取消设置ismnx修改器</td>
</tr>
</tbody>
</table>
<h2 id="conclusion"><strong>结论</strong></h2>
<p>作为一个初学者，这个正则表达式备忘单可能很难理解。由于各种各样的字符和符号，可能很难在正确的地方记住所有这些表达。掌握正则表达式需要大量的练习。</p>
<p>好吧，如果你被困在某个地方，你可以简单地参考这个正则表达式备忘单。我们已经讨论了几乎所有使用正则表达式的表达式、字符和符号。我们希望这个备忘单能帮助你理解关于regex的一切。</p>
<h2 id="frequently-asked-questions"><strong>常见问题解答</strong></h2>
<h4 id="toc-1-what-are-regex-commands"><strong> 1。什么是正则表达式命令？</strong></h4>
<p>Regex命令根据给定的正则表达式过滤数据。</p>
<pre>regex &lt;field&gt; [=|!= &lt;regular expression&gt;] | [IN | NOT IN (&lt;regular expression&gt; [(,&lt;regular expression&gt;)*])]</pre>
<h4 id="toc-2-what-does-mean-in-regex"><strong> 2。在regex中*$是什么意思？</strong></h4>
<p>正则表达式没有类似“*$”的内容。这是一个无效字符。“*”是一个正则表达式运算符，表示它前面的字符或子表达式出现了零次或多次。当“$”匹配被匹配字符串的末尾时，假设正则表达式中它前面的内容可以匹配字符串中前面的字符。</p>
<p><strong>例如:</strong></p>
<pre>a*</pre>
<p>它将匹配字符a出现零次或多次的任何序列。</p>
<pre>a*$</pre>
<p>它将在匹配的字符串末尾匹配零个或多个出现的。</p>
<h4 id="toc-3-is-regex-the-same-in-all-languages"><strong> 3。所有语言的regex都一样吗？</strong></h4>
<p>所有编程语言的正则表达式语法可能略有不同，但大多数细节是相同的。一些regex实现在处理和某些特殊字符序列的含义上略有不同。</p>
<h4 id="toc-4-what-is-a-question-mark-in-regex"><strong> 4。正则表达式中的问号是什么？</strong></h4>
<p>一个问号(？)regex指定前面的元素出现零次或一次。</p>
<p><strong>比如:</strong> <br/> abc？d表示匹配ab后跟c(可选)带强制d. <br/> ab(cde)？f表示匹配ab后跟cde(可选),带有强制f。</p>
<p><strong>人也在读:</strong></p>


									</div>

									</div>    
</body>
</html>