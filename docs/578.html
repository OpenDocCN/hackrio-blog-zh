<html>
<head>
<title>Top Java 8 Features (With Examples) You Need to Know [2023]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>你需要知道的Java 8的主要特性(附例子)[2023]</h1>
<blockquote>原文：<a href="https://hackr.io/blog/java-8-features#0001-01-01">https://hackr.io/blog/java-8-features#0001-01-01</a></blockquote><div><div class="content">
										<p>Java 8是较老的Java版本，发布于2014年3月。但是许多程序员认为Java 8是使用最广泛的Java版本之一。事实上，它非常受欢迎，Oracle将其支持延长至2030年。另外，组织继续发布Java 8课程和T2书籍。</p>
<p>Java 8受欢迎有几个原因。首先，它是在与新版本略有不同的许可下发布的。此外，它还有许多新的有用的功能。探索它们的最佳方式是用<a href="https://hackr.io/blog/java-projects"> Java项目</a>进行实践。但是如果您想快速浏览Java 8的主要特性，我们可以满足您的需求。</p>
<p>今天，我们将介绍一些最重要的Java 8特性，以及它们为什么重要。</p>
<h2 id="what-s-changed-in-java-8">Java 8有什么变化？</h2>
<p><strong><img src="../Images/8646d098712fa1bfad8fb75884e3f081.png" alt="" data-original-src="https://hackr.io/blog/media/what-s-changed-in-java-8-min.png"/>T2】</strong></p>

<p>Java 8最有趣的特性是对语言本身的补充，例如:</p>
<ul>
<li>Lambdas和功能接口</li>
<li>改进的类型推理</li>
<li>forEach()方法是可迭代的接口</li>
<li>方法引用</li>
<li>重复注释</li>
</ul>
<p>Java的库也经历了一些新的增加，包括:</p>
<ul>
<li>Base64</li>
<li>日期/时间API</li>
<li>流</li>
<li>并发</li>
</ul>
<p>另一个有用的Java 8特性是jdeps类依赖分析器，它使得处理大型特性更加容易。</p>
<h2 id="key-new-java-8-features-with-examples">【Java 8的主要新特性及示例</h2>
<p>我们可以写一本关于Java 8新特性的书。但是在这里，我们将重点介绍一些我们最喜欢的，以及一些Java 8编程示例，向您展示它们是如何工作的。</p>
<p>已经熟悉Java编程的开发人员应该会发现在他们的代码中使用这些概念和特性很容易。</p>
<h3 id="lambda-expressions"><strong>λ表达式</strong></h3>
<p>Lambda表达式是一个代码块，可以接受一个参数并返回值。它们执行类似于方法的功能，但是它们不需要名字。此外，您可以在现有方法的主体中使用它们。Lambda表达式有助于使代码更短、更易读。</p>

<p>lambda表达式可以采用以下形式的单个参数:</p>
<pre class="language-java"><code>parameter -&gt; expression</code></pre>
<p>或者，在括号中有多个参数:</p>
<pre class="language-java"><code>(first_parameter, second_parameter) -&gt; expression</code></pre>
<p>Lambda表达式可以减少相对简单的流程所需的代码量。但是，表达式必须立即返回值。它不能与变量、<strong> if </strong>语句或赋值一起使用。但是，您可以使用代码块来代替表达式:</p>
<pre class="language-java"><code>(first_parameter, second_parameter) -&gt; { code to execute; }</code></pre>
<p>如果代码块必须返回一些东西，那么你必须使用<strong> return </strong>命令:</p>
<p>下面是一个lambda表达式的示例:</p>
<pre class="language-java"><code>import java.util.Collections;
import java.util.List;
import java.util.ArrayList;
import java.util.Comparator;
public class Java8Example {
public static void main(String args[]) {
List&lt;String&gt; shoppingList = new ArrayList&lt;String&gt;();
shoppingList.add("Onions");
shoppingList.add("Bread");
shoppingList.add("Flour");
shoppingList.add("Sugar");
shoppingList.add("Chicken");
Java8Example example = new Java8Example();
example.sortUsingLambda(shoppingList);
System.out.println(shoppingList);
}
private void sortUsingLambda(List&lt;String&gt; shoppingList) {
Collections.sort(shoppingList, (s1, s2) -&gt; s1.compareTo(s2));
}
}</code></pre>
<h3 id="improved-type-inference"><strong>改良型推理</strong></h3>
<p>类型推断是Java编译器推断在调用泛型方法后发送的任何参数的类型的方式。如果未指定数据类型，编译器将使用上下文信息来推断该类型应该是什么。</p>
<p>类型推断对于Java 8来说并不是一个新概念。这项功能的有限版本已经推出一段时间了。不过是针对Java 8的<em>改进了</em>。</p>
<p>类型推断非常有用，因为它保持了Java代码的整洁和可读性。在Java的早期版本中，没有类型推断，这意味着必须指定数据类型。</p>
<p>例如:</p>
<pre class="language-java"><code>List&lt;Integer&gt; ageInYears = new ArrayList&lt;Integer&gt;();</code></pre>
<p>Java 7引入了类型推断，这意味着同一个列表可以使用:</p>
<pre class="language-java"><code>ageInYears = new ArrayList&lt;&gt;();</code></pre>
<p>当我们在列表中添加年龄时，编译器会自动推断年龄是一个整数，而不是一个字符串。</p>
<pre class="language-java"><code>ageInYears.add(30);</code></pre>
<p>这在Java 8中得到了进一步扩展，允许我们调用泛型方法，而不必指定类型:</p>
<pre class="language-java"><code>import java.util.ArrayList;
import java.util.List;
public class TypeInferExample {
public static void main(String[] args) {
addAges(new ArrayList&lt;&gt;(), 12, 12);
}
static void addAges(List&lt;Integer&gt; ageInYears, int firstAge, int secondAge) {
ageInYears.add(firstAge);
ageInYears.add(secondAge);
System.out.println(ageInYears);
}
}</code></pre>
<h3 id="the-foreach-method"><strong>forEach()方法</strong></h3>
<p>Java 8增加了forEach()方法作为一个<strong> java.lang.Iterable </strong>接口，帮助开发人员更多地关注程序的逻辑，而不是创建迭代器并使用它遍历集合的具体细节。这有助于提高代码可读性，并降低执行常见任务时出现编译器错误的风险。</p>
<p>我们可以将forEach()方法用作类的一部分或lambda表达式。在本Java 8新特性教程的前面，我们使用了一个购物清单示例。如果我们使用相同的示例，我们可以使用forEach()方法打印列表:</p>
<pre class="language-java"><code>public class Java8Example {
public static void main(String args[]) {
List&lt;String&gt; shoppingList = new ArrayList&lt;String&gt;();
shoppingList.add("Onions");
shoppingList.add("Bread");
shoppingList.add("Flour");
shoppingList.add("Sugar");
shoppingList.add("Chicken");
// Print out each item in the shopping list usig Java 8's
// forEach
shoppingList.forEach(item -&gt; System.out.println(item))
}
}</code></pre>
<h3 id="the-date-time-api"><strong>日期/时间API </strong></h3>
<p>从Java 8开始，<strong> java.time </strong>包包含了一个新的<strong>日期-时间</strong> API。这个API提供了几个有用的特性，包括简化的时区管理和格式。旧的<strong> Date </strong>类已经被弃用，所以鼓励开发者使用<strong> LocalDate </strong>和<strong> LocalTime </strong>来代替。</p>
<p>时区管理通过<strong> OffsetDate </strong>、<strong> OffsetDateTime </strong>和<strong> OffsetTime </strong>处理。</p>
<ul>
<li><strong> LocalDate: </strong>表示yyyy-MM-dd格式的日期</li>
<li><strong>本地时间:</strong>以HH-mm-ss-ns格式表示时间</li>
<li><strong> LocalDateTime: </strong>使用yyyy-MM-dd-HH-mm-ss-ns格式表示日期和时间</li>
</ul>
<p>使用其他格式，您可以使用<strong> DateTimeFormatter </strong>来显示和解析<strong>日期时间</strong>对象。</p>
<h3 id="concurrency-in-java-8"><strong>Java 8中的并发</strong></h3>
<p>从Java 8开始，几个主要的变化改进了并发API，包括<strong> newWorkStealingPool() </strong>方法。它创建了一个工作窃取线程池，该线程池可以在所需的并行度级别上使用可用的处理器。</p>
<p>并发API的其他改进包括:</p>
<ul>
<li><strong> ConcurrentHashMap的新方法:</strong> forEach()，forEachEntry()，forEachValue()，reduce()，merge()和search()。</li>
<li><strong> CompleteableFuture </strong>可以显式设置其值和状态</li>
</ul>
<h3 id="stream-api-for-bulk-data-operations"><strong>批量数据操作的流API</strong></h3>
<p>Java 8流API用于对集合执行批量数据操作。这可以在<strong> java.util.Stream </strong>中找到，可以用于并行和串行执行。Stream API是Java 8最有趣的特性之一，尤其是考虑到大数据日益增长的重要性。它可以轻松、快速地过滤和处理集合中的数据。</p>
<p>集合接口上的两个新方法是<strong> stream() </strong>和<strong> parallelStream() </strong>。这些默认方法正如它们的名字所暗示的那样工作，其中<strong> stream() </strong>允许打开流进行顺序执行，而<strong> parallelStream() </strong>用于并行执行。</p>
<p>这些方法可用于打开列表，如下所示:</p>
<pre class="language-java"><code>Stream&lt;Integer&gt; sequentialStream = shoppingList.stream();
Stream&lt;Integer&gt; parallelStream = shoppingList.parallelStream();</code></pre>
<p>上面的代码将把我们前面例子中的shoppingList ArrayList作为一个顺序流或并行流打开。然后列表可以有动作，比如对它执行的<strong> filter() </strong>。</p>
<h4 id="why-use-streams">为什么要使用流？</h4>
<p>并行流是为大型数据收集而设计的。在Java 8和Stream API之前，处理大型集合需要开发人员编写自己的迭代。</p>
<p>这是一个问题，原因有几个:</p>
<ol>
<li>开发人员浪费时间编写外部迭代，而不是关注应用程序的业务逻辑。</li>
<li>在大多数情况下，开发人员将最终实现简单的顺序迭代，这不适合处理大型集合。</li>
<li>即使是简单的迭代也需要额外的代码，这会产生技术债务，冒着编译器错误的风险，并使代码更难维护。</li>
</ol>
<p>Java 8的流API引入了内部迭代。它依赖Java的内部方法进行迭代、过滤和映射。Stream API使用函数接口，因此可以与lambda表达式一起使用，从而生成易读、简洁的代码。</p>

<p>记住，流API应该使用无状态的lambda表达式。如果表达式是有状态的，那么在执行并行处理时可能会遇到意外的结果。但是，对于顺序流来说，这应该不是问题。</p>
<p>开发人员不必重新发明轮子，手动过滤或删除重复项，Java可以轻松处理这些任务。</p>
<p>但是，也有一些限制。流是可消耗的。不可能创建一个流并多次使用它。然而，并行处理特性允许Stream API为大型应用程序提供高性能。此外，特定于类型的类<strong> IntStream </strong>、<strong> DoubleStream </strong>和<strong> LongStream </strong>在处理这些原语时非常有用。</p>
<p>一旦流被打开，几个中间和终端操作是可用的，包括:</p>
<ul>
<li><strong> Filter(): </strong>根据条件测试流中的每个项目，并生成与过滤器匹配的项目列表。</li>
<li><strong> Map(): </strong>将函数应用于流。</li>
<li><strong> Sorted(): </strong>对流进行排序，排序类型由比较器参数设置。</li>
<li><strong> flatMap(): </strong>从列表流创建一个流，如果它包含数组的话可能会有用。</li>
<li><strong> Count(): </strong>计算流中的项数。</li>
<li><strong> forEach(): </strong>遍历流中的项目，并对每个项目执行一个操作。</li>
<li><strong> findFirst(): </strong>在流中搜索，找到与提供的过滤器匹配的第一个项目，然后终止操作。</li>
</ul>
<p>以上并不是流API特性的完整列表。然而，对于那些处理大型数据集合的人来说，这些新的Java 8特性是值得学习的。</p>
<h3 id="other-useful-java-8-features"><strong>其他有用的Java 8特性</strong></h3>
<p>我们已经介绍了一些最有趣的Java 8特性。但是，此版本增加了其他一些有趣的改进，包括:</p>
<h4 id="java-io-improvements"><em> Java IO改进</em></h4>
<p>Java 8为打开和读取文件提供了几个新特性，包括:</p>
<ul>
<li><strong> Files.list(): </strong>这需要一个路径并返回一个惰性填充的流，列出目录中的文件</li>
<li><strong> Files.lines(): </strong>读取一个文件并返回一个包含该文件所有行的流</li>
<li><strong> Files.find(): </strong>搜索一个文件并返回一个由文件路径组成的流</li>
<li><strong> BufferedReader.lines(): </strong>打开一个缓冲读取器并返回一个包含从读取器读取的行的流。</li>
</ul>
<h4 id="base64-encoding-and-decoding"><em> Base64编解码</em></h4>
<p>新的<strong> java.util.Base64 </strong>类以MIME友好的格式为Base64提供编码和解码支持。编码器不会在输出的末尾添加换行符，解码器会拒绝集合之外的任何字符:“A-Za-z0-9+/”。</p>

<p>Java 8版本引入了新工具，增加了新特性，删除了过时的特性。例如，JDBC-ODBC桥和PermGen内存空间都被删除了。</p>
<p>Java 8增加了<strong> jdeps </strong>命令，这是一个命令行工具和类依赖分析器。jar文件并枚举包或类级别的依赖关系。</p>

<h2 id="conclusion"><strong>结论</strong></h2>
<p>Java 8在许多程序员的日常工作中仍然很重要。你可以通过探索<a href="https://hackr.io/blog/best-java-ides">Java ide</a>和课程来保持你的知识。</p>

<p>但这里有一个有趣的事实——Java 8仍然是科技界新职位的常见工作要求。现在您已经探索了Java 8的特性，可以考虑继续为您的下一个职业发展做准备了。</p>
<p><a class="btn btn-primary btn-call-to-action btn-block" href="https://click.linksynergy.com/link?id=jU79Zysihs4&amp;offerid=1045023.533682&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fjava-the-complete-java-developer-course%2F" target="_blank" rel="noopener"> Java编程大师班更新到Java 17 </a></p>
<h2 id="frequently-asked-questions"><strong>常见问题解答</strong></h2>
<h4 id="toc-1-what-is-meant-by-java-8"><strong> 1。Java 8是什么意思？</strong></h4>
<p>Java 8是指Java平台的第8个版本。这是一个具有扩展支持和几个新的API特性、工具和语言变化的主要版本。因为这个版本是如此重要的一个里程碑，所以它很受那些希望为他们的应用程序提供一个稳定平台的开发人员的欢迎。</p>
<h4 id="toc-2-what-are-the-characteristics-of-java-8"><strong> 2。Java 8有什么特点？</strong></h4>
<p>Java 8是Java的长期支持(LTS)版本。这意味着与大多数其他版本不同，这些版本在发布后仅支持六个月的更新，用户可以期待更长时间的标准支持，之后还可以选择特优、扩展支持。Java 8已经有八年多的历史了，扩展支持一直持续到2030年12月。</p>
<p>截至2019年4月，Java 8 SE免费用于一般的非商业计算用途。Java 8 U 202和早期版本不收取许可费。然而，那些希望将Java 8 SE用于商业目的的人必须为更新付费。</p>
<h4 id="toc-3-what-are-the-advantages-of-java-8-features"><strong> 3。Java 8特性的优势是什么？</strong></h4>
<p>Java 8的新特性提供了几个潜在的好处:</p>
<ul>
<li>更容易编写人类可读的代码</li>
<li>开发人员有更多的时间关注业务逻辑，而不是重新实现常用的算法</li>
<li>降低编译器错误的风险</li>
<li>通过LTS为开发者和用户提供稳定性</li>
</ul>
<h4 id="toc-4-what-is-the-latest-version-of-java"><strong> 4。Java的最新版本是什么？</strong></h4>
<p>截至2022年8月，Java的最新版本是2022年3月发布的Java 18。Java 19将于2022年9月取代Java 18。两者都是非LTS发行的。</p>
<p><strong>人也在读:</strong></p>


									</div>

									</div>    
</body>
</html>