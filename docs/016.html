<html>
<head>
<title>Bubble Sort in C - [Program &amp; Algorithm] Step-by-Step Explanation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>C-[程序和算法]中的冒泡排序分步解释</h1>
<blockquote>原文：<a href="https://hackr.io/blog/bubble-sort-in-c#0001-01-01">https://hackr.io/blog/bubble-sort-in-c#0001-01-01</a></blockquote><div><div class="content">
										<p>数据排序是计算机科学中最基本也是最重要的问题之一。对于那些想学习数据结构和算法的人来说，排序是一个很好的案例研究。</p>
<h2 id="what-is-sorting-definition"><strong>什么是排序定义</strong></h2>
<p>在现实生活中，我们经常被要求按照特定的顺序排列数据。例如，在我们上学的时候，我们被告知要根据身高排队。另一个例子是学校/学院的出勤登记，其中包含按字母顺序排列的我们的名字。</p>
<p>这些数据安排使得将来使用数据更加容易。在100名学生的考勤记录中找到“乔”。按特定顺序排列数据称为按该顺序对数据进行排序。2最常用的订单有:</p>
<ul>
<li><strong>升序:</strong> <span>在按升序排列数据时，我们试图以某种方式排列数据，使每个元素在某种程度上“小于”它的后继元素。这种“小于”关系是从其获取数据的集合上的有序关系。举个简单的例子，数字1，2，3，4，5是按升序排列的。在这里，“小于”关系实际上是“&lt;”运算符。可以看出，1 &lt; 2 &lt; 3 &lt; 4 &lt; 5。</span></li>
<li><strong>降序:</strong> <span>降序与升序正好相反。给定一个按升序排序的数据，反转它，你将得到按降序排序的数据。</span></li>
</ul>
<p>由于两个订单的性质相似，我们通常会删除实际订单，并说我们希望对数据进行排序。这通常意味着我们希望数据按照<em><span/></em><span>升序排序。</span>在我们进入排序算法的细节之前，让我们先了解一下问题陈述。</p>

<h2 id="problem-statement"><strong>问题陈述</strong></h2>
<p>我们得到了一组数据。我们还可以对数据中的元素进行“排序”。现在，我们被要求按照给定的顺序排列数据。 <span>举个例子，给我们一个整数数组:[5，1，4，2，3]。我们得到的“顺序”是“小于”。因此，我们被要求以这样一种方式排列这个数组的元素，使得每个元素都比它的后继元素小。基本上，我们需要找到一种方法来对这个数组进行排序，以便最终获得的数组是[1，2，3，4，5]。</span> <span>有几种技术/算法可以实现这种有序的输出数组。我们将在本博客中讨论的一个著名技术叫做冒泡排序。</span></p>
<h2 id="bubble-sort-algorithm-in-c-introduction"><strong>C语言中的冒泡排序算法简介</strong></h2>
<p>C中的冒泡排序是一种排序算法，我们在数组中反复迭代，并交换相邻的无序元素。 <span>我们重复这个过程，直到数组排序完毕。</span></p>
<p><span>作为一个例子，对于上面提到的数组- [5，1，4，2，3]我们可以看到5不应该在1的左边，因此，我们交换它们得到:[1，5，4，2，3]。</span> <span>接下来，我们看到5应该又不在4的左边。我们交换5和4得到[1，4，5，2，3]。我们对5和2重复这个过程，然后对5和3重复这个过程，得到[1，4，2，3，5]。</span></p>
<p><span>可以看出，在阵列上“经过”一次后，最大的元素(本例中为5个)已经到达其正确的位置——最右边。让我们试着重复这个过程。</span></p>
<p><span> (1，4)正确。然而，(4，2)是不正确的顺序。因此，我们交换4和2得到[1，2，4，3，5]。(4，3)也是不正确的，所以我们再交换一次，得到[1，2，3，4，5]。</span></p>
<p><em> <span>可以看出，数组是排序的！</span>T3】</em></p>

<p>这正是C语言中冒泡排序的工作方式。</p>
<p><span>例如，请看这幅图片，它形象地描述了冒泡排序的工作原理。</span> <span> <img class="alignnone" src="../Images/453f10ed8306df3bda8d17f53a344da1.png" alt="How-bubble-sort-works-gif" data-original-src="https://media.giphy.com/media/sJqcl6rWaEEXS/giphy.gif"/> </span></p>
<p><strong>建议课程</strong></p>
<p><strong> <a class="btn btn-primary btn-call-to-action " href="https://click.linksynergy.com/deeplink?id=jU79Zysihs4&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fmaster-the-coding-interview-data-structures-algorithms%2F" target="_blank" rel="noopener">掌握编码面试:数据结构+算法</a> </strong></p>
<h2 id="bubble-sort-explanation"><strong>冒泡排序-解释</strong></h2>
<p><span>在第一次“通过”数组时，最大的元素总是被交换，直到它被放在最右边。这是因为这个最大的元素总是会打破期望的顺序。因此，在第一遍结束时，最大的元素将始终到达其正确的位置。</span></p>
<p>现在，最大的元素已经到达了它的正确位置(例如，5到达了最后一个位置)，我们可以简单地忽略它，并专注于数组的其余部分(在上面的例子中是[1，4，2，3])。这里，数组剩余部分中最大的元素(4)将是数组中第二大的元素。通过上面的递归参数，这个第二大的数组将到达剩余数组的最后一个位置([1，2，3，4])。这只不过是对剩余数组的递归自变量。</p>
<p>这一直持续到n次迭代，其中n =数组中元素的数量。最后，数组被排序。</p>
<pre><span>#include &lt;stdio.h&gt;</span><br/><span>void bubble_sort(int a[], int n) {</span><br/><span>    int i = 0, j = 0, tmp;</span><br/><span>    for (i = 0; i &lt; n; i++) {   // loop n times - 1 per element</span><br/><span>        for (j = 0; j &lt; n - i - 1; j++) { // last i elements are sorted already</span><br/><span>            if (a[j] &gt; a[j + 1]) {  // swop if order is broken</span><br/><span>                tmp = a[j];</span><br/><span>                a[j] = a[j + 1];</span><br/><span>                a[j + 1] = tmp;</span><br/><span>            }</span><br/><span>        }</span><br/><span>    }</span><br/><span>}</span><br/><span>int main() {</span><br/><span>  int a[100], n, i, d, swap;</span><br/><span>  printf("Enter number of elements in the array:\n");</span><br/><span>  scanf("%d", &amp;n);</span> <br/><span>  printf("Enter %d integers\n", n);</span><br/><span>  for (i = 0; i &lt; n; i++)</span><br/><span>    scanf("%d", &amp;a[i]);</span><br/><span>  bubble_sort(a, n);</span><br/><span>  printf("Printing the sorted array:\n");</span><br/><span>  for (i = 0; i &lt; n; i++)</span><br/><span>     printf("%d\n", a[i]);</span><br/><span>  return 0;</span><br/><span>}</span></pre>
<h2 id="bubble-sort-program-in-c"><strong>C语言中的冒泡排序程序</strong></h2>
<p>我们循环n次——对数组的每个元素循环一次。当 <span> i = 0 </span> <span>时，通过</span> <span> j </span> <span>循环，数组的最大元素到达正确位置。当</span> <span> i = 1 </span> <span>时，通过</span> <span> j </span> <span>循环，数组的第二大元素到达正确位置。如此等等。</span></p>
<h2 id="conclusion"><strong>结论</strong></h2>
<p>冒泡排序是一个相当简单的算法。这是一个有趣的例子，说明简单的计算可以用来完成更复杂的任务。然而，该算法有一个问题——与其他排序算法相比，它相对较慢。为了理解这一点，让我们看一下相关的循环——有两个循环:</p>
<ul>
<li><span>首先，从</span> <span> i = 0 </span> <span>到</span> <span> i = n - 1 </span> <span>的变量</span> <span> i </span> <span>的外循环。</span></li>
<li><span>对于外</span> <span> i </span> <span>循环的每次迭代，变量</span> <span> j </span> <span>的内循环从</span> <span> j = 0 </span> <span>到</span> <span> j = n - i - 2 </span> <span>。</span></li>
</ul>
<p><span>我们可以合并迭代次数来看:</span></p>
<ul>
<li><span>当</span> <span> i = 0 </span> <span>时，内j循环从</span> <span> j = 0 </span> <span>到</span> <span> j = n - 2 </span></li>
<li><span>当</span> <span> i = 1 </span> <span>时，内j循环从</span> <span> j = 0 </span> <span>到</span> <span> j = n - 3 </span></li>
<li><span>当</span> <span> i = 2 </span> <span>时，内j循环从</span> <span> j = 0 </span> <span>到</span> <span> j = n - 4 </span></li>
<li><span>当</span> <span> i = n - 2 </span> <span>时，内j循环从</span> <span> j = 0 </span> <span>到</span> <span> j = 0 </span></li>
</ul>
<p><span>我们可以把这个加起来看，总迭代次数是(n-2)+(n-3)+(n-4)…+1+0 =(n-2)*(n-3)/2 =(n</span><sup><span>2</span></sup><span>-5n+6)/2 = n</span><sup><span>2</span></sup><span>/2-2.5n+3</span><span>可以看出 这一项正比于n</span><sup><span>2</span></sup><span>(n的最大幂是n</span><sup><span>2</span></sup><span>)。 数学上，这被表述为-冒泡排序算法的复杂度为O(n</span><sup><span>2</span></sup><span>)。这还不是最好的，因为当n很大时(比如n = 10 </span> <span> 6 </span> <span>)，n</span><sup><span>2</span></sup><span>是巨大的(n</span><sup><span>2</span></sup><span>= 10</span><span>12</span><span>)。因此，算法需要大量的迭代才能完成。这是不可取的。还有一些比较好的算法像C中的<a href="https://hackr.io/blog/merge-sort-in-c">归并排序</a>等，需要O(nlog</span><sub><span>2</span></sub><span>n)次迭代。logn比n小很多，举个例子，当n = 2 </span> <span> 30 </span> <span>(也就是大约10 </span> <span> 9 </span> <span>，log</span><sub><span>2</span></sub><span>n正好是30)。尽管如此，冒泡排序是一个有趣的算法，也是初学者理解排序如何工作的一个好方法。</span></p>
<p class="p1"><strong>人也在读:</strong></p>


									</div>

									</div>    
</body>
</html>