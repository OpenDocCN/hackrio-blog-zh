<html>
<head>
<title>Download Angular Cheat Sheet PDF for 2023 [Updated]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>下载2023年角度备忘单PDF更新]</h1>
<blockquote>原文：<a href="https://hackr.io/blog/angular-cheat-sheet#0001-01-01">https://hackr.io/blog/angular-cheat-sheet#0001-01-01</a></blockquote><div><div class="content">
										<p>开源的Angular框架有一个模块化的架构，并带有可重用的UI组件——非常适合构建大规模的应用程序。Angular基于<a href="https://hackr.io/blog/typescript-vs-javascript"> TypeScript </a>，一种深受JavaScipt影响的编程语言。此外，Angular利用了一种名为Ivy的新技术，这是Angular编译和渲染管道的代号。</p>
<p>由于<a href="https://hackr.io/blog/why-should-you-learn-angular"> Angular </a>是使用最广泛的框架之一，许多技术专业人士研究它以获得稳定的工作机会。但是你不可能把所有的角度方法和命令都背下来。这就是这个方便的角度小抄的用武之地！</p>
<p>准备好深入Angular语法并轻松完成下一个Angular项目了吗？使用这个更新的Angular 4备忘单来补充你的web开发职业。</p>
<p>点击下载完整的角度备忘单PDF <strong> <a href="https://drive.google.com/file/d/1VTqMQBoBDoJ2Az1k6ehyXQwp_3QMtMFC/view?usp=sharing" target="_blank" rel="noopener">。</a></strong></p>

<h2 id="angular-cheat-sheet"><strong>棱角分明的小抄</strong></h2>
<p>在我们开始之前，让我们简单地接触一下Angular JS。背景将帮助你理解在你的工作中使用Angular框架背后的更大的目的。</p>
<h3 id="what-is-angular-js"><strong>什么是Angular JS？</strong></h3>
<p>谷歌开发了AngularJS，这是一个Javascript框架，帮助开发人员创建完全扩展的单页面web应用程序。术语“单页”是指网页需要更新。</p>
<p>单个网页由多个移动部件及其组织结构组成，包括导航栏、页脚、侧边栏等等。为了将这些组件注入到同一个网页中，我们使用AngularJS。</p>
<p>底线？AngularJS使网页动态化。AngularJS不会在用户导航到URL时刷新页面，而是将所需的组件注入到同一个页面中。它基本上重用了不变的组件，减少了加载时间，提供了更好的浏览体验。</p>
<p>现在，让我们进入一些角度命令。</p>
<h3 id="angular-cli-cheat-sheet"><strong> Angular CLI备忘单</strong></h3>
<p>Angular命令行界面(CLI)是一组命令，可帮助您直接从命令外壳初始化、开发和维护高度可扩展和快速的Angular应用程序。</p>

<p>在这个Angular CLI命令备忘单部分，我们将介绍各种Angular CI命令。</p>
<h4 id="toc-1-setup"><strong> 1。设置</strong></h4>
<p>以下命令全局安装Angular CLI:</p>
<pre class="language-javascript"><code>npm install -g @angular/cli</code></pre>
<h4 id="toc-2-new-application"><strong> 2。新应用程序</strong></h4>
<p>以下命令将前缀设置为“best:”</p>
<pre class="language-javascript"><code>ng new best-practises --prefix best</code></pre>
<p>该命令检查可用的命令列表。</p>
<pre class="language-javascript"><code>ng new --help</code></pre>
<p>该命令模拟“ng new”命令:</p>
<pre class="language-javascript"><code>ng new best-practises --dry-run</code></pre>
<h4 id="toc-3-lint-for-formatting"><strong> 3。用于格式化的线头</strong></h4>
<p>Lint命令修复代码气味并纠正不正确的格式。</p>
<pre class="language-javascript"><code>ng lint my-app --fix</code></pre>
<p>下一个命令显示警告:</p>
<pre class="language-javascript"><code>ng lint my-app</code></pre>
<p>如果想格式化代码，可以使用下面的命令。</p>
<pre class="language-javascript"><code>ng lint my-app --format stylish</code></pre>
<p>接下来，该命令验证可访问的命令列表。</p>
<pre class="language-javascript"><code>ng lint my-app --help</code></pre>
<h4 id="toc-4-blueprints"><strong> 4。蓝图</strong></h4>
<p>生成规格:</p>
<pre class="language-javascript"><code>--spec</code></pre>
<p>检查模板是否为. ts文件:</p>
<pre class="language-javascript"><code>--inline-template (-t)</code></pre>
<p>检查样式是否在. ts文件中:</p>
<pre class="language-javascript"><code>--inline-style (-s)</code></pre>
<p>创建指令:</p>
<pre class="language-javascript"><code>ng g d directive-name</code></pre>
<p>创建管道:</p>
<pre class="language-javascript"><code>ng g p init-caps</code></pre>
<p>在模型文件夹中创建客户类:</p>
<pre class="language-javascript"><code>ng g cl models/customer</code></pre>
<p>无需创建新文件夹即可创建组件。</p>
<pre class="language-javascript"><code>ng g c my-component --flat true</code></pre>
<p>分配前缀:</p>
<pre class="language-javascript"><code>--prefix</code></pre>
<p>在模型文件夹中创建一个界面:</p>
<pre class="language-javascript"><code>ng g i models/person</code></pre>
<p>在模型文件夹中创建枚举性别:</p>
<pre class="language-javascript"><code>ng g e models/gender</code></pre>
<p>创建服务:</p>
<pre class="language-javascript"><code>ng g s service-name</code></pre>
<h4 id="toc-5-building-serving"><strong> 5。建筑服务</strong></h4>
<p>构建应用程序至/分发文件夹:</p>
<pre class="language-javascript"><code>ng build</code></pre>
<p>不使用不必要的代码优化和构建应用程序:</p>
<pre class="language-javascript"><code>ng build --aot</code></pre>
<p>为生产创建一个版本:</p>
<pre class="language-javascript"><code>ng build --prod</code></pre>
<p>打开浏览器指定服务:</p>
<pre class="language-javascript"><code>ng serve -o</code></pre>
<p>发生更改时重新加载:</p>
<pre class="language-javascript"><code>ng serve --live-reload</code></pre>
<p>使用SSL提供服务:</p>

<pre class="language-javascript"><code>ng serve -ssl</code></pre>
<h4 id="recommended-courses"><strong>推荐课程</strong></h4>
<p><a href="https://click.linksynergy.com/deeplink?id=jU79Zysihs4&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourses%2Fsearch%2F%3Fsrc%3Dukw%26q%3Dangular" target="_blank" rel="noopener"><strong><img src="../Images/8e13b18ae7ac23ad81e5b0889a08cbec.png" alt="" data-original-src="https://cdn.hackr.io/uploads/posts/attachments/1669138247uKbpVNl1T8.png"/></strong>T4】</a></p>
<h4 id="toc-6-add-new-capabilities"><strong> 6。添加新功能</strong></h4>
<p>将有角度的材料添加到项目中:</p>
<pre class="language-javascript"><code>ng add @angular/material</code></pre>
<p>创建材料导航组件:</p>
<pre class="language-javascript"><code>ng g @angular/material:material-nav --name nav</code></pre>
<h3 id="components-and-templates"><strong>组件和模板</strong></h3>
<p>组件是最基本的UI构件。一棵Angular组件树组成一个Angular app。</p>
<h4 id="sample-component-ts-file"><strong>样本组件ts文件</strong></h4>
<pre class="language-javascript"><code>import { Component } from '@angular/core';

@Component({

// component attributes

selector: 'app-root',

templateUrl: './app.component.html',

styleUrls: ['./app.component.less']

})

export class AppComponent {

title = 'Hello World';

}</code></pre>
<h4 id="component-attributes"><strong>组件属性</strong></h4>
<p><strong>变化检测</strong></p>
<p>用于此组件的更改检测策略。</p>
<p><strong> viewProviders </strong></p>
<p>定义对其视图DOM子对象可见的可注入对象集。</p>
<p><strong>模块Id </strong></p>
<p>包含组件的模块的模块ID。</p>

<p><strong>封装</strong></p>

<p>模板和CSS样式的封装策略。</p>
<p><strong>插值</strong></p>
<p>覆盖默认的封装开始和结束分隔符({{和})。</p>
<p><strong>入口组件</strong></p>
<p>应与该组件一起编译的一组组件。</p>
<p><strong>保留白色空间</strong></p>
<p>True表示保留，false表示从编译后的模板中删除可能多余的空白字符。</p>
<h4 id="component-life-cycles"><strong>组件生命周期</strong></h4>
<p><strong> ngOnInit </strong></p>
<p>在第一次ngOnChanges()之后调用一次</p>
<p><strong> ngOnChanges </strong></p>

<p>在ngOnInit()之前以及每当其中一个输入属性发生更改时调用。</p>

<p><strong> ngOnDestroy </strong></p>
<p>在Angular销毁指令/组件之前调用。</p>
<p><strong> ngDoCheck </strong></p>
<p>在每次更改检测运行期间调用。</p>
<p><strong> ngAfterContentChecked </strong></p>
<p>在ngAfterContentInit()和每个后续的ngDoCheck()之后调用</p>
<p><strong> ngAfterViewChecked </strong></p>
<p>在ngAfterViewInit()和每个后续的ngAfterContentChecked()之后调用。</p>
<p><strong> ngAfterContentInit </strong></p>
<p>在第一个ngDoCheck()之后调用一次。</p>
<p><strong>ngaafterviewinit</strong></p>
<p>在第一个ngAfterContentChecked()之后调用一次。</p>
<h4 id="template-syntax"><strong>模板语法</strong></h4>
<pre class="language-javascript"><code>{{user.name}}</code></pre>
<p>插值-生成用户名。</p>
<pre class="language-javascript"><code>&lt;img [src] = "user.imageUrl"&gt;</code></pre>
<p>属性绑定-将用户的图像url绑定到src属性</p>
<pre class="language-javascript"><code>&lt;button (click)="do()" ... /&gt;</code></pre>
<p>事件-分配点击事件的功能</p>
<pre class="language-javascript"><code>&lt;button *ngIf="user.showSth" ... /&gt;</code></pre>
<p>当user.showSth为真时显示按钮</p>
<pre class="language-javascript"><code>*ngFor="let item of items"</code></pre>
<p>遍历项目列表</p>
<pre class="language-javascript"><code>&lt;div [ngClass]="{green: isTrue(), bold: itTrue()}"/&gt;</code></pre>
<p>角度ngClass属性</p>
<pre class="language-javascript"><code>&lt;div [ngStyle]="{'color': isTrue() ? '#bbb' : '#ccc'}"/&gt;</code></pre>
<p>角度ngStyle属性</p>
<h4 id="input-and-output"><strong>输入和输出</strong></h4>
<p>Input()将值传递给子组件</p>
<p>子组件实现示例:</p>
<pre class="language-javascript"><code>export class SampleComponent {

@Input() value: any/string/object/…;

...

}</code></pre>
<p>父组件用法示例:</p>
<pre class="language-javascript"><code>&lt;app-sample-component [value]="myValue"&gt;&lt;/app-sampe-component&gt;

Output() Emitting event to parent component

Sample child component:

@Output() myEvent: EventEmitter = new EventEmitter();

onRemoved(item: MyModel) {

this.myEvent.emit(item);

}</code></pre>
<p>示例父组件:</p>
<pre class="language-javascript"><code>&lt;app-my-component 

(myEvent)="someFunction()"&gt;&lt;/app-my-component&gt;</code></pre>
<p>子组件中的<strong> onRemoved </strong>正在调用父组件中的<strong> someFunction() </strong>方法，正如我们在上面两个子组件和父组件中看到的。</p>
<h4 id="content-projection"><strong>内容投影</strong></h4>
<p>Angular中的内容投影是一种模式，在这种模式中，您将所需的内容注入到特定的组件中。</p>
<p>以下是父组件模板的示例:</p>
<pre class="language-javascript"><code>&lt;component&gt;

&lt;div&gt;

(some html here)

&lt;/div&gt;

&lt;/component&gt;</code></pre>
<p>子组件模板:</p>
<pre class="language-javascript"><code>&lt;ng-content&gt;&lt;/ng-content&gt;</code></pre>
<p>现在让我们在父组件模板中注入以下HTML代码:</p>
<pre class="language-html"><code>&lt;div well-body&gt;

(some html here)

&lt;/div&gt;</code></pre>
<p>它看起来会像:</p>
<pre class="language-javascript"><code>&lt;component&gt;

&lt;div well-title&gt;

(some html here)

&lt;/div&gt;

&lt;div well-body&gt;

(some html here)

&lt;/div&gt;

&lt;/component&gt;</code></pre>
<p>当我们组合上述父模板和子模板时，您会得到以下结果:</p>
<pre class="language-javascript"><code>&lt;component&gt;

&lt;div well-title&gt;

(some html here)

&lt;/div&gt;

&lt;div well-body&gt;

(some html here)

&lt;/div&gt;

&lt;/component&gt;

&lt;ng-content select="title"&gt;&lt;/ng-content&gt; 

&lt;ng-content select="body"&gt;&lt;/ng-content&gt;</code></pre>
<h4 id="viewchild-decorator"><strong> ViewChild Decorator </strong></h4>
<p>提供对子组件/指令/元素的访问:</p>
<pre class="language-javascript"><code>@ViewChild(NumberComponent)

private numberComponent: NumberComponent;

increase() {

this.numberComponent.increaseByOne(); //method from child component

}

decrease() {

this.numberComponent.decreaseByOne(); //method from child component

}</code></pre>
<p>元素的示例:html:</p>
<pre class="language-javascript"><code>&lt;div #myElement&gt;&lt;/div&gt;</code></pre>
<p>组件:</p>
<pre class="language-javascript"><code>@ViewChild('myElement') myElement: ElementRef</code></pre>
<p>相反，ElementRef可用于特定元素，如FormControl for forms。</p>
<p>对html中元素的引用:</p>
<pre class="language-javascript"><code>&lt;button (click)="doSth(myElement)"&gt;&lt;/button&gt;</code></pre>
<h3 id="routing"><strong>路由</strong></h3>
<p>当用户执行应用任务时，角度路由器能够从一个视图导航到下一个视图。</p>
<p>示例路由ts文件:</p>
<pre class="language-javascript"><code>const appRoutes: Routes = [

{ path: 'crisis-center', component: CrisisListComponent },

{ path: 'prod/:id', component: HeroDetailComponent },

{

path: 'products',

component: ProductListComponent,

data: { title: 'Products List' }

},

{ path: '',

redirectTo: '/products',

pathMatch: 'full'

},

{ path: '**', component: PageNotFoundComponent }

];</code></pre>
<p>然后，应该将它添加到Angular.module导入中:</p>
<pre class="language-javascript"><code>RouterModule.forRoot(appRoutes)</code></pre>
<p>您还可以通过添加enableTracing来打开路由的控制台跟踪:</p>
<pre class="language-javascript"><code>imports: [

RouterModule.forRoot(

routes,

{enableTracing: true}

)

],</code></pre>
<p>使用</p>
<pre class="language-javascript"><code>&lt;a routerLink="/crisis-center" routerLinkActive="active"&gt;Crisis Center&lt;/a&gt;</code></pre>
<p>当链接的路由变为活动时，routerLinkActive="active "将向元素添加活动类</p>
<pre class="language-javascript"><code>//Navigate from code
this.router.navigate(['/heroes']);

// with parameters

this.router.navigate(['/heroes', { id: heroId, foo: 'foo' }]);

// Receive parameters without Observable
let id=this.route.snapshot.paramMap.get('id');</code></pre>
<h4 id="canactivate-and-candeactivate"><strong>可以激活和取消激活</strong></h4>
<p>在角度路由中，两个路由保护可以激活和禁用。前者决定路由是否可以被当前用户激活，后者决定路由器是否可以被当前用户去激活。</p>
<p><strong>可以激活:</strong></p>
<pre class="language-javascript"><code>class UserToken {}

class Permissions {

canActivate(user: UserToken, id: string): boolean {

return true;

}

}</code></pre>
<p><strong>可以激活:</strong></p>
<pre class="language-javascript"><code>class UserToken {}

class Permissions {

canDeactivate(user: UserToken, id: string): boolean {

return true;

}

}</code></pre>
<h3 id="modules"><strong>模块</strong></h3>
<p>Angular应用程序是模块化的，Angular有自己的模块化系统，称为NgModules。NgModules是专用于应用程序域、工作流或一组密切相关的功能的内聚代码块的容器。</p>

<pre class="language-javascript"><code>import { BrowserModule } from '@angular/platform-browser';

import { NgModule } from '@angular/core';

import { AppRoutingModule } from './app-routing.module';

import { AppComponent } from './app.component';

@NgModule({

declarations: [AppComponent], // components, pipes, directives

imports: [BrowserModule, AppRoutingModule], // other modules

providers: [], // services

bootstrap: [AppComponent] // top component

})

export class AppModule { }</code></pre>
<h3 id="services"><strong>服务</strong></h3>
<p>组件不应该直接获取或保存数据，当然也不应该故意呈现虚假数据。相反，他们应该专注于呈现数据，并将数据访问委托给服务。</p>
<p>具有一个功能的示例服务:</p>
<pre class="language-javascript"><code>@Injectable()

export class MyService {

public items: Item[];

constructor() { }

getSth() {

// some implementation

}

}</code></pre>
<p>当您创建组件类的任何新实例时，Angular通过查看构造函数中定义的参数来确定该组件所需的服务和其他依赖项，如下所示:</p>
<pre class="language-javascript"><code>constructor(private dogListService: MyService){ }</code></pre>
<p>上面的构造函数需要服务:MyService</p>
<p>在providers模块中注册MyService:</p>
<pre class="language-javascript"><code>providers: [MyService]</code></pre>
<h4 id="httpclient"><strong>http客户端</strong></h4>
<p>这个命令处理和使用http请求。</p>
<p>将导入添加到模块:</p>
<pre class="language-javascript"><code>import { HttpClientModule} from "@angular/common/http";</code></pre>
<p>您可以按以下方式使用上述语句:</p>
<pre class="language-javascript"><code>import {HttpClient} from '@angular/common/http';

...

// GET

public getData(): Observable {

return this.http.get('api/users/2');

}

// POST

public send(val1: any, val2: any): Observable {

const object = new SendModel(val1, val2);

const options = {headers: new HttpHeaders({'Content-type': 'application/json'})};

return this.http.post(environment.apiUrl + 'api/login', object, options);

}</code></pre>
<h4 id="dependency-injection"><strong>依赖注入</strong></h4>
<p>这将一个类注入另一个类:</p>
<pre class="language-javascript"><code>@Injectable({

providedIn: 'root',

})

export class SomeService {}</code></pre>
<p>它接受“root”作为一个值或应用程序的任何模块。</p>
<h4 id="declare-global-values"><strong>声明全局值</strong></h4>
<p>类别:</p>
<pre class="language-javascript"><code>import {InjectionToken} from '@angular/core';

export const CONTROLS_GLOBAL_CONFIG = new InjectionToken('global-values');

export interface ControlsConfig {firstGlobalValue: string;}</code></pre>
<p>模块:</p>
<pre class="language-javascript"><code>providers: [{provide: CONTROLS_GLOBAL_CONFIG, useValue: {firstGlobalValue : 'Some value' }},</code></pre>
<p>用法(例如在组件中):</p>
<pre class="language-javascript"><code>constructor(@Optional() @Inject(CONTROLS_GLOBAL_CONFIG) globalVlues: ControlsConfig) {</code></pre>
<h3 id="pipes"><strong>管道</strong></h3>
<p>管道将数据和值转换为特定的格式。例如:</p>
<p>以短日期格式显示日期:</p>
<pre class="language-javascript"><code>{{model.birthsDay | date:'shortDate'}}</code></pre>
<p>管道实施:</p>
<pre class="language-javascript"><code>@Pipe({name: 'uselessPipe'})

export class uselessPipe implements PipeTransform {

transform(value: string, before: string, after: string): string {

let newStr = `${before} ${value} ${after}`;

return newStr;

}

}</code></pre>
<p>用法:</p>
<pre class="language-javascript"><code>{{ user.name | uselessPipe:"Mr.":"the great" }}</code></pre>
<h3 id="directives"><strong>指令</strong></h3>
<p>属性指令改变DOM元素的外观或行为。例如，[ngStyle]就是一个指令。</p>
<p>自定义指令:</p>
<pre class="language-javascript"><code>import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Directive({

selector: '[appHighlight]'

})

export class HighlightDirective {

constructor(private el: ElementRef) { }

@Input('appHighlight') highlightColor: string;

@Input('otherPar') otherPar: any; //it will be taken from other attribute named [otherPar]

@HostListener('mouseenter') onMouseEnter() {

this.highlight(this.highlightColor || 'red');

}

private highlight(color: string) {

this.el.nativeElement.style.backgroundColor = color;

}
}</code></pre>
<p>用法:</p>
<pre class="language-javascript"><code>&lt;p [appHighlight]="color" [otherPar]="someValue"&gt;Highlight me!&lt;/p&gt;</code></pre>
<h3 id="animations"><strong>动画</strong></h3>
<p>动画允许您在将BrowserModule和BrowserAnimationsModule添加到模块之前从一种样式状态移动到另一种样式状态。</p>
<p>实施:</p>
<pre class="language-javascript"><code>animations: [

trigger('openClose', [

state('open', style({

height: '400px',

opacity: 1.5,

})),

state('closed', style({

height: '100px',

opacity: 0.5,

})),

transition('open =&gt; closed', [

animate('1s')

]),

transition('closed =&gt; open', [

animate('1s')

])

])

]</code></pre>
<p>用法:</p>
<pre class="language-javascript"><code>&lt;div [@openClose]="isShowed ? 'open' : 'closed'"&gt;</code></pre>
<h3 id="angular-forms"><strong>角形</strong></h3>
<p>在Angular 4备忘单的这一部分，我们将讨论不同类型的角形。</p>
<h4 id="template-driven-forms"><strong>模板驱动表单</strong></h4>
<p>表单逻辑(验证、属性)保存在模板中。</p>
<p>html示例</p>
<pre class="language-html"><code>&lt;form name="form" (ngSubmit)="f.form.valid &amp;&amp; onSubmit()" #f="ngForm" novalidate&gt;

&lt;div class="form-group"&gt;

&lt;label for="firstName"&gt;First Name&lt;/label&gt;

&lt;input type="text" class="form-control" name="firstName" [(ngModel)]="model.firstName" #firstName="ngModel" [ngClass]="{ 'is-invalid': f.submitted &amp;&amp; firstName.invalid }" required /&gt;

&lt;div *ngIf="f.submitted &amp;&amp; firstName.invalid" class="invalid-feedback"&gt;

&lt;div *ngIf="firstName.errors.required"&gt;First Name is required&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;

&lt;div class="form-group"&gt;

&lt;button class="btn btn-primary"&gt;Register&lt;/button&gt;

&lt;/div&gt;

&lt;/form&gt;</code></pre>
<p>样本组件:</p>
<pre class="language-javascript"><code>@ViewChild("f") form: any;

firstName: string = "";

langs: string[] = ["English", "French", "German"];

onSubmit() {

if (this.form.valid) {

console.log("Form Submitted!");

this.form.reset();

}

}</code></pre>
<h4 id="reactive-forms"><strong>反应形式</strong></h4>
<p>表单逻辑(验证、属性)保存在<em>组件中。</em></p>
<p>示例HTML:</p>
<pre class="language-html"><code>&lt;form [formGroup]="registerForm" (ngSubmit)="onSubmit()"&gt;

&lt;div class="form-group"&gt;

&lt;label&gt;Email&lt;/label&gt;

&lt;input type="text" formControlName="email" class="form-control" [ngClass]="{ 'is-invalid': submitted &amp;&amp; f.email.errors }" /&gt;

&lt;div *ngIf="submitted &amp;&amp; f.email.errors" class="invalid-feedback"&gt;

&lt;div *ngIf="f.email.errors.required"&gt;Email is required&lt;/div&gt;

&lt;div *ngIf="f.email.errors.email"&gt;Email must be a valid email address&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;

&lt;div class="form-group"&gt;

&lt;button [disabled]="loading" class="btn btn-primary"&gt;Register&lt;/button&gt;

&lt;/div&gt;

 &lt;/form&gt;</code></pre>
<p>样本组件:</p>
<pre class="language-javascript"><code>registerForm: FormGroup;

submitted = false;

constructor(private formBuilder: FormBuilder) { }

ngOnInit() {

this.registerForm = this.formBuilder.group({

firstName: [{{here default value}}, Validators.required],

lastName: ['', Validators.required],

email: ['', [Validators.required, Validators.email]],

password: ['', [Validators.required, Validators.minLength(6)]]

});

}

// convenience getter for easy access to form fields

get f() { return this.registerForm.controls; }

 onSubmit() {

this.submitted = true;

// stop here if form is invalid

if (this.registerForm.invalid) {

return;

}

alert('SUCCESS!! :-)')

}</code></pre>
<h4 id="custom-validator-for-reactive-forms"><strong>反应式表单的自定义验证器</strong></h4>
<p>功能:</p>
<pre class="language-javascript"><code>validateUrl(control: AbstractControl) {

if (!control.value || control.value.includes('.png') || control.value.includes('.jpg')) {

return null;

}

return { validUrl: true };

}</code></pre>
<p>用法:</p>
<pre class="language-javascript"><code>this.secondFormGroup = this._formBuilder.group({

imageCtrl: ['', [Validators.required, this.validateUrl]]

});</code></pre>
<p>多字段验证:</p>
<pre class="language-javascript"><code>validateNameShire(group: FormGroup) {

if (group) {

if (group.get('isShireCtrl').value &amp;&amp; !group.get('nameCtrl').value.toString().toLowerCase().includes('shire')) {

return { nameShire : true };

}

}

return null;

 }</code></pre>
<p>多字段验证用法:*</p>
<pre class="language-javascript"><code>this.firstFormGroup.setValidators(this.validateNameShire);</code></pre>
<p>错误处理:</p>
<pre class="language-javascript"><code>&lt;div *ngIf="firstFormGroup.controls.nameCtrl.errors.maxlength"&gt;Name is too long&lt;/div&gt;

&lt;div *ngIf="firstFormGroup.errors.nameShire"&gt;Shire dogs should have "shire" in name&lt;/div&gt;</code></pre>
<h4 id="custom-validator-directive-for-template-driven-forms"><strong>模板驱动表单的自定义验证器指令</strong></h4>
<p>简而言之，我们将介绍如何向NG_VALIDATORS服务注册我们的自定义验证指令。由于多参数，我们不会覆盖NG_VALIDATORS，而只是将CustomValidator添加到NG_VALIDATORS中。</p>
<p>这是你用的:</p>
<pre class="language-javascript"><code>@Directive({

selector: '[CustomValidator]',

providers: [{provide: NG_VALIDATORS, useExisting: CustomValidator, multi:true}]

})</code></pre>
<p>示例:</p>
<pre class="language-javascript"><code>@Directive({

selector: '[customValidation]',

providers: [{provide: NG_VALIDATORS, useExisting: EmailValidationDirective, multi: true}]

})

export class CustomValidation implements Validator {

constructor() { }

validate(control: AbstractControl): ValidationErrors {

return (control.value &amp;&amp; control.value.length &lt;= 300) ? 

{myValue : true } : null;

}

}

For multiple fields:

validate(formGroup: FormGroup): ValidationErrors {

const passwordControl = formGroup.controls["password"];

const emailControl = formGroup.controls["login"];

if (!passwordControl || !emailControl || !passwordControl.value || !emailControl.value) {

return null;

}

if (passwordControl.value.length &gt; emailControl.value.length) {

passwordControl.setErrors({ tooLong: true });

} else {

passwordControl.setErrors(null);

}

return formGroup;

}</code></pre>
<h4 id="ngmodel-in-custom-component"><strong>自定义组件中的ng model</strong></h4>
<p>添加到模块:</p>
<pre class="language-javascript"><code>providers: [

{

provide: NG_VALUE_ACCESSOR,

useExisting: forwardRef(() =&gt; TextAreaComponent),

multi: true

}

]

Implement ControlValueAccessor interface

interface ControlValueAccessor {

writeValue(obj: any): void

registerOnChange(fn: any): void

registerOnTouched(fn: any): void

setDisabledState(isDisabled: boolean)?: void

}</code></pre>
<p>寄存器交换</p>
<p>注册一个函数，告知Angular输入值何时改变。</p>
<p><strong>注册户口〔t1〕</strong></p>
<p>注册一个函数，告诉Angular值何时被触摸。</p>
<p><strong>写值</strong></p>
<p>告诉Angular如何将值写入输入。</p>
<p>示例实现:</p>
<pre class="language-javascript"><code>@Component({

selector: 'app-text-area',

templateUrl: './text-area.component.html',

styleUrls: ['./text-area.component.less'],

providers: [

{

provide: NG_VALUE_ACCESSOR,

useExisting: forwardRef(() =&gt; TextAreaComponent),

multi: true

}

]

})

export class TextAreaComponent implements ControlValueAccessor, OnInit {

@Input() value: string;

private _onChange = (data: any) =&gt; { console.log('changed: ' + data); };

private _onTouched = (data?: any) =&gt; {console.log('touched: ' + data); };

ngOnInit(): void {

const self = this;

}

constructor() {}

writeValue(obj: any): void {

this.value = obj;

}

registerOnChange(fn) {

this._onChange = fn;

}

registerOnTouched(fn: any): void {

this._onTouched = fn;

}

}</code></pre>
<h3 id="tests"><strong>测试</strong></h3>
<p>开发中的每个软件应用程序都需要测试以验证其正确性，Angular应用程序也是如此。测试意味着对应用程序执行各种测试或测试用例，以验证其功能和正确性。</p>
<h3 id="unit-tests">单元测试</h3>
<p>一般来说，单元测试是一种软件测试级别，它分别检查应用程序的各个组件。在Angular中，默认的单元测试框架是Jasmine。在使用CLI开发Angular项目时，它被广泛使用。</p>
<p>服务:</p>
<pre class="language-javascript"><code>describe('MyService', () =&gt; {

let service: MyService;

beforeEach(() =&gt; service = new MyService();

it('#fetch should update data', () =&gt; {

service.fetchData();

expect(service.data.length).toBe(4);

expect(service.data[0].id).toBe(1);

});

});</code></pre>
<p>对于异步功能:</p>
<pre class="language-markup"><code>it('#fetch should update data', (done: DoneFn) =&gt; {

// some code

done(); // we need 'done' to avoid test finishing before date was received

// some code

});</code></pre>
<p>异步测试示例:</p>
<pre class="language-javascript"><code>it('http client works', (done: DoneFn) =&gt; {

service.getUser().subscribe((data) =&gt; {

expect(data).toBe('test');

done();

});

 });</code></pre>
<h3 id="spy-and-stub">间谍和存根</h3>
<p>当您在测试过程中进行呼叫时，存根会提供所有这些呼叫的固定答案。它不响应被测程序之外的任何东西。</p>
<p>spy是一个存根，它根据您在测试期间拨打的电话记录信息。</p>
<p><strong>间谍:</strong></p>
<pre class="language-javascript"><code>// create spied object by copy getDataAsync from HttpService

const valueServiceSpy =

jasmine.createSpyObj('HttpService', ['getDataAsync']);</code></pre>
<p><strong>存根:</strong></p>
<pre class="language-javascript"><code>const stubValue = of('StubValue');

valueServiceSpy.getDataAsync.and.returnValue(stubValue);</code></pre>
<p>单元测试的试验台模拟整个模块/环境:</p>
<pre class="language-javascript"><code>beforeEach(() =&gt; {

let httpClientMock = TestBed.configureTestingModule({ providers: [{ provide: MyService, useValue: new MyService(httpClientMock)}] });

});</code></pre>
<p>然后像这样使用测试对象(例如服务):</p>
<pre class="language-javascript"><code>service = TestBed.get(MyService);</code></pre>
<p>我们可以添加模式:[NO_ERRORS_SCHEMA]。这意味着我们不必模仿这个组件的子组件依赖，因为Angular不会因为我们不包含它们而大喊大叫！</p>
<h3 id="miscellaneous"><strong>杂项</strong></h3>
<h3 id="http-interceptor">Http拦截器</h3>
<p>HTTP拦截器可以处理任何给定的HTTP请求。</p>
<p>类别:</p>
<pre class="language-javascript"><code>@Injectable()

export class MyInterceptor implements HttpInterceptor {

constructor() { }

intercept(request: HttpRequest, next: HttpHandler): Observable&gt; {

// do sth (like check and throw error)

return next.handle(request); //if want continue

}

}</code></pre>
<p>参数:</p>
<ol>
<li>req:http request<any>——它是处理传出请求的对象。</any></li>
<li>下一个:HttpHandler——它表示行中的下一个拦截器，或者在没有拦截器的情况下表示后端。</li>
</ol>
<p>退货:</p>
<p>HTTP拦截器返回事件流的可观察对象。</p>
<p>可观察的<httpevent>&gt;</httpevent></p>
<h2 id="conclusion"><strong>结论</strong></h2>
<p>这里我们已经到了角度备忘单的末尾。我们讨论了各种领域，如表单、管道、指令、路由等。以及它们的用法和例子。</p>
<p>Web开发工作大部分时间都很漫长，所以快速参考Angular命令和语法大有帮助。</p>
<p>有兴趣查找更多参考资料以加快您的工作吗？尝试另一个备忘单！</p>
<p><a class="btn btn-primary btn-call-to-action " href="https://hackr.io/blog/javascript-cheat-sheet">探索JavaScript备忘单</a></p>
<h2 id="frequently-asked-questions"><strong>常见问题解答</strong></h2>
<h4 id="toc-1-what-is-the-angular-cheat-sheet"><strong> 1。什么是有棱角的小抄？</strong></h4>
<p>Angular cheat sheet是一套简短的笔记，涵盖了从管道到指令的所有Angular主题，可以方便地快速参考。</p>
<h4 id="toc-2-what-are-components-in-angular"><strong> 2。Angular中的分量是什么？</strong></h4>
<p>角度组件是任何角度应用的最基本构件。</p>
<h4 id="toc-3-what-is-a-question-mark-in-angular"><strong> 3。Angular中的问号是什么？</strong></h4>
<p>角形问号指的是“安全导航操作员”它确保当我们试图访问一个对象的属性时，在角度应用程序中没有空值或未定义的值。</p>
<h4 id="toc-4-what-is-ng-in-angular"><strong> 4。Angular中的Ng是什么？</strong></h4>
<p>在Angular中，“ng”是Angular附带的所有内置指令的前缀。</p>

									</div>

									</div>    
</body>
</html>