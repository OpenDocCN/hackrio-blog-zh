<html>
<head>
<title>Normalization in DBMS: 1NF, 2NF, 3NF, and BCNF [Examples]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>DBMS中的规范化:1NF、2NF、3NF和BCNF[示例]</h1>
<blockquote>原文：<a href="https://hackr.io/blog/dbms-normalization#0001-01-01">https://hackr.io/blog/dbms-normalization#0001-01-01</a></blockquote><div><div class="content">
										<p>当开发关系数据库的模式时，要考虑的最重要的方面之一是确保数据的重复最小化。我们通过执行数据库规范化来做到这一点，这是数据库模式设计过程的一个重要部分。</p>
<p>这里，我们解释DBMS中的规范化，解释1NF、2NF、3NF和BCNF，并附有解释。首先，让我们看看什么是规范化，为什么它很重要。</p>
<h2 id="what-is-normalization-in-dbms"><strong>什么是数据库管理系统中的规范化？</strong></h2>
<p>数据库规范化是一种帮助以最佳方式设计数据库模式的技术。数据库规范化的核心思想是将表分成更小的子表，并存储指向数据的指针，而不是复制数据。</p>
<h3 id="why-do-we-carry-out-database-normalization"><strong>我们为什么要进行数据库规范化？</strong></h3>
<p><strong><img src="../Images/8b8801ef8654e6cfd3142d2dcf651c2b.png" alt="Types of Normal Form" data-original-src="https://hackr.io/blog/media/types-of-normal-form.png"/>T2】</strong></p>

<p>使用数据库规范化有两个主要原因。首先，它有助于减少存储数据所需的存储量。其次，它防止了由于相同数据的多个副本的存在而可能出现的数据冲突。</p>
<p>如果一个数据库没有被规范化，那么它会导致效率更低，通常更慢的系统，甚至可能导致不准确的数据。这也可能会导致磁盘I/O使用率过高和性能下降。</p>
<h2 id="what-is-a-key"><strong>什么是钥匙？</strong></h2>
<p>你也应该知道什么是键。键是帮助识别表中某一行的属性。有七种不同的类型，您将会在各种标准化的解释中看到它们的使用:</p>
<ul>
<li aria-level="1">候选关键字</li>
<li aria-level="1">主关键字</li>
<li aria-level="1">外键</li>
<li aria-level="1">超级键</li>
<li aria-level="1">备用关键字</li>
<li aria-level="1">复合键</li>
<li aria-level="1">唯一键</li>
</ul>
<h2 id="database-normalization-example"><strong>数据库规范化示例</strong></h2>
<p>为了理解示例表的(DBMS)规范化，让我们假设我们正在存储一所大学的课程和教师的详细信息。下面是一个示例数据库的样子:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>课程代码</strong></p>
</td>
<td>
<p><strong>课程地点</strong></p>
</td>
<td>
<p><strong>讲师姓名</strong></p>
</td>
<td>
<p><strong>讲师的电话号码</strong></p>
</td>
</tr>
<tr>
<td>
<p>CS101</p>
</td>
<td>
<p>20号报告厅</p>
</td>
<td>
<p>乔治教授</p>
</td>
<td>
<p>+1 6514821924</p>
</td>
</tr>
<tr>
<td>
<p>CS152</p>
</td>
<td>
<p>21号演讲厅</p>
</td>
<td>
<p>阿特金斯教授</p>
</td>
<td>
<p>+1 6519272918</p>
</td>
</tr>
<tr>
<td>
<p>CS154</p>
</td>
<td>
<p>政务司司长礼堂</p>
</td>
<td>
<p>乔治教授</p>
</td>
<td>
<p>+1 6514821924</p>
</td>
</tr>
</tbody>
</table>
<p>在这里，数据基本上存储了课程代码、课程地点、讲师姓名和讲师电话号码。乍一看，这个设计似乎不错。然而，一旦我们需要修改信息，问题就开始出现了。例如，假设，如果乔治教授改变了他的手机号码。在这种情况下，我们必须在两个地方进行编辑。</p>
<p>如果有人刚针对CS101编辑了手机号，却忘了针对CS154编辑呢？这将导致数据库中的信息陈旧/错误。这个问题可以通过将我们的表分成两个更简单的表来轻松解决:</p>

<p><strong>表1(讲师):</strong></p>
<ul>
<li aria-level="1">讲师ID</li>
<li aria-level="1">讲师姓名</li>
<li aria-level="1">教师手机号码</li>
</ul>
<p><strong>表2(课程):</strong></p>
<ul>
<li aria-level="1">课程代码</li>
<li aria-level="1">课程地点</li>
<li aria-level="1">讲师ID</li>
</ul>
<p>现在，我们的数据将如下所示:</p>
<p><strong>表1(讲师):</strong></p>
<table>
<tbody>
<tr>
<td>
<p><strong>教师ID </strong></p>
</td>
<td>
<p><strong>教师姓名</strong></p>
</td>
<td>
<p><strong>教师编号</strong></p>
</td>
</tr>
<tr>
<td>
<p>一</p>
</td>
<td>
<p>乔治教授</p>
</td>
<td>
<p>+1 6514821924</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>阿特金斯教授</p>
</td>
<td>
<p>+1 6519272918</p>
</td>
</tr>
</tbody>
</table>
<p><strong>表2(课程):</strong></p>
<table>
<tbody>
<tr>
<td>
<p><strong>课程代码</strong></p>
</td>
<td>
<p><strong>课程地点</strong></p>
</td>
<td>
<p><strong>讲师ID </strong></p>
</td>
</tr>
<tr>
<td>
<p>CS101</p>
</td>
<td>
<p>20号报告厅</p>
</td>
<td>
<p>一</p>
</td>
</tr>
<tr>
<td>
<p>CS152</p>
</td>
<td>
<p>21号演讲厅</p>
</td>
<td>
<p>2</p>
</td>
</tr>
<tr>
<td>
<p>CS154</p>
</td>
<td>
<p>政务司司长礼堂</p>
</td>
<td>
<p>一</p>
</td>
</tr>
</tbody>
</table>
<p>基本上，我们单独存储教师，在课程表中，我们不存储教师的全部数据。相反，我们存储教师的ID。现在，如果有人想知道教练的手机号码，他们可以简单地查找教练表。此外，如果我们要更改乔治教授的手机号码，可以在一个地方完成。这避免了陈旧/错误的数据问题。</p>
<p>此外，如果你观察，手机号码现在不需要存储2次。我们把它存放在一个地方。这也节省了存储空间。这在上面的简单例子中可能并不明显。然而，请考虑这样一种情况，当有数百个课程和教师时，对于每个教师，我们不仅要存储手机号码，还要存储其他详细信息，如办公室地址、电子邮件地址、专业、可用性等。在这种情况下，复制如此多的数据会不必要地增加存储需求。</p>
<p><strong>建议课程</strong></p>
<p><a class="btn btn-primary btn-call-to-action " href="https://click.linksynergy.com/deeplink?id=jU79Zysihs4&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Frelational-database-management-systemrdbms-complete-pack%2F" target="_blank" rel="noopener">数据库管理系统&amp; SQL:完成打包2023 </a></p>
<h2 id="types-of-dbms-normalization"><strong>数据库管理系统规范化的类型</strong></h2>
<p>DBMS中有各种范式。每个范式都有一个重要性，它有助于优化数据库以节省存储和减少冗余。我们用下面的例子解释DBMS中的规范化。</p>
<h3 id="first-normal-form-1nf"><strong>第一范式(1NF) </strong></h3>
<p>第一种范式简单地说，表格的每个单元格应该只包含一个值。假设我们正在存储某个特定讲师所学的课程，我们可以这样存储:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>教师姓名</strong></p>
</td>
<td>
<p><strong>课程代码</strong></p>
</td>
</tr>
<tr>
<td>
<p>乔治教授</p>
</td>
<td>
<p>(CS101、CS154)</p>
</td>
</tr>
<tr>
<td>
<p>阿特金斯教授</p>
</td>
<td>
<p>(CS152)</p>
</td>
</tr>
</tbody>
</table>
<p>这里的问题是，在第一行中，我们存储了针对George教授的两门课程。这不是最佳的方式，因为这就是现在设计的SQL数据库的使用方式。更好的方法是将课程分开存储。例如:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>教师姓名</strong></p>
</td>
<td>
<p><strong>课程代码</strong></p>
</td>
</tr>
<tr>
<td>
<p>乔治教授</p>
</td>
<td>
<p>CS101</p>
</td>
</tr>
<tr>
<td>
<p>乔治教授</p>
</td>
<td>
<p>CS154</p>
</td>
</tr>
<tr>
<td>
<p>阿特金斯教授</p>
</td>
<td>
<p>CS152</p>
</td>
</tr>
</tbody>
</table>
<p>这样，如果我们想要编辑一些与CS101相关的信息，我们就不必接触与CS154相对应的数据。另外，注意每一行都存储唯一的信息。没有重复。这是第一范式。</p>
<p>1NF中的数据冗余更高，因为在多行中有多个相同的列。1NF更注重消除重复组，而不是消除冗余。</p>
<h3 id="second-normal-form-2nf"><strong>第二范式(2NF) </strong></h3>
<p>对于处于第二范式的表，必须满足以下两个条件:</p>
<ol>
<li aria-level="1">该表应为第一范式。</li>
<li aria-level="1">表的主键应该只有一列。</li>
</ol>
<p>第一点显然很简单，因为我们刚刚研究了1NF。让我们理解第二点:1列主键。主键是唯一标识一行的一组列。这里，没有两行具有相同的主键。</p>
<table>
<tbody>
<tr>
<td>
<p><strong>课程代码</strong></p>
</td>
<td>
<p><strong>课程地点</strong></p>
</td>
<td>
<p><strong>讲师姓名</strong></p>
</td>
<td>
<p><strong>讲师的电话号码</strong></p>
</td>
</tr>
<tr>
<td>
<p>CS101</p>
</td>
<td>
<p>20号报告厅</p>
</td>
<td>
<p>乔治教授</p>
</td>
<td>
<p>+1 6514821924</p>
</td>
</tr>
<tr>
<td>
<p>CS152</p>
</td>
<td>
<p>21号演讲厅</p>
</td>
<td>
<p>阿特金斯教授</p>
</td>
<td>
<p>+1 6519272918</p>
</td>
</tr>
<tr>
<td>
<p>CS154</p>
</td>
<td>
<p>政务司司长礼堂</p>
</td>
<td>
<p>乔治教授</p>
</td>
<td>
<p>+1 6514821924</p>
</td>
</tr>
</tbody>
</table>
<p>在这个表中，课程代码是唯一的，因此它成为我们的主键。让我们再举一个存储各种课程的学生注册的例子。每个学生可以注册多门课程。同样，每门课程可能有多个注册。示例表可能如下所示(学生姓名和课程代码):</p>
<table>
<tbody>
<tr>
<td>
<p><strong>学生姓名</strong></p>
</td>
<td>
<p><strong>课程代码</strong></p>
</td>
</tr>
<tr>
<td>
<p>拉胡尔</p>
</td>
<td>
<p>CS152</p>
</td>
</tr>
<tr>
<td>
<p>拉杰特</p>
</td>
<td>
<p>CS101</p>
</td>
</tr>
<tr>
<td>
<p>拉胡尔</p>
</td>
<td>
<p>CS154</p>
</td>
</tr>
<tr>
<td>
<p>拉曼</p>
</td>
<td>
<p>CS101</p>
</td>
</tr>
</tbody>
</table>
<p>这里，第一列是学生姓名，第二列是学生所学的课程。</p>
<p>显然，学生姓名列不是唯一的，因为我们可以看到在第1行和第3行中有2个条目对应于姓名“Rahul”。类似地，课程代码列不是唯一的，因为我们可以看到在第2行和第4行中有2个条目对应于课程代码CS101。</p>
<p>但是，元组(学生姓名、课程代码)是唯一的，因为学生不能多次注册同一门课程。因此，这两列组合起来就形成了数据库的主键。</p>
<p>根据第二范式定义，我们上面的注册表不在第二范式中。为了达到同样的效果(1NF至2NF)，我们可以将其分为两个表:</p>
<p><strong>学生:</strong></p>
<table>
<tbody>
<tr>
<td>
<p><strong>学生姓名</strong></p>
</td>
<td>
<p><strong>报名人数</strong></p>
</td>
</tr>
<tr>
<td>
<p>拉胡尔</p>
</td>
<td>
<p>一</p>
</td>
</tr>
<tr>
<td>
<p>拉杰特</p>
</td>
<td>
<p>2</p>
</td>
</tr>
<tr>
<td>
<p>拉曼</p>
</td>
<td>
<p>3</p>
</td>
</tr>
</tbody>
</table>
<p>这里第二列是唯一的，它表示学生的注册号码。显然，注册号码是唯一的。现在，我们可以将这些注册号码与课程代码联系起来。</p>
<p><strong>课程:</strong></p>
<table>
<tbody>
<tr>
<td>
<p><strong>课程代码</strong></p>
</td>
<td>
<p><strong>报名人数</strong></p>
</td>
</tr>
<tr>
<td>
<p>CS101</p>
</td>
<td>
<p>2</p>
</td>
</tr>
<tr>
<td>
<p>CS101</p>
</td>
<td>
<p>3</p>
</td>
</tr>
<tr>
<td>
<p>CS152</p>
</td>
<td>
<p>一</p>
</td>
</tr>
<tr>
<td>
<p>CS154</p>
</td>
<td>
<p>一</p>
</td>
</tr>
</tbody>
</table>
<p>这两个表一起为我们提供了与原始表完全相同的信息。</p>
<h3 id="third-normal-form-3nf">第三范式(3NF)</h3>
<p>在我们深入研究第三范式的细节之前，让我们了解一下表的函数依赖的概念。</p>

<p>如果更改A的值可能需要更改B的值，则称A列在功能上依赖于B列。例如，考虑下表:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>课程代码</strong></p>
</td>
<td>
<p><strong>课程地点</strong></p>
</td>
<td>
<p><strong>教师姓名</strong></p>
</td>
<td>
<p><strong>部门</strong></p>
</td>
</tr>
<tr>
<td>
<p>MA214</p>
</td>
<td>
<p>18号演讲厅</p>
</td>
<td>
<p>乔治教授</p>
</td>
<td>
<p>计算机科学系</p>
</td>
</tr>
<tr>
<td>
<p>ME112</p>
</td>
<td>
<p>礼堂建筑</p>
</td>
<td>
<p>约翰教授</p>
</td>
<td>
<p>电子系</p>
</td>
</tr>
</tbody>
</table>
<p>在这里，department列依赖于professor name列。这是因为如果在一个特定的行中，我们改变了教授的名字，我们也必须改变department值。例如，假设MA214现在由恰好来自数学系的Ronald教授负责，则表格将如下所示:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>课程代码</strong></p>
</td>
<td>
<p><strong>课程地点</strong></p>
</td>
<td>
<p><strong>教师姓名</strong></p>
</td>
<td>
<p><strong>部门</strong></p>
</td>
</tr>
<tr>
<td>
<p>MA214</p>
</td>
<td>
<p>18号演讲厅</p>
</td>
<td>
<p>罗纳德教授</p>
</td>
<td>
<p>数学系</p>
</td>
</tr>
<tr>
<td>
<p>ME112</p>
</td>
<td>
<p>礼堂建筑</p>
</td>
<td>
<p>约翰教授</p>
</td>
<td>
<p>电子系</p>
</td>
</tr>
</tbody>
</table>
<p>在这里，当我们改变教授的名字时，我们也必须改变系栏。这是不希望的，因为更新数据库的人可能记得更改教授的姓名，但可能忘记更新部门值。这可能会导致数据库不一致。</p>
<p>第三范式通过将它分解成单独的表来避免这种情况:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>课程代码</strong></p>
</td>
<td>
<p><strong>课程地点</strong></p>
</td>
<td>
<p><strong>教师ID </strong></p>
</td>
</tr>
<tr>
<td>
<p>MA214</p>
</td>
<td>
<p>18号演讲厅</p>
</td>
<td>
<p>一</p>
</td>
</tr>
<tr>
<td>
<p>ME112</p>
</td>
<td>
<p>礼堂大楼，</p>
</td>
<td>
<p>2</p>
</td>
</tr>
</tbody>
</table>
<p>在这里，第三列是正在上课的教授的ID。</p>
<table>
<tbody>
<tr>
<td>
<p><strong>教师ID </strong></p>
</td>
<td>
<p><strong>教师姓名</strong></p>
</td>
<td>
<p><strong>部门</strong></p>
</td>
</tr>
<tr>
<td>
<p>一</p>
</td>
<td>
<p>罗纳德教授</p>
</td>
<td>
<p>数学系</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>约翰教授</p>
</td>
<td>
<p>电子系</p>
</td>
</tr>
</tbody>
</table>
<p>在上面的表格中，我们根据教授的ID存储了他/她的详细信息。这样，每当我们想在某个地方引用教授时，我们就不必再将教授的其他详细信息放在那个表中。我们可以简单地使用ID。</p>
<p>因此，在第三范式中，需要以下条件:</p>
<ul>
<li aria-level="1">该表应为第二范式。</li>
<li aria-level="1">不应该有任何功能依赖。</li>
</ul>
<h3 id="boyce-codd-normal-form-bcnf">博伊斯-科德范式(BCNF)</h3>
<p>Boyce-Codd范式是第三范式的更强推广。当且仅当每个函数相关性A → B至少满足下列条件之一时，表才是Boyce-Codd范式:</p>
<ul>
<li aria-level="1">a是一个超级键</li>
<li aria-level="1">这是一个微不足道的函数依赖。</li>
</ul>
<p>让我们先了解一下超级键是什么意思。要了解DBMS中的BCNF，请考虑以下BCNF示例表:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>课程代码</strong></p>
</td>
<td>
<p><strong>课程地点</strong></p>
</td>
<td>
<p><strong>讲师姓名</strong></p>
</td>
<td>
<p><strong>讲师的电话号码</strong></p>
</td>
</tr>
<tr>
<td>
<p>CS101</p>
</td>
<td>
<p>20号报告厅</p>
</td>
<td>
<p>乔治教授</p>
</td>
<td>
<p>+1 6514821924</p>
</td>
</tr>
<tr>
<td>
<p>CS152</p>
</td>
<td>
<p>21号演讲厅</p>
</td>
<td>
<p>阿特金斯教授</p>
</td>
<td>
<p>+1 6519272918</p>
</td>
</tr>
<tr>
<td>
<p>CS154</p>
</td>
<td>
<p>政务司司长礼堂</p>
</td>
<td>
<p>乔治教授</p>
</td>
<td>
<p>+1 6514821924</p>
</td>
</tr>
</tbody>
</table>
<p>这里，第一列(课程代码)在各行中是唯一的。所以，这是一个超级键。考虑列的组合(课程代码，教授姓名)。它在各行之间也是唯一的。所以，它也是一个超级键。超级键基本上是一组列，这组列的值在不同的行中是唯一的。也就是说，没有任何两行的这些列具有相同的一组值。上表中的一些超级键是:</p>

<ul>
<li aria-level="1">课程代码</li>
<li aria-level="1">课程代码、教授姓名</li>
<li aria-level="1">课程代码，教授手机号码</li>
</ul>
<p>大小(列数)最小的超键称为候选键。例如，上面的第一个超级键只有一列。第二个和最后一个有2列。所以，第一个超级键(课程代码)是一个候选键。</p>

<p>Boyce-Codd范式说，如果有一个函数依赖A → B，那么要么A是一个超键，要么它是一个平凡的函数依赖。平凡函数依赖意味着B的所有列都包含在a的列中。例如，(课程代码，教授姓名)→(课程代码)是平凡函数依赖，因为当我们知道课程代码和教授姓名的值时，我们确实知道课程代码的值，所以依赖变得平凡。</p>
<p><strong>让我们明白是怎么回事:</strong></p>
<p>A是一个超级键:这意味着只有在一个超级键列上，才会存在对其他列的依赖。基本上，如果一组列(B)可以在已知另一组列(A)的情况下确定，那么A应该是一个超键。Superkey基本上唯一地确定每一行。</p>
<p><strong>是平凡的函数依赖:</strong>这意味着不应该有非平凡的依赖。例如，我们看到教授的系是如何依赖于教授的名字的。这可能会造成诚信问题，因为有人可能会编辑教授的名字，而不改变部门。这可能会导致数据库不一致。</p>
<p>另一个例子是，如果一家公司有员工在多个部门工作。相应的数据库可以分解成，其中函数依赖关系可以是诸如雇员ID和雇员部门这样的键。</p>
<h3 id="fourth-normal-form"><strong>第四范式</strong></h3>
<p>如果没有两个或两个以上独立的多值数据描述相关实体，则称一个表为第四范式。</p>
<h3 id="fifth-normal-form"><strong>第五范式</strong></h3>
<p>一个表是第五范式的，如果:</p>
<ul>
<li aria-level="1">这是它的第四范式。</li>
<li aria-level="1">它不能被细分成任何更小的表而不丢失某种形式的信息。</li>
</ul>
<h2 id="normalization-is-important-for-database-systems"><strong>规范化对数据库系统很重要</strong></h2>
<p>DBMS中的规范化对于设计数据库模式很有用，这样就不会有可能导致不一致的数据复制。在设计应用程序的模式时，我们应该总是考虑如何利用这些形式。</p>
<p>如果您想<a href="https://hackr.io/blog/how-to-learn-sql">了解更多关于SQL </a>的知识，请查看我们关于<a href="https://hackr.io/blog/sql-certifications">最佳SQL认证</a>的帖子。你也可以阅读<a href="https://hackr.io/blog/sql-vs-mysql"> SQL vs MySQL </a>来了解这两者是什么。要成为一名数据工程师，你需要学习标准化和更多，所以今天就开始吧。</p>
<h2 id="frequently-asked-questions"><strong>常见问题解答</strong></h2>
<h4 id="toc-1-does-database-normalization-reduce-the-database-size"><strong> 1。数据库规范化会减小数据库大小吗？</strong></h4>
<p>是的，数据库规范化确实减小了数据库的大小。冗余数据被删除，因此数据库磁盘存储使用变得更小。</p>

<h4 id="toc-2-which-normal-form-can-remove-all-the-anomalies-in-dbms"><strong> 2。哪种范式可以去除DBMS中的所有异常？</strong></h4>
<p>5NF将移除所有异常。然而，一般来说，大多数3NF表不会出现异常。</p>

<h4 id="toc-3-can-database-normalization-reduce-the-number-of-tables"><strong> 3。数据库规范化可以减少表的数量吗？</strong></h4>
<p>数据库规范化增加了表的数量。这是因为我们将表拆分成子表，以消除冗余数据。</p>
<h4 id="toc-4-what-is-the-difference-between-bcnf-and-3nf"><strong> 4。BCNF和3NF有什么区别？</strong></h4>
<p>BCNF是3NF的延伸。主要区别在于它从关系中移除了传递依赖。</p>
<p><strong>人也在读:</strong></p>


									</div>

									</div>    
</body>
</html>