<html>
<head>
<title>Download XPath Cheat Sheet PDF for Quick References</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>下载XPath备忘单PDF作为快速参考</h1>
<blockquote>原文：<a href="https://hackr.io/blog/xpath-cheat-sheet#0001-01-01">https://hackr.io/blog/xpath-cheat-sheet#0001-01-01</a></blockquote><div><div class="content">
										<p>Selenium框架帮助我们与DOM(文档对象模型)中的WebElements进行交互。但是，您需要网络定位器才能继续。幸运的是，市面上有很多Selenium web定位器。您可能渴望一个Selenium locators备忘单来帮助您。唯一的问题是:对于与<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener"> DOM </a>中的WebElements的最佳交互，哪一个是正确的？</p>
<p>Selenium为web定位器提供了广泛的选项，比如ID、名称、XPath、LinkText和标记名。</p>
<p>XPath是最常用的方法之一。XPath或XML路径语言是一种表达式语言，支持XML文档的查询或转换。它可以很容易地遍历DOM元素和属性。</p>
<p>如果您计划使用XPath web定位器来创建测试自动化脚本，那么这个XPath备忘单就是为您准备的。我们的Selenium XPath备忘单将帮助您学习和记住XPath语法、表达式等等。</p>

<p><a href="https://drive.google.com/file/d/1opAv6PCccceNutM8zfW0Xfc8p6vyu25J/view?usp=sharing" target="_blank" rel="noopener">点击这里</a>下载我们的免费XPath备忘单PDF。</p>
<p>我们开始吧！</p>
<h2 id="xpath-cheat-sheet-for-quick-references">快速参考的XPath备忘单</h2>
<p>当您需要快速浏览XPath语法和XPath定位器的其他方面时，这个XPath备忘单就派上了用场。</p>
<p>首先，让我们探索一下Selenium中XPath web位置的确切含义。</p>
<h3 id="what-is-xpath-web-locator-in-selenium">Selenium中的XPath Web Locator是什么？</h3>
<p>XPath使用类似路径的语法，帮助我们识别和导航XML和HTML文档中的节点。换句话说，它使用非XML语法，这使得它可以灵活地处理XML文档的各个部分。此外，XPath遵循<a href="https://developer.mozilla.org/en-US/docs/Web/XSLT" target="_blank" rel="noopener"> XSLT </a>(可扩展样式表语言转换)标准，该标准通常用于导航web元素和属性。</p>
<p>DOM对于浏览HTML文档是必不可少的。它就像一个包含所有web元素和您正在寻找的元素的地图。您可以使用适当的web定位器从DOM中找到所需的WebElements。</p>

<h3 id="different-types-of-xpath-locators">不同类型的XPath定位器</h3>
<p>有两种方法可以在DOM中定位所需的WebElement。一个是通过绝对路径，另一个是通过相对路径。在XPath备忘单的这一部分，我们将研究使用XPath定位器在DOM中查找所需WebElement的不同方法。</p>
<h4 id="toc-1-absolute-xpath">1.绝对XPath</h4>
<p>绝对路径指定从根元素到要使用的元素的完整路径。但是，使用绝对路径可能会遇到问题。如果在元素的路径中做了任何更改，就会导致XPath失败。</p>
<p>无论何时使用绝对路径，都必须使用单个正斜杠(/)开始XPath。这表明您正在从文档的根节点中选择元素。</p>
<p>语法:</p>
<pre><code>/html/body/div[x]/div[y]/</code></pre>
<p>示例:</p>
<pre><code>/html//div/div/div/div[1]/div/a/img</code></pre>
<p>要定位一个元素，您可以右键单击web元素并单击Inspect。然后您将看到Elements选项卡，您可以在其中编写定位器。在本例中，我们从HTML标记开始，一个接一个地遍历到div，包含的标记一直到最终的img标记。</p>
<p>尽管这看起来很简单，但常见的缺点是，即使DOM结构中很小的变化也会导致几个自动化故障。</p>
<h4 id="toc-2-relative-xpath">2.相对XPath</h4>
<p>与绝对路径不同，相对XPath指的是我们希望在特定位置定位的元素。在这种情况下，元素相对于其实际位置进行定位。</p>
<p>要使用相对路径，必须在开头指定双正斜杠(//)。大多数情况下，相对XPath是Selenium自动化测试的首选。如果页面设计或DOM层次结构有任何变化，现有的XPath选择器不会受到影响。</p>
<p>语法:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1"><pre>//tagname[@attribute='value']</pre></td>
</tr>
</tbody>
</table>
<pre>XPath Syntax</pre>
<p>为了选择HTML文档中的节点，XPath使用以下路径表达式:</p>
<pre><code>XPath=//tagname[@Attribute="Value"]</code></pre>
<p><img title="" src="../Images/8887f5e3d8a38bd1ee53380596fdc1d3.png" alt="" data-original-src="https://hackr.io/blog/media/xpath-syntax-min.png"/></p>
<p>下面是一些在XML文档中选择节点的常用路径表达式:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>表达式/ XPath </strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>结节</p>
</td>
<td colspan="1" rowspan="1">
<p>选择名称为的所有元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/</p>
</td>
<td colspan="1" rowspan="1">
<p>从根节点中选择</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//</p>
</td>
<td colspan="1" rowspan="1">
<p>从当前元素中选择文档中与选择匹配的元素(无论它们在哪里)</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>。</p>
</td>
<td colspan="1" rowspan="1">
<p>选择当前节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>..</p>
</td>
<td colspan="1" rowspan="1">
<p>选择当前节点元素的父元素。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>@</p>
</td>
<td colspan="1" rowspan="1">
<p>选择属性</p>
</td>
</tr>
</tbody>
</table>
<h3 id="xpath-expressions">XPath表达式</h3>
<p>XPath表达式是用于选择一组节点并执行转换的模式。XPath使用路径表达式从XML和HTML文档中选择节点。</p>
<p><strong>语法:</strong></p>
<pre><code>//tagname[@attribute='value']</code></pre>
<p><strong>举例:</strong></p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1"><pre>&lt;?xml version="1.0"standalone="yes"?&gt;<br/>&lt;empinfo&gt;<br/>&lt;employeeid="1"&gt;<br/>&lt;name&gt;Opal Kole&lt;/name&gt;<br/>&lt;designationdiscipline="web"experience="3 year"&gt;Senior Engineer&lt;/designation&gt;<br/>&lt;email&gt;OpalKole@myemail.com&lt;/email&gt;<br/>&lt;/employee&gt;<br/>&lt;employeeid="2"&gt;<br/>&lt;namefrom="CA"&gt;Max Miller&lt;/name&gt;<br/>&lt;designationdiscipline="DBA"experience="2 year"&gt;DBA Engineer&lt;/designation&gt;<br/>&lt;email&gt;maxmiller@email.com&lt;/email&gt;<br/>&lt;/employee&gt;<br/>&lt;employeeid="3"&gt;<br/>&lt;name&gt;Beccaa Moss&lt;/name&gt;<br/>&lt;designationdiscipline="appdev"&gt;Application Developer&lt;/designation&gt;<br/>&lt;email&gt;beccaamoss@email.com&lt;/email&gt;<br/>&lt;/employee&gt;<br/>&lt;/empinfo&gt;</pre></td>
</tr>
</tbody>
</table>
<p>您将在下面找到轴和相应的步骤。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p>轴</p>
</td>
<td colspan="1" rowspan="1">
<p>//</p>
</td>
<td colspan="1" rowspan="1">
<p>/</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>步骤</p>
</td>
<td colspan="1" rowspan="1">
<p>保险商实验所</p>
</td>
<td colspan="1" rowspan="1">
<p>一个[@id='link']</p>
</td>
</tr>
</tbody>
</table>
<h4 id="prefixes-expression">前缀表达式</h4>
<p>我们可以在XPath表达式的开头使用前缀:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>表情</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>例子</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//</p>
</td>
<td colspan="1" rowspan="1">
<p>//p[@class='footer']</p>
</td>
<td colspan="1" rowspan="1">
<p>从DOM中的任意位置选择段落标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/</p>
</td>
<td colspan="1" rowspan="1">
<p>/a</p>
</td>
<td colspan="1" rowspan="1">
<p>从给定节点中查找所有锚(a)标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/</p>
</td>
<td colspan="1" rowspan="1">
<p>/html/body/div</p>
</td>
<td colspan="1" rowspan="1">
<p>从根元素开始查找所有div</p>
</td>
</tr>
</tbody>
</table>
<p>以下是XPath中各种可用步骤的一些示例:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong> XPath </strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//div</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有div标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//[@id=’btn’]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择ID为“btn”的所有元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//div[@name='post']</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有名为“post”的div元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//a/text()</p>
</td>
<td colspan="1" rowspan="1">
<p>给出所有锚定标签的文本</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//a/@href</p>
</td>
<td colspan="1" rowspan="1">
<p>给出定位标记的href值</p>
</td>
</tr>
</tbody>
</table>
<h3 id="need-more-help-checkout-this-course">需要更多帮助吗？检查本课程</h3>
<p><a href="https://imp.i384100.net/qn64Yb" target="_blank" rel="noopener"><img src="../Images/c1b5ca4bb8a0944243f333fc07ca6a25.png" alt="xpath selium" data-original-src="https://hackr.io/blog/media/selium-course.png"/>T2】</a></p>
<h4 id="selecting-nodes">选择节点</h4>
<p>下表包括用于选择节点或WebElements的XPath表达式。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong> XPath </strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>差异</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有div元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/div</p>
</td>
<td colspan="1" rowspan="1">
<p>从根元素中选择div元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>分区/tr</p>
</td>
<td colspan="1" rowspan="1">
<p>选择作为div子元素的所有tr元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//tr</p>
</td>
<td colspan="1" rowspan="1">
<p>选择文档中任意位置的所有tr元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>div//tr</p>
</td>
<td colspan="1" rowspan="1">
<p>在文档中任意位置选择div的所有子元素tr</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//@类</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有类别属性</p>
</td>
</tr>
</tbody>
</table>
<h4 id="predicates-for-finding-nodes">查找节点的谓词</h4>
<p>可以在XPath中使用谓词来定位包含指定值的特定节点。它们被括在方括号中，如下表所示。</p>
<p>这些谓词标识符返回布尔值(真或假)。您甚至可以对它们使用关系运算符和布尔运算符。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong> XPath </strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/div/a[1</p>
</td>
<td colspan="1" rowspan="1">
<p>选择div元素中的第一个定位元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/div/a[last()]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择div元素中的最后一个定位元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/div/a[last()-1]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择div元素中倒数第二个定位元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/div/a[position()&lt;3]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择div元素中的前两个定位元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//a[@class]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有具有类属性的锚元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//a[@class='btn']</p>
</td>
<td colspan="1" rowspan="1">
<p>选择具有类属性和值“btn”的所有锚元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/div/h1[1]a</p>
</td>
<td colspan="1" rowspan="1">
<p>选择h1中作为div元素子元素的所有定位元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/div/h1/a[1]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择div元素中h1子元素的所有锚元素</p>
</td>
</tr>
</tbody>
</table>
<p>例如:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>表情</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>元素名称[N]</p>
</td>
<td colspan="1" rowspan="1">
<p>引用特定元素序列号(数组序列)的左方括号和右方括号。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>员工信息/员工[2]</p>
</td>
<td colspan="1" rowspan="1">
<p>子元素的第二个子元素；</p>
<p>选择empinfo元素的第二个雇员。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>雇员信息/雇员[2]/姓名</p>
</td>
<td colspan="1" rowspan="1">
<p>子元素序列；</p>
<p>选择empinfo元素的第二个employee元素的name元素。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>元素名称[@属性名称]</p>
<p>empinfo/employee[@id]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择具有属性的元素</p>
<p>选择具有给定id属性的所有employee元素。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>元素名称[@属性名称=值]</p>
<p>empinfo/employee[@id=2]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择具有指定属性值的元素；</p>
<p>查找具有给定属性和值的雇员元素。</p>
<p>仅匹配那些其属性和值在XPath表达式中指定的元素。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>empinfo/employee[@id=2][2]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择给定属性和值的所有雇员元素。最后，只选择第二个employee元素。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>empinfo/employee[1][@id=1]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择具有给定属性和值的第一个employee元素。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//称号[@学科和@经验]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择具有给定的第一和第二两个属性的所有指定元素。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//称号[@学科或@经验]</p>
<p>//称号[@学科| @经验]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择具有第一或第二属性的所有指定元素。</p>
</td>
</tr>
</tbody>
</table>
<h4 id="chaining-order">链接顺序</h4>
<p>XPath的含义随着顺序的变化而变化。</p>
<p>例如:</p>

<p>a[1][@href='/']和</p>
<p>a[@href='/'][1]不同。</p>
<h4 id="indexing">索引</h4>
<p>您必须在XPath中使用[]进行索引，其中[]包含一个数字，指定您想要选择的节点。还可以使用XPath中的索引函数，如last()、position()等，来指定元素的索引。</p>
<p>例如:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p>//a[1]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择第一个锚点标记</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//a[last()]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择最后一个锚点标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//ul/li[2]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择第二个li标签(ul标签的子标签)</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//ul/li[position()=2]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择第二个li标签，它是ul标签的子标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//ul/li[position()&gt;1]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择不是ul标签的第一个子标签的li标签</p>
</td>
</tr>
</tbody>
</table>
<h4 id="expressions-for-selecting-unknown-nodes-wildcards">用于选择未知节点的表达式(通配符)</h4>
<p>可以在XPath定位器中使用通配符来查找未知的HTML文档元素。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p>*</p>
</td>
<td colspan="1" rowspan="1">
<p>匹配任何HTML元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>@*</p>
</td>
<td colspan="1" rowspan="1">
<p>匹配元素的任何属性</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>节点()</p>
</td>
<td colspan="1" rowspan="1">
<p>匹配任何类型的元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/div/*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择div元素的所有子元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择HTML文档中的所有元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//a[@*]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择具有任何属性的所有锚元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>。</p>
</td>
<td colspan="1" rowspan="1">
<p>匹配任何HTML元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>..</p>
</td>
<td colspan="1" rowspan="1">
<p>引用父上下文节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/</p>
</td>
<td colspan="1" rowspan="1">
<p>指根节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//</p>
</td>
<td colspan="1" rowspan="1">
<p>引用文档中任意位置的节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>*</p>
</td>
<td colspan="1" rowspan="1">
<p>指上下文节点的所有子元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>|</p>
<p>或者</p>
</td>
<td colspan="1" rowspan="1">
<p>引用OR条件组合表达式第一个表达式或第二个表达式</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>和</p>
</td>
<td colspan="1" rowspan="1">
<p>指一个条件和组合表达式</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>文本()</p>
</td>
<td colspan="1" rowspan="1">
<p>选择当前元素的所有文本节点子元素。</p>
</td>
</tr>
</tbody>
</table>
<h4 id="expressions-for-selecting-several-paths">选择多条路径的表达式</h4>
<p>您可以在XPath表达式中使用“|”运算符来选择多条路径。以下是使用“|”运算符的方法:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p>//div | //a</p>
</td>
<td colspan="1" rowspan="1">
<p>选择HTML文档中的所有div和锚元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//div/h1 | //div/a</p>
</td>
<td colspan="1" rowspan="1">
<p>选择div元素中的所有h1和锚元素</p>
</td>
</tr>
</tbody>
</table>
<p><a class="btn btn-primary btn-call-to-action " href="https://click.linksynergy.com/deeplink?id=jU79Zysihs4&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fxslt-xpath-and-xquery-fundamentals%2F" target="_blank" rel="noopener"> XSLT XPATH和XQuery基础知识</a></p>
<h3 id="xpath-axes">XPath轴</h3>
<p>XPath规范中有13个轴。这些轴表示上下文节点或引用节点之间的关系。XPath中定义了13个轴，使您能够从当前上下文节点或根节点搜索XML文档中的不同节点部分。XPath轴从文档内的上下文节点中选择节点。</p>
<p>轴示例和节点测试</p>
<p>AxesName ::= 'self '</p>

<p>| '孩子'</p>

<p>| '后裔'</p>
<p>| '自己的后代'</p>
<p>| '父级'</p>
<p>| '祖先'</p>
<p>| '祖先或自我'</p>
<p>| '属性'</p>
<p>| '跟随'</p>
<p>| '跟随-同级'</p>
<p>| '在前'</p>
<p>| '前置-同级'</p>

<p>|“命名空间”</p>

<ul>
<li>自身:轴选择上下文节点。</li>
<li>子节点:轴选择上下文节点的子节点。</li>
<li>后代:轴选择上下文节点的所有后代，即任何级别深度的子节点。</li>
<li>descendant-or-self: Axes选择上下文节点的所有后代，任何级别深度的子节点也为自己选择上下文节点。</li>
<li>parent:轴选择上下文节点的父节点。</li>
<li>祖先:轴选择上下文节点的所有父节点，直到根节点。</li>
<li>ancestor-or-self: Axes选择上下文节点的所有父节点，直到根节点。此外，选择上下文节点本身。</li>
<li>属性:轴选择上下文节点的属性。</li>
<li>以下:轴选择上下文节点之后的所有节点，不包括属性节点或名称空间节点。</li>
<li>following-sibling:轴选择上下文节点的所有后续同级。如果上下文节点是空同级节点之后的属性节点或命名空间节点，则选择none。</li>
<li>preceding:轴选择上下文节点之前的所有节点，不包括属性节点或名称空间节点。</li>
<li>previous-sibling:轴选择上下文节点的属性。</li>
<li>名称空间:轴选择上下文节点的所有名称空间节点。</li>
</ul>
<p>语法:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1"><pre>AxesName::node[predicate]</pre></td>
</tr>
</tbody>
</table>
<pre>Where:</pre>
<ul>
<li>谓词指定包含在[]中的节点序列。</li>
<li>轴名和节点由:::分隔。</li>
</ul>
<p>示例:</p>
<pre class="language-markup"><code>&lt;?xml version="1.0"standalone="yes"?&gt;
&lt;empinfo&gt;
&lt;employeeid="1"&gt;
&lt;name&gt;Opal Kole&lt;/name&gt;
&lt;designationdiscipline="web"experience="3 year"&gt;Senior Engineer&lt;/designation&gt;
&lt;email&gt;OpalKole@myemail.com&lt;/email&gt;
&lt;/employee&gt;
&lt;employeeid="2"&gt;
&lt;namefrom="CA"&gt;Max Miller&lt;/name&gt;
&lt;designationdiscipline="DBA"experience="2 year"&gt;DBA Engineer&lt;/designation&gt;
&lt;email&gt;maxmiller@email.com&lt;/email&gt;
&lt;/employee&gt;
&lt;employeeid="3"&gt;
&lt;name&gt;Beccaa Moss&lt;/name&gt;
&lt;designationdiscipline="appdev"&gt;Application Developer&lt;/designation&gt;
&lt;email&gt;beccaamoss@email.com&lt;/email&gt;
&lt;/employee&gt;
&lt;/empinfo&gt;</code></pre>
<h3 id="node-test">节点测试</h3>
<p>节点测试是XPath表达式的一部分，用于在XML文档中查找节点。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>选择轴</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//name/self::*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择名称上下文节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>孩子::*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择上下文节点的所有子节点。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>子::节点()</p>
</td>
<td colspan="1" rowspan="1">
<p>选择上下文节点的所有子节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>子级::empinfo</p>
</td>
<td colspan="1" rowspan="1">
<p>选择empinfo节点的所有子元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//员工/后代::*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择雇员节点的所有后代</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//后代::员工</p>
</td>
<td colspan="1" rowspan="1">
<p>选择上下文节点中employee节点的所有后代。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//员工/后代或自己::*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择employee节点和上下文节点本身的所有后代。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//后代或自身::雇员</p>
</td>
<td colspan="1" rowspan="1">
<p>此轴选择employee节点及其上下文节点本身的所有后代。</p>
</td>
</tr>
</tbody>
</table>
<h4 id="ancestors">祖先</h4>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p>//员工/祖先::*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择employee节点的所有祖先节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//祖先::名称</p>
</td>
<td colspan="1" rowspan="1">
<p>选择上下文节点中名称节点的所有祖先</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//员工/祖先或自己::*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择employee节点的所有祖先和上下文节点本身。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//名称/祖先或自己::雇员</p>
</td>
<td colspan="1" rowspan="1">
<p>使用上下文节点本身选择名称节点的所有祖先</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//名称/父项::*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择名称上下文节点的父节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//姓名/父::员工</p>
</td>
<td colspan="1" rowspan="1">
<p>如果员工节点是上下文节点的父节点，则返回结果节点；否则找不到节点。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//属性::id</p>
</td>
<td colspan="1" rowspan="1">
<p>选择具有id属性的所有节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//属性::*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择具有任何属性的所有节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//员工[@ id = 1]/以下::*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择上下文节点之后的所有节点(及其子节点)</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//employee[@ id = 1]/following-sibling::*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择上下文节点之后的所有同级节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//employee[@id=3]/preceding::*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择上下文节点之前的所有节点(及其子节点)</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//employee[@ id = 3]/preceding-sibling::*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择上下文节点之前的所有同级节点</p>
</td>
</tr>
</tbody>
</table>
<p>例如:</p>
<ol start="1">
<li><?xml version="1.0" standalone="yes"??></li>
<li><empinfo/></li>
<li><employee id="1"/></li>
<li><name>欧泊科尔</name></li>
<li><designation discipline="web" experience="3 year">高级工程师</designation></li>
<li><email>OpalKole@myemail.com</email></li>
<li/>
<li><employee id="2"/></li>
<li>马克斯·米勒</li>
<li><designation discipline="DBA" experience="2 year"> DBA工程师</designation></li>
<li><email>maxmiller@email.com</email></li>
<li/>
<li><employee id="3"/></li>
<li><name> Beccaa Moss </name></li>
<li><designation discipline="appdev">应用开发者</designation></li>
<li><email>beccaamoss@email.com</email></li>
<li/>
<li/>
</ol>
<p>其中:</p>
<ul>
<li>//name/self::*(名称节点值- 4，9，14行号)</li>
<li>子级::* (3到7行、8到12行、13到17行)</li>
<li>child::node() name节点值(4、9、14行)。</li>
<li>child::empinfo 2到18行。</li>
<li>/员工/后代::*4，5，6，9，10，11，14，15，16行</li>
<li>//descendant::employee (3到7，8到12，13到17行。)</li>
<li>//employee/descendant-or-self::*(4，5，6，8，9，10，11，13，14，15，16行。)</li>
<li>//descendant-or-self::employee(3到7，8到12，13到17行。)</li>
<li>//员工/祖先::* (2到18行。)</li>
<li>//ancestor::name(名称节点值(4，9，14行))。</li>
<li>//employee/ancestor-or-self::*(2，3，7，8，12，13，17，18行(4节点选择)。)</li>
<li>//name/ancestor-or-self::employee(3到7，8到12，13到17行(3个节点选择)。)</li>
<li>//名称/父::* (3到7，8到12，13到17行(3节点选择)。)</li>
<li>//name/parent::employee (3到7，8到12，13到17行(3节点选择)。)</li>
<li>//attribute::id (id属性值(3，8，13行)。)</li>
<li>//属性::* (3，5，8，9，10，13，15)</li>
<li>//employee[@ id = 1]/following::*(8到12，9，10，11，13到17，14，15，16行(8节点选择)。)</li>
<li>//employee[@ id = 1]/following-sibling::*(8到12，13到17行(2节点选择)。)</li>
<li>//employee[@ id = 3]/preceding::*(3到7，4，5，6，8到12，9，10，11行(8节点选择)。)</li>
<li>//employee[@ id = 3]/preceding-sibling::*(3到7，8到12行(2节点选择)。)</li>
</ul>
<h3 id="xpath-operators">XPath运算符</h3>
<p>XPath表达式可以返回数字、布尔值(true或false)、节点集(div、a、li)或字符串。可以使用各种运算符来操作XPath表达式返回的值。</p>
<p>以下是XPath表达式中使用的各种运算符:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>操作员</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>|</p>
</td>
<td colspan="1" rowspan="1">
<p>计算两个节点集。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>+</p>
</td>
<td colspan="1" rowspan="1">
<p>加法算子</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>-</p>
</td>
<td colspan="1" rowspan="1">
<p>减法运算符</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>*</p>
</td>
<td colspan="1" rowspan="1">
<p>乘法运算符</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>差异</p>
</td>
<td colspan="1" rowspan="1">
<p>除法算符</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>=</p>
</td>
<td colspan="1" rowspan="1">
<p>相等运算符</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>！=</p>
</td>
<td colspan="1" rowspan="1">
<p>不等运算符</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>&lt;</p>
</td>
<td colspan="1" rowspan="1">
<p>小于运算符</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>&lt;=</p>
</td>
<td colspan="1" rowspan="1">
<p>小于或等于运算符</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>&gt;</p>
</td>
<td colspan="1" rowspan="1">
<p>大于运算符</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>&gt;=</p>
</td>
<td colspan="1" rowspan="1">
<p>大于或等于运算符</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>或者</p>
</td>
<td colspan="1" rowspan="1">
<p>Or运算符</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>和</p>
</td>
<td colspan="1" rowspan="1">
<p>逻辑积算符</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>现代的</p>
</td>
<td colspan="1" rowspan="1">
<p>模数(除法余数)</p>
</td>
</tr>
</tbody>
</table>
<p>下面列出了五种不同类型的XPath运算符:</p>
<ul>
<li>比较运算符</li>
<li>布尔运算符</li>
<li>数字运算符或函数</li>
<li>字符串函数</li>
<li>节点运算符或函数</li>
</ul>
<h4 id="comparison-operators">比较运算符</h4>
<p>比较运算符比较两个不同的值。以下是XPath表达式中使用的各种比较运算符的示例:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>操作员</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>=</p>
</td>
<td colspan="1" rowspan="1">
<p>指定等于</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>！=</p>
</td>
<td colspan="1" rowspan="1">
<p>指定不等于</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>&lt;</p>
</td>
<td colspan="1" rowspan="1">
<p>指定小于</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>&gt;</p>
</td>
<td colspan="1" rowspan="1">
<p>指定大于</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>&lt;=</p>
</td>
<td colspan="1" rowspan="1">
<p>指定小于或等于</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>&gt;=</p>
</td>
<td colspan="1" rowspan="1">
<p>指定大于或等于</p>
</td>
</tr>
</tbody>
</table>
<p>在下面的例子中，我们通过迭代每个雇员来创建一个包含属性id和子元素<firstname>、<lastname>、<nickname>和<salary>的元素表。它检查薪金是否大于(&gt;)25000，然后打印详细信息。</salary></nickname></lastname></firstname></p>
<p>Employee.xml</p>
<pre class="language-markup"><code>&lt;?xml version ="1.0"?&gt;
&lt;?xml-stylesheet type ="text/xsl"href ="employee.xsl"?&gt;
&lt;class&gt;
&lt;employeeid="001"&gt;
&lt;firstname&gt;Abhiram&lt;/firstname&gt;
&lt;lastname&gt;Kushwaha&lt;/lastname&gt;
&lt;nickname&gt;Manoj&lt;/nickname&gt;
&lt;salary&gt;15000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="002"&gt;
&lt;firstname&gt;Akash&lt;/firstname&gt;
&lt;lastname&gt;Singh&lt;/lastname&gt;
&lt;nickname&gt;Bunty&lt;/nickname&gt;
&lt;salary&gt;25000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="003"&gt;
&lt;firstname&gt;Brijesh&lt;/firstname&gt;
&lt;lastname&gt;Kaushik&lt;/lastname&gt;
&lt;nickname&gt;Ballu&lt;/nickname&gt;
&lt;salary&gt;20000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="004"&gt;
&lt;firstname&gt;Zoya&lt;/firstname&gt;
&lt;lastname&gt;Mansoori&lt;/lastname&gt;
&lt;nickname&gt;Sonam&lt;/nickname&gt;
&lt;salary&gt;30000&lt;/salary&gt;
&lt;/employee&gt;
&lt;/class&gt;</code></pre>
<p>雇员. xsl</p>
<pre class="language-markup"><code>&lt;?xml version ="1.0"encoding ="UTF-8"?&gt;
&lt;xsl:stylesheetversion="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:templatematch="/"&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h2&gt;Employee&lt;/h2&gt;
&lt;tableborder="1"&gt;
&lt;trbgcolor="pink"&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;First Name&lt;/th&gt;
&lt;th&gt;Last Name&lt;/th&gt;
&lt;th&gt;Nick Name&lt;/th&gt;
&lt;th&gt;Salary&lt;/th&gt;
&lt;/tr&gt;
&lt;xsl:for-eachselect="class/employee"&gt;
&lt;xsl:iftest="salary &gt; 25000"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;xsl:value-ofselect="@id"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="firstname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="lastname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="nickname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="salary"/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/xsl:if&gt;
&lt;/xsl:for-each&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code></pre>
<pre class="language-markup"><code>&lt;?xml version ="1.0"encoding ="UTF-8"?&gt;
&lt;xsl:stylesheetversion="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:templatematch="/"&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h2&gt;Employee&lt;/h2&gt;
&lt;tableborder="1"&gt;
&lt;trbgcolor="pink"&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;First Name&lt;/th&gt;
&lt;th&gt;Last Name&lt;/th&gt;
&lt;th&gt;Nick Name&lt;/th&gt;
&lt;th&gt;Salary&lt;/th&gt;
&lt;/tr&gt;
&lt;xsl:for-eachselect="class/employee"&gt;
&lt;xsl:iftest="salary &gt; 25000"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;xsl:value-ofselect="@id"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="firstname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="lastname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="nickname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="salary"/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/xsl:if&gt;
&lt;/xsl:for-each&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code></pre>
<h4 id="boolean-operators">布尔运算符</h4>
<p>这种类型的运算符返回true或false作为结果。以下是XPath中不同的布尔运算符:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>操作员</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>和</p>
</td>
<td colspan="1" rowspan="1">
<p>指定的两个条件都必须满足</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>或者</p>
</td>
<td colspan="1" rowspan="1">
<p>指定的任何一个条件都必须满足</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>不是()</p>
</td>
<td colspan="1" rowspan="1">
<p>指定了检查不满足条件的函数</p>
</td>
</tr>
</tbody>
</table>
<p>在这个例子中，我们创建了一个元素表，它包含属性id和子元素<firstname>、<lastname>、<nickname>和<salary>。该示例检查id是001还是003，然后打印详细信息。</salary></nickname></lastname></firstname></p>
<p>Employee.xml</p>
<pre class="language-markup"><code>&lt;?xml version ="1.0"?&gt;
&lt;?xml-stylesheet type ="text/xsl"href ="employee.xsl"?&gt;
&lt;class&gt;
&lt;employeeid="001"&gt;
&lt;firstname&gt;Abhiram&lt;/firstname&gt;
&lt;lastname&gt;Kushwaha&lt;/lastname&gt;
&lt;nickname&gt;Manoj&lt;/nickname&gt;
&lt;salary&gt;15000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="002"&gt;
&lt;firstname&gt;Akash&lt;/firstname&gt;
&lt;lastname&gt;Singh&lt;/lastname&gt;
&lt;nickname&gt;Bunty&lt;/nickname&gt;
&lt;salary&gt;25000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="003"&gt;
&lt;firstname&gt;Brijesh&lt;/firstname&gt;
&lt;lastname&gt;Kaushik&lt;/lastname&gt;
&lt;nickname&gt;Ballu&lt;/nickname&gt;
&lt;salary&gt;20000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="004"&gt;
&lt;firstname&gt;Zoya&lt;/firstname&gt;
&lt;lastname&gt;Mansoori&lt;/lastname&gt;
&lt;nickname&gt;Sonam&lt;/nickname&gt;
&lt;salary&gt;30000&lt;/salary&gt;
&lt;/employee&gt;
&lt;/class&gt;</code></pre>
<p>雇员. xsl</p>
<pre class="language-markup"><code>&lt;?xml version ="1.0"encoding ="UTF-8"?&gt;
&lt;xsl:stylesheetversion="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:templatematch="/"&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h2&gt;Employee&lt;/h2&gt;
&lt;tableborder="1"&gt;
&lt;trbgcolor="pink"&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;First Name&lt;/th&gt;
&lt;th&gt;Last Name&lt;/th&gt;
&lt;th&gt;Nick Name&lt;/th&gt;
&lt;th&gt;Salary&lt;/th&gt;
&lt;/tr&gt;
&lt;xsl:for-eachselect="class/employee[(@id = 001) or ((@id = 003))]"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;xsl:value-ofselect="@id"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="firstname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="lastname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="nickname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="salary"/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/xsl:for-each&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code></pre>
<h4 id="number-operators-and-functions">数字运算符和函数</h4>
<p>下面描述了可以在Xpath表达式中使用的各种数字运算符:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>操作员</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>+</p>
</td>
<td colspan="1" rowspan="1">
<p>加法运算</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>-</p>
</td>
<td colspan="1" rowspan="1">
<p>减法运算</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>*</p>
</td>
<td colspan="1" rowspan="1">
<p>乘法运算</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>差异</p>
</td>
<td colspan="1" rowspan="1">
<p>除法运算</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>现代的</p>
</td>
<td colspan="1" rowspan="1">
<p>模运算</p>
</td>
</tr>
</tbody>
</table>
<p>以下是一些可以在XPath表达式上执行的函数:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>功能</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>天花板()</p>
</td>
<td colspan="1" rowspan="1">
<p>返回大于所提供值的最小整数</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>地板()</p>
</td>
<td colspan="1" rowspan="1">
<p>返回小于所提供值的最大整数</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>圆形()</p>
</td>
<td colspan="1" rowspan="1">
<p>将舍入值返回到最接近的整数</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>总和()</p>
</td>
<td colspan="1" rowspan="1">
<p>返回两个数的和</p>
</td>
</tr>
</tbody>
</table>
<p>在这个例子中，我们创建了一个包含<employee>元素及其属性id和子元素<firstname>、<lastname>、<nickname>和<salary>的表。它计算雇员的工资，然后显示结果。</salary></nickname></lastname></firstname></employee></p>
<p>Employee.xml</p>
<pre class="language-markup"><code>&lt;?xml version ="1.0"?&gt;
&lt;?xml-stylesheet type ="text/xsl"href ="employee.xsl"?&gt;
&lt;class&gt;
&lt;employeeid="001"&gt;
&lt;firstname&gt;Abhiram&lt;/firstname&gt;
&lt;lastname&gt;Kushwaha&lt;/lastname&gt;
&lt;nickname&gt;Manoj&lt;/nickname&gt;
&lt;salary&gt;15000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="002"&gt;
&lt;firstname&gt;Akash&lt;/firstname&gt;
&lt;lastname&gt;Singh&lt;/lastname&gt;
&lt;nickname&gt;Bunty&lt;/nickname&gt;
&lt;salary&gt;25000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="003"&gt;
&lt;firstname&gt;Brijesh&lt;/firstname&gt;
&lt;lastname&gt;Kaushik&lt;/lastname&gt;
&lt;nickname&gt;Ballu&lt;/nickname&gt;
&lt;salary&gt;20000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="004"&gt;
&lt;firstname&gt;Zoya&lt;/firstname&gt;
&lt;lastname&gt;Mansoori&lt;/lastname&gt;
&lt;nickname&gt;Sonam&lt;/nickname&gt;
&lt;salary&gt;30000&lt;/salary&gt;
&lt;/employee&gt;
&lt;/class&gt;</code></pre>
<p>雇员. xsl</p>
<pre class="language-markup"><code>&lt;?xml version ="1.0"encoding ="UTF-8"?&gt;
&lt;xsl:stylesheetversion="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:templatematch="/"&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h2&gt;Employee&lt;/h2&gt;
&lt;tableborder="1"&gt;
&lt;trbgcolor="pink"&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;First Name&lt;/th&gt;
&lt;th&gt;Last Name&lt;/th&gt;
&lt;th&gt;Nick Name&lt;/th&gt;
&lt;th&gt;Salary&lt;/th&gt;
&lt;th&gt;Grade&lt;/th&gt;
&lt;/tr&gt;
&lt;xsl:for-eachselect="class/employee"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;xsl:value-ofselect="@id"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="firstname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="lastname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="nickname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="salary"/&gt;&lt;/td&gt;
&lt;td&gt;
&lt;xsl:choose&gt;
&lt;xsl:whentest="salary div 25000 &gt; 1"&gt;
High
&lt;/xsl:when&gt;
&lt;xsl:whentest="salary div 20000 &gt; 1"&gt;
Medium
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
Low
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/xsl:for-each&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code></pre>
<h4 id="string-functions">字符串函数</h4>
<p>以下是帮助您执行XPath表达式任务的各种字符串函数:</p>
<ul>
<li>starts-with(string1，string2):当第一个字符串以第二个字符串开头时，返回true</li>
<li>contains(string1，string2):当第一个字符串包含第二个字符串时，返回true</li>
<li>子串(字符串，偏移量，长度？):结果得到字符串的一部分。该部分从偏移处开始，直到提供的长度。</li>
<li>substring-before(string1，string2):该函数返回第一次出现string2之前的string1部分。</li>
<li>substring-after(string1，string2):返回第一次出现string2之后的string1部分。</li>
<li>string-length(string):这个函数返回字符串的字符长度。</li>
<li>normalize-space(string):你可以用这个函数来修剪字符串的前导和尾随空格。</li>
<li>translate(string1，string2，string3):在string2中的任何匹配字符被string3中的字符替换后，它返回string1。</li>
<li>concat(string1，string2，...):您可以使用此函数组合所有字符串。</li>
<li>format-number(number1，string1，string2):在将string1作为格式字符串应用后，它返回number1的格式化版本。String2是可选的区域设置字符串。</li>
</ul>
<p>在这个例子中，我们通过迭代每个雇员来创建一个包含<employee>元素的表，其中包含这些元素的名称和名称长度。它在连接名字和姓氏后计算雇员姓名的长度，然后显示雇员的详细信息。</employee></p>
<p>Example.xml</p>
<pre class="language-markup"><code>&lt;?xml version ="1.0"?&gt;
&lt;?xml-stylesheet type ="text/xsl"href ="employee.xsl"?&gt;
&lt;class&gt;
&lt;employeeid="001"&gt;
&lt;firstname&gt;Abhiram&lt;/firstname&gt;
&lt;lastname&gt;Kushwaha&lt;/lastname&gt;
&lt;nickname&gt;Manoj&lt;/nickname&gt;
&lt;salary&gt;15000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="002"&gt;
&lt;firstname&gt;Akash&lt;/firstname&gt;
&lt;lastname&gt;Singh&lt;/lastname&gt;
&lt;nickname&gt;Bunty&lt;/nickname&gt;
&lt;salary&gt;25000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="003"&gt;
&lt;firstname&gt;Brijesh&lt;/firstname&gt;
&lt;lastname&gt;Kaushik&lt;/lastname&gt;
&lt;nickname&gt;Ballu&lt;/nickname&gt;
&lt;salary&gt;20000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="004"&gt;
&lt;firstname&gt;Zoya&lt;/firstname&gt;
&lt;lastname&gt;Mansoori&lt;/lastname&gt;
&lt;nickname&gt;Sonam&lt;/nickname&gt;
&lt;salary&gt;30000&lt;/salary&gt;
&lt;/employee&gt;
&lt;/class&gt;</code></pre>
<p>示例. xsl</p>
<pre class="language-markup"><code>&lt;?xml version ="1.0"encoding ="UTF-8"?&gt;
&lt;xsl:stylesheetversion="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:templatematch="/"&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h2&gt;Employee&lt;/h2&gt;
&lt;tableborder="1"&gt;
&lt;trbgcolor="pink"&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Length of Name&lt;/th&gt;
&lt;/tr&gt;
&lt;xsl:for-eachselect="class/employee"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;xsl:value-ofselect="concat(firstname,' ',lastname)"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="string-length(concat(firstname,' ',lastname))"/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/xsl:for-each&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code></pre>
<h3 id="node-functions">节点功能</h3>
<p>下表突出显示了各种节点运算符及其说明:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>操作员</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>/</p>
</td>
<td colspan="1" rowspan="1">
<p>选择特定节点下的节点。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//</p>
</td>
<td colspan="1" rowspan="1">
<p>从根节点中选择节点。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>[...]</p>
</td>
<td colspan="1" rowspan="1">
<p>检查节点值。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>|</p>
</td>
<td colspan="1" rowspan="1">
<p>统一两个节点集。</p>
</td>
</tr>
</tbody>
</table>
<p>以下是XPath表达式中使用的节点函数列表。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>功能</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>节点()</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有类型的节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>处理指令()</p>
</td>
<td colspan="1" rowspan="1">
<p>选择处理指令的节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>文本()</p>
</td>
<td colspan="1" rowspan="1">
<p>选择一个文本节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>名称()</p>
</td>
<td colspan="1" rowspan="1">
<p>提供节点名称</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>位置()</p>
</td>
<td colspan="1" rowspan="1">
<p>提供节点位置</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>最后一个()</p>
</td>
<td colspan="1" rowspan="1">
<p>选择相对于当前节点的最后一个节点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>评论</p>
</td>
<td colspan="1" rowspan="1">
<p>选择作为注释的节点</p>
</td>
</tr>
</tbody>
</table>
<p>在这个例子中，我们通过迭代每个雇员来创建一个包含<employee>元素及其详细信息的表。它计算学生节点的位置，然后显示带有序列号的雇员详细信息。</employee></p>
<p>雇员. xml:</p>
<pre class="language-markup"><code>&lt;?xml version ="1.0"?&gt;
&lt;?xml-stylesheet type ="text/xsl"href ="employee.xsl"?&gt;
&lt;class&gt;
&lt;employeeid="001"&gt;
&lt;firstname&gt;Abhiram&lt;/firstname&gt;
&lt;lastname&gt;Kushwaha&lt;/lastname&gt;
&lt;nickname&gt;Manoj&lt;/nickname&gt;
&lt;salary&gt;15000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="002"&gt;
&lt;firstname&gt;Akash&lt;/firstname&gt;
&lt;lastname&gt;Singh&lt;/lastname&gt;
&lt;nickname&gt;Bunty&lt;/nickname&gt;
&lt;salary&gt;25000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="003"&gt;
&lt;firstname&gt;Brijesh&lt;/firstname&gt;
&lt;lastname&gt;Kaushik&lt;/lastname&gt;
&lt;nickname&gt;Ballu&lt;/nickname&gt;
&lt;salary&gt;20000&lt;/salary&gt;
&lt;/employee&gt;
&lt;employeeid="004"&gt;
&lt;firstname&gt;Zoya&lt;/firstname&gt;
&lt;lastname&gt;Mansoori&lt;/lastname&gt;
&lt;nickname&gt;Sonam&lt;/nickname&gt;
&lt;salary&gt;30000&lt;/salary&gt;
&lt;/employee&gt;
&lt;/class&gt;</code></pre>
<p>雇员. xsl:</p>
<pre class="language-markup"><code>&lt;?xml version ="1.0"encoding ="UTF-8"?&gt;
&lt;xsl:stylesheetversion="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:templatematch="/"&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h2&gt;Employee&lt;/h2&gt;
&lt;tableborder="1"&gt;
&lt;trbgcolor="pink"&gt;
&lt;th&gt;Serial No&lt;/th&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;First Name&lt;/th&gt;
&lt;th&gt;Last Name&lt;/th&gt;
&lt;th&gt;Nick Name&lt;/th&gt;
&lt;th&gt;Salary&lt;/th&gt;
&lt;/tr&gt;
&lt;xsl:for-eachselect="class/employee"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;xsl:value-ofselect="position()"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="@id"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="firstname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="lastname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="nickname"/&gt;&lt;/td&gt;
&lt;td&gt;&lt;xsl:value-ofselect="salary"/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/xsl:for-each&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code></pre>
<h3 id="xpath-selectors">XPath选择器</h3>
<p>借助XPath选择器，您可以只选择HTML文档中由XPath元素指定的特定部分。XPath有许多不同类型的selectos。</p>
<h4 id="descendent-selectors">后代选择器</h4>
<p>后代选择器代表当前节点的所有子节点，以及每个子节点的所有子节点，等等。这些选择器不包括属性和名称空间节点。属性节点的父节点是其元素节点，而属性节点不是其父节点的后代。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p>差异</p>
</td>
<td colspan="1" rowspan="1">
<p>//div</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有div元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>部门h1</p>
</td>
<td colspan="1" rowspan="1">
<p>//div//h1</p>
</td>
<td colspan="1" rowspan="1">
<p>选择div元素中的所有h1</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>ul &gt; li</p>
</td>
<td colspan="1" rowspan="1">
<p>//ul/li</p>
</td>
<td colspan="1" rowspan="1">
<p>选择作为ul子元素的所有li元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>一个</p>
</td>
<td colspan="1" rowspan="1">
<p>/div/p/a</p>
</td>
<td colspan="1" rowspan="1">
<p>选择div元素的段落标记内的所有锚点标记</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>div &gt; *</p>
</td>
<td colspan="1" rowspan="1">
<p>//div/*</p>
</td>
<td colspan="1" rowspan="1">
<p>选择div标签中的所有元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>:根</p>
</td>
<td colspan="1" rowspan="1">
<p>/</p>
</td>
<td colspan="1" rowspan="1">
<p>选择DOM的根元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>:根&gt;正文</p>
</td>
<td colspan="1" rowspan="1">
<p>/body</p>
</td>
<td colspan="1" rowspan="1">
<p>选择正文标签</p>
</td>
</tr>
</tbody>
</table>
<h4 id="attribute-selectors">属性选择器</h4>
<p>XPath属性选择器根据给定属性的存在或值来匹配元素。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>元素</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong> Xpath </strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>#id</p>
</td>
<td colspan="1" rowspan="1">
<p>//*[@id="id"]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择具有匹配ID属性的所有元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>。班级</p>
</td>
<td colspan="1" rowspan="1">
<p>//*[@class="class"]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择具有匹配类属性的所有元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>[rel]</p>
</td>
<td colspan="1" rowspan="1">
<p>//和[@ with]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有具有rel属性的锚点标记。</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>a[href^='/']</p>
</td>
<td colspan="1" rowspan="1">
<p>//a[以(@href，'/')开头]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择href以“/”开头的所有锚点标记</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>a[href$='txt']</p>
</td>
<td colspan="1" rowspan="1">
<p>//a[以(@href，')结尾。txt')]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有href以'结尾的锚点标记。'文本'</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>a[rel~='details']</p>
</td>
<td colspan="1" rowspan="1">
<p>//a[包含(@rel，' details')]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有具有相关值“详细信息”的锚点标记</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>输入[type="password"]</p>
</td>
<td colspan="1" rowspan="1">
<p>//input[@type="password"]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有密码类型的输入标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>a#btn[for="XYZ"]</p>
</td>
<td colspan="1" rowspan="1">
<p>//a[@id="btn"][@for="XYZ"]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择“BTN”ID与XYZ链接的所有锚定标签</p>
</td>
</tr>
</tbody>
</table>
<h4 id="order-selectors">订单选择器</h4>
<p>可以在XPath中使用顺序选择器来检索列表元素。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>元素</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong> XPath </strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>ul &gt;李:一流</p>
</td>
<td colspan="1" rowspan="1">
<p>//ul/li[1]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择作为ul子标签的第一个li标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>ul &gt; li:第n种类型(2)</p>
</td>
<td colspan="1" rowspan="1">
<p>//ul/li[2]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择第二个li标签，它是ul的子标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>li#id:第一款</p>
</td>
<td colspan="1" rowspan="1">
<p>//李[1][@id="id"]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择id值为“id”的第一个li</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>ul &gt;李:最新型</p>
</td>
<td colspan="1" rowspan="1">
<p>//ul/li[last()]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择ul的子级的最后一个li</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>答:第一胎</p>
</td>
<td colspan="1" rowspan="1">
<p>//*[1][name()="a"]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择锚点标签的第一个子标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>答:最后一个孩子</p>
</td>
<td colspan="1" rowspan="1">
<p>//*[last()][name()="a"]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择锚点标签的最后一个子标签</p>
</td>
</tr>
</tbody>
</table>
<h4 id="siblings">同科</h4>
<p>在Selenium WebDriver中，可以检索作为父元素同级的WebElement。以下是如何在Selenium WebDriver中使用同级获取元素:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>元素</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong> XPath </strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>h1 ~ ul</p>
</td>
<td colspan="1" rowspan="1">
<p>//h1/following-sibling::ul</p>
</td>
<td colspan="1" rowspan="1">
<p>选择h1标签同级之后的所有ul标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>h1 ~ #id</p>
</td>
<td colspan="1" rowspan="1">
<p>//h1/following-sibling::[@ id = " id "]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有id值为“ID”的元素，它们是h1的同级元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>h1 + ul</p>
</td>
<td colspan="1" rowspan="1">
<p>//h1/following-sibling::ul[1]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择h1同级之后的第一个ul标签</p>
</td>
</tr>
</tbody>
</table>
<h4 id="different-operators">不同的操作员</h4>
<p>XPathto中还有其他操作符来定位元素:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>操作员</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong> XPath </strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>非运算符</p>
</td>
<td colspan="1" rowspan="1">
<p>//p[not(@id)]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择属性与id不匹配的所有段落标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>文本匹配</p>
</td>
<td colspan="1" rowspan="1">
<p>//button[text()="Submit"]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择带有文本输入“提交”的按钮</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>文本匹配(子字符串)</p>
</td>
<td colspan="1" rowspan="1">
<p>//button[contains(text()，" pass")]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择包含字符串“pass”的按钮</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>算术</p>
</td>
<td colspan="1" rowspan="1">
<p>//产品[@price &gt; 3]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择值大于3的价格</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>有孩子</p>
</td>
<td colspan="1" rowspan="1">
<p>//ul[*]</p>
</td>
<td colspan="1" rowspan="1">
<p>如果有子代，请选择带有任意数字(或类型)的ul</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>有孩子(特定)</p>
</td>
<td colspan="1" rowspan="1">
<p>//ul[li]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择带有任何数字和li标签的ul作为子标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>逻辑</p>
</td>
<td colspan="1" rowspan="1">
<p>//a[@name或@href]</p>
</td>
<td colspan="1" rowspan="1">
<p>选择具有名称和href属性的所有锚点标记</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>联合(连接结果)</p>
</td>
<td colspan="1" rowspan="1">
<p>//a | //div</p>
</td>
<td colspan="1" rowspan="1">
<p>a和div标记的联合</p>
</td>
</tr>
</tbody>
</table>
<h4 id="contextual-selectors">上下文选择器</h4>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>定位器</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//img</p>
</td>
<td colspan="1" rowspan="1">
<p>图像元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//img/*[1]</p>
</td>
<td colspan="1" rowspan="1">
<p>元素img的第一个子元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//ul/child::李</p>
</td>
<td colspan="1" rowspan="1">
<p>ul的第一个孩子li</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//img[1]</p>
</td>
<td colspan="1" rowspan="1">
<p>第一个img孩子</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//img/*[last()]</p>
</td>
<td colspan="1" rowspan="1">
<p>元素img的最后一个子元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//img[last()]</p>
</td>
<td colspan="1" rowspan="1">
<p>最后一个img子代</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//img[last()-1]</p>
</td>
<td colspan="1" rowspan="1">
<p>倒数第二个img子代</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//ul[*]</p>
</td>
<td colspan="1" rowspan="1">
<p>有孩子的人</p>
</td>
</tr>
</tbody>
</table>
<h4 id="attribute-selectors-1">属性选择器</h4>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>定位器</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//img[@id='myId']</p>
</td>
<td colspan="1" rowspan="1">
<p>@id= 'myId '的图像元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//img[@id！='myId']</p>
</td>
<td colspan="1" rowspan="1">
<p>@id不等于“myId”的图像元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//img[@name]</p>
</td>
<td colspan="1" rowspan="1">
<p>具有名称属性的图像元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//*[包含(@id，' Id')]</p>
</td>
<td colspan="1" rowspan="1">
<p>包含@id的元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//*[以(@id，' id '))开头]</p>
</td>
<td colspan="1" rowspan="1">
<p>以@id开头的元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//*[以(@id，' id '))结尾]</p>
</td>
<td colspan="1" rowspan="1">
<p>以@id结尾的元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//*[匹配(@id，' r')]</p>
</td>
<td colspan="1" rowspan="1">
<p>@id与正则表达式“r”匹配的元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//*[@name='myName']</p>
</td>
<td colspan="1" rowspan="1">
<p>@name= 'myName '的图像元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//*[@id='X '或@name='X']</p>
</td>
<td colspan="1" rowspan="1">
<p>具有@id X或名称X的元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//*[@name="N"][@value="v"]</p>
</td>
<td colspan="1" rowspan="1">
<p>具有@name N和指定@value 'v '的元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//*[@name="N" and @value="v"]</p>
</td>
<td colspan="1" rowspan="1">
<p>具有@name N和指定@value 'v '的元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//*[@ name = " N " and not(@ value = " v ")]</p>
</td>
<td colspan="1" rowspan="1">
<p>@name为N的元素&amp;未指定@value 'v '</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//input[@type="submit"]</p>
</td>
<td colspan="1" rowspan="1">
<p>提交类型的输入</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//a[@href="url"]</p>
</td>
<td colspan="1" rowspan="1">
<p>带有目标链接的锚点' url '</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//section[//h1[@id='hi']]</p>
</td>
<td colspan="1" rowspan="1">
<p>如果它有一个@id= 'hi '的<h1>后代，则返回<section/></h1></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//*[@ id = " test table "]//tr[3]//TD[2]</p>
</td>
<td colspan="1" rowspan="1">
<p>按行和列的单元格</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//输入[@checked]</p>
</td>
<td colspan="1" rowspan="1">
<p>选中的复选框(或单选按钮)</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//a[@disabled]</p>
</td>
<td colspan="1" rowspan="1">
<p>所有被禁用的“a”元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//a[@price &gt; 2.50]</p>
</td>
<td colspan="1" rowspan="1">
<p>' a '价格&gt; 2.5英镑</p>
</td>
</tr>
</tbody>
</table>
<h3 id="xpath-methods">XPath方法</h3>
<p>以下是一些不同的XPath方法:</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>定位器</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>解释</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//table[count(tr) &gt; 1]</p>
</td>
<td colspan="1" rowspan="1">
<p>返回多于一行的表格</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//*[.="t"]</p>
</td>
<td colspan="1" rowspan="1">
<p>恰好包含文本“t”的元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//a[contains(text()，" Log Out")]</p>
</td>
<td colspan="1" rowspan="1">
<p>内部文本包含“注销”的锚点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//a[not(contains(text()，" Log Out))]</p>
</td>
<td colspan="1" rowspan="1">
<p>内部文本不包含“注销”的锚点</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>//a[not(@disabled)]</p>
</td>
<td colspan="1" rowspan="1">
<p>所有未禁用的“a”元素</p>
</td>
</tr>
</tbody>
</table>
<h4 id="math-methods">数学方法</h4>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>定位器</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>解释</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>上限(数量)</p>
</td>
<td colspan="1" rowspan="1">
<p>计算一个小数，并返回大于或等于该小数的小整数</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>楼层(编号)</p>
</td>
<td colspan="1" rowspan="1">
<p>计算一个小数，并返回小于或等于该小数的大整数</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>四舍五入(十进制)</p>
</td>
<td colspan="1" rowspan="1">
<p>返回与给定数字最接近的整数</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>总和(节点集)</p>
</td>
<td colspan="1" rowspan="1">
<p>返回给定节点集中每个节点的数值之和</p>
</td>
</tr>
</tbody>
</table>
<h4 id="string-methods">字符串方法</h4>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p><strong>定位器</strong></p>
</td>
<td colspan="1" rowspan="1">
<p><strong>解释</strong></p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>包含(空间字符串，行星字符串)</p>
</td>
<td colspan="1" rowspan="1">
<p>确定第一个参数字符串是否包含第二个参数字符串，并返回布尔值true或false</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>concat(string1, string2 [stringn]*)</p>
</td>
<td colspan="1" rowspan="1">
<p>连接两个或多个字符串并返回结果字符串</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>规范化-空格(字符串)</p>
</td>
<td colspan="1" rowspan="1">
<p>从字符串中去除前导和尾随空白；用一个空格替换空白字符序列；返回结果字符串</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>开头为(spacetrack，space)</p>
</td>
<td colspan="1" rowspan="1">
<p>检查第一个字符串是否以第二个字符串开始，并返回true或false</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>字符串长度([字符串])</p>
</td>
<td colspan="1" rowspan="1">
<p>返回一个等于给定字符串中字符数的数字</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>子字符串(字符串，开始[长度])</p>
</td>
<td colspan="1" rowspan="1">
<p>返回给定字符串的一部分</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>子串-after(spacetrack，track)</p>
</td>
<td colspan="1" rowspan="1">
<p>返回给定子串之后给定字符串的剩余部分</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>子串-before(spacetrack，tra)</p>
</td>
<td colspan="1" rowspan="1">
<p>返回给定子串之前给定字符串的剩余部分</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>翻译(字符串，ghj，GHJ)</p>
</td>
<td colspan="1" rowspan="1">
<p>计算要翻译的字符串和一组字符，并返回翻译后的字符串</p>
</td>
</tr>
</tbody>
</table>
<h2 id="obtaining-xpath-using-jquery">使用JQuery获取XPath</h2>
<p>JQuery 支持所有基本类型的XPath表达式。在我们的XPath备忘单的下一部分中列出了主要的错误！</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">
<p>JQuery XPath</p>
</td>
<td colspan="1" rowspan="1">
<p>XPath</p>
</td>
<td colspan="1" rowspan="1">
<p>描述</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>$('ul &gt; li ')。父级()</p>
</td>
<td colspan="1" rowspan="1">
<p>//ul/li/..</p>
</td>
<td colspan="1" rowspan="1">
<p>选择作为li标签父级的所有ul元素</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>$('李')。最近的(“部分”)</p>
</td>
<td colspan="1" rowspan="1">
<p>//李/祖先或自己::节</p>
</td>
<td colspan="1" rowspan="1">
<p>选择所有具有href属性的锚点标签</p>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<p>$('p ')。文本()</p>
</td>
<td colspan="1" rowspan="1">
<p>//p/text()</p>
</td>
<td colspan="1" rowspan="1">
<p>选择段落标签中的文本</p>
</td>
</tr>
</tbody>
</table>
<h2 id="conclusion">结论</h2>
<p>我们已经到了XPath备忘单的末尾。XPath是Selenium中常用的web定位器。但是要获得高效的XPath，必须依赖于文档的结构和WebElement的当前位置。</p>
<p>在这篇详尽的Selenium web locator备忘单中，我们涵盖了XPath定位器的所有主要方面。需要时，将它放在身边，让您的工作更上一层楼。</p>
<p>有兴趣了解更多关于Selenium WebDriver的知识并找到一个附带的Selenium备忘单吗？查看我们的<a href="https://hackr.io/blog/what-is-selenium-webdriver" target="_blank" rel="noopener"> Selenium WebDriver指南</a>。</p>
<h2 id="frequently-asked-questions">常见问题</h2>
<h4 id="toc-1-what-is-an-xpath-example">1.什么是XPath示例？</h4>
<p>想象一个有很多书的书店。每本书都有不同的书名、作者、价格、出版年份和内容——所有的信息都储存在书店的电脑里。数据从书店的计算机传输到我们的计算机的一种方式是通过XML文件。XML文件包含数据，如下所示:</p>
<pre class="language-markup"><code>&lt;?xml version='1.0'?&gt;

&lt;bookstore&gt;

&lt;category&gt;Cooking&lt;/Category&gt;

&lt;language&gt;Chinese&lt;/language&gt;

&lt;title&gt;Chinese Noodles&lt;/title&gt;

&lt;author&gt;Chen Li&lt;/author&gt;

&lt;year&gt;2010&lt;/year&gt;

&lt;price&gt;$12.99&lt;/price&gt;

&lt;/bookstore&gt;</code></pre>
<p>注意，第一行说明了XML版本。如果您查看XML文件，它的结构类似于一个文件柜。文件柜的名字是书店。文件柜包含不同的文件或不同的信息——类别、语言、标题、作者、年份、价格等。</p>
<p>书店被称为根元素或根节点，因为所有其他信息都在书店内。根节点中的每条信息都称为一个节点。节点是标签&lt; &gt;和 &gt;之间的名称。</p>
<p>在这个XML文件中，根节点是书店。这些节点是类别、语言、标题、作者、年份和价格。</p>
<h4 id="toc-2-what-is-the-easiest-way-to-find-xpath">2.查找XPath最简单的方法是什么？</h4>
<p>下面是如何用最简单的方法找到XPath:</p>
<ul>
<li>转到名字选项卡，右键单击&gt;&gt;检查。</li>
<li>您将看到一个输入标签和类似classandid的属性。</li>
<li>使用id和属性来构造XPath，该XPath将定位名字字段。</li>
</ul>
<h4 id="toc-3-what-is-the-correct-xpath-syntax">3.正确的XPath语法是什么？</h4>
<p>XPath包含位于网页上的元素路径。创建XPath的标准XPath语法是:</p>
<pre class="language-markup"><code>Xpath=//tagname[@attribute='value']</code></pre>
<p>//:选择当前节点。</p>
<p>标记名:特定节点的标记名。</p>
<p>@:选择属性。</p>
<p>属性:节点的属性名。</p>
<p>值:属性的值。</p>
<h4 id="toc-4-how-do-i-get-xpath-in-html">4.如何在HTML中获取XPath？</h4>
<p>如果你使用Chrome为HTML元素寻找XPath，你不需要安装任何扩展。</p>
<ol start="1">
<li>在Chrome中打开想要检查的网站。按F12打开网站检查器，它将出现在窗口的右侧。</li>
</ol>
<ol start="2">
<li>点按元素检查器按钮。您可以在网站检查器面板的左上角找到它。这个按钮看起来像一个有鼠标指针指向的盒子。</li>
</ol>
<ol start="3">
<li>单击网站上要检查的元素。当您将光标移动到站点的元素上时，您会看到这些元素高亮显示。</li>
</ol>
<ol start="4">
<li>右键单击检查器面板中突出显示的代码。当您使用检查器点按某个元素时，相关代码将在窗口底部的检查器面板中自动高亮显示。</li>
</ol>
<ol start="5">
<li>右键单击突出显示的代码。选择“复制”= &gt;“复制XPath”这将把元素的XPath信息复制到剪贴板。</li>
</ol>
<p>注意:这只是复制了最少的XPath信息。Firefox的Firebug可以提供完整的XPath信息。</p>

									</div>

									</div>    
</body>
</html>