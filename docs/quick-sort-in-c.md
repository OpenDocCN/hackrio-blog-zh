# C 语言中的快速排序[程序与算法]

> 原文：<https://hackr.io/blog/quick-sort-in-c>

和 C 中的 [归并排序](https://hackr.io/blog/merge-sort-in-c) 一样，C 中的快速排序也遵循了递减和征服的原则——或者像人们常说的分而治之。快速排序算法是一种排序算法，其工作原理是选择一个中枢点，然后围绕该中枢点划分数字集或数组。

也被称为分区交换排序，是由英国计算机科学家东尼·霍尔在 1959 年发明的。自 1961 年发布以来，quicksort 已经成为排序算法的首选之一。

在本指南中，我们将通过一个用 c 语言编写的快速排序程序来解释该算法。您还将了解快速排序与其他排序算法相比的优势，以及快速排序的最佳应用场景。

## C 中的快速排序程序是什么？

快速排序算法中的主要过程是分区。如果 x 是数组中的枢纽，那么排序过程的主要目的是将 x 放在排序后的数组中的正确位置，这样较小的元素在 x 之前，较大的元素在 x 之后。

一旦选择了枢纽元素，比枢纽元素小的元素会放在它的前面，大的放在后面。快速排序算法有几种变体，这取决于选择哪种元素(或数字)作为枢纽:

*   第一个元素作为支点
*   最后一个元素作为支点
*   一个随机元素作为支点
*   正中为支点

## C 语言中的一个快速排序程序

C 语言中的快速排序代码非常简单，一旦你理解了其中的逻辑，你应该可以在 10 分钟内实现它。

下面的代码非常清晰地演示了 C 语言中的快速排序。它要求用户输入一些需要排序的元素(最多 25 个)，然后按照排序后的顺序显示这些元素:

```
#include<stdio.h>

void quicksort(int number[25],int first,int last){

int i, j, pivot, temp;

if(first<last){

pivot=first;

i=first;

j=last;

while(i<j){

while(number[i]<=number[pivot]&&i<last)

i++;

while(number[j]>number[pivot])

j--;

if(i<j){

temp=number[i];

number[i]=number[j];

number[j]=temp;

}

}

temp=number[pivot];

number[pivot]=number[j];

number[j]=temp;

quicksort(number,first,j-1);

quicksort(number,j+1,last);

}

}

int main(){

int i, count, number[25];

printf("Enter some elements (Max. - 25): ");

scanf("%d",&count);

printf("Enter %d elements: ", count);

for(i=0;i<count;i++)

scanf("%d",&number[i]);

quicksort(number,0,count-1);

printf("The Sorted Order is: ");

for(i=0;i<count;i++)

printf(" %d",number[i]);

return 0;

}
```

### **样本输出:**

输入一些元素(最大。- 25): 5

输入 5 个元素:5 22 -19 63 1

排序顺序为:-19 1 5 22 63

### 快速排序是如何工作的？

下面的步骤分解了 C 中的快速排序算法:

1.  我们从主函数开始。在调用快速排序之前，用户输入要排序的元素数量，然后输入元素本身。
2.  我们将 25 个数字(数组的元素)存储在数组编号中，用变量 first 和 last 表示第一个和最后一个元素。然后我们调用 quicksort 函数，它将算法移动到下一步。
3.  如果第一个元素比最后一个元素小，它将枢轴设置到第一个元素。
4.  它调用一个 while 循环，根据 I 和 j 与支点的关系来增加 I 和减少 j。更简单地说，它检查元素是否低于/高于支点，并将整个数组分成两个子数组；这是分区步骤。
5.  然后，快速排序递归地调用它自己来相应地排序两个子数组，直到整个数组被排序。
6.  打印排序后的数组。

## **另一个快速排序示例**

这是另一个演示快速排序的 C 程序。在这种情况下，我们将最后一个元素作为枢纽，我们不会接受任何输入。

```
#include<stdio.h>

void
swap (int *a, int *b)
{

  int t = *a;

  *a = *b;

  *b = t;

}

int
partition (int arr[], int low, int high)
{

  int pivot = arr[high];

  int i = (low - 1);

  for (int j = low; j <= high - 1; j++)

    {

      if (arr[j] <= pivot)

	{

	  i++;

	  swap (&arr[i], &arr[j]);

	}

    }

  swap (&arr[i + 1], &arr[high]);

  return (i + 1);

}

void
quickSort (int arr[], int low, int high)
{

  if (low < high)

    {

      int pi = partition (arr, low, high);

      quickSort (arr, low, pi - 1);

      quickSort (arr, pi + 1, high);

    }

}

void
printArray (int arr[], int size)
{

  int i;

  for (i = 0; i < size; i++)

    printf ("%d ", arr[i]);

  printf ("\n");

}

int
main ()
{

  int arr[10] = { 9, 15, 10, 12, 23, 4, 48, 11, 12, 6 };

  int n = sizeof (arr) / sizeof (arr[0]);

  quickSort (arr, 0, n - 1);

  printf ("The sorted array is: \n");

  printArray (arr, n);

  return 0;

}
```

### **输出:**

排序后的数组为:

-8 5 9 11 17 22

### **程序解释**

在这个例子中，我们使用最后一个元素作为支点。您会注意到，在这种情况下，交换和分区过程是在它们自己的函数中编写的，而不是在同一个 quicksort 函数中。这有助于可读性和可重用性。

当我们使用最后一个元素作为支点时，快速排序算法就是这样进行的:

1.  我们定义要排序的数组。我们将数组大小、第一个和最后一个元素的参数传递给快速排序算法
2.  该算法检查第一个元素是否确实低于最后一个元素。如果是，它将数组、第一个和最后一个元素传递给分区函数。
3.  partition 函数将 pivot 元素设置为数组中的最后一个元素，并设置一个变量 I，该变量 I 递增并用于将元素划分为子数组。
4.  分区就绪后，quicksort 函数递归调用自己来对两个子数组进行排序，进而对整个数组进行排序。
5.  排序后的数组被打印出来。

[数据结构&算法使用 C++、C 和 Python - 2023](https://click.linksynergy.com/link?id=jU79Zysihs4&offerid=1045023.3202154&type=2&murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fmastering-data-structures-and-algorithms-using-c-programming%2F)

## **快速排序算法的复杂性**

快速排序算法对总共 n 个数进行排序所需的时间由下面的等式表示:

T(n)= T(k)+T(n-k-1)+(n)→(I)

T(k)和 T(n-k-1)代表快速排序算法中的两次递归调用。最后一项(n)表示划分过程，而 k 表示集合中小于主元的数字的总数。

请注意，快速排序算法完成所需的总时间取决于输入数组和部署的分区策略。

快速排序算法的效率有 3 种不同的情况:

*   **最坏情况:** 当分区过程总是选择最小或最大的元素作为轴心时，这被认为是快速排序算法的最坏情况。例如，在我们的 C 语言快速排序程序中，最后一个元素被选为支点，最坏的情况发生在数组已经排序的情况下。  对于快速排序的最坏情况，等式(I)被变换如下:T(n) = T(0) + T(n-1) + (n)。可以写成:T(n) = T(n-1) + (n)这给出了 t(n)o(n^2 的最坏情况)
*   **一般情况:** 快速排序中既不属于最坏情况也不属于最好情况的情况都是一般情况。  为了进行快速排序的平均情况分析，我们需要考虑给定数组的所有可能排列，然后计算每个排列所用的时间。显然，这是一个非常复杂的过程。  解决这个问题的一种方法是考虑分区过程将(n/9)个元素放在一个集合中而将(9n/10)个元素放在另一个集合中的平均情况。  因此，方程(I)就转化为**T(n)= T(n/9)+T(9n/10)+(n)  这个递推关系的解就是 T(n) = (n log n)。这里，T(n)的平均情况是 O(n log n)**
***   **最佳情况:** 快速排序的最佳情况发生在分区过程总是选取中间元素作为支点的时候。这里，等式(I)变成 T(n) = 2T(n/2) + (n)。利用 [主定理例 2](https://cs.stackexchange.com/questions/41250/what-is-the-case-2-in-master-theorem)，T(n) = (n log n)。因此，T(n)的最佳情况是 O (n log n)**

 **## **快速排序与其他排序算法**

Quicksort 在最坏情况下 O(n2)的时间复杂度明显比其他流行的排序算法，即归并排序和堆排序要差。然而，在实践中，快速排序比其他算法更快。

如果仔细实施，快速排序可以比合并排序和堆排序快两到三倍。这是因为快速排序算法的内循环允许在大多数系统架构上针对大多数形式的真实世界数据有效地实现。

通过改变枢纽的选择，快速排序也可以以不同的方式实现。这使得最坏的情况不太可能发生。话虽如此，当处理大量外部存储的数据时，合并排序是更好的选择。

虽然 [冒泡排序](https://hackr.io/blog/bubble-sort-in-c) 并不是快速排序的直接竞争对手，但对于简单性是主要优先考虑的场景，可以考虑使用它。这是因为冒泡排序的简单性，而快速排序则更复杂。

与选择排序相比，快速排序非常相似。然而，主要的区别在于快速排序不是一种稳定的排序。

## 什么时候使用快速排序算法？

快速排序算法是速度较快的算法之一，在不需要稳定排序时使用。它不需要任何额外的存储空间，并在信息搜索、运筹学和事件驱动模拟中得到应用。它也是尾递归的，由编译器优化。

## **自己试试 C 中的快速排序**

你刚刚学习了如何用 c 语言编写一个快速排序程序。排序的概念是编程的一个基本部分，因此，彻底理解它是非常重要的。

你已经看到了两个不同的 C 语言快速排序程序的例子，但是最好通过实践来理解。继续自己尝试，并尝试逐行理解代码的工作原理。

您还可以参考其他资源和一些 来更好地理解排序概念，进一步提高您的编程技能。

立即了解有关 C 和 C++的更多信息！

**人也在读:****