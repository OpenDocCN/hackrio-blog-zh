<html>
<head>
<title>Download Python Regex Cheat Sheet PDF for Quick Reference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>下载Python正则表达式备忘单PDF以供快速参考</h1>
<blockquote>原文：<a href="https://hackr.io/blog/python-regex-cheat-sheet#0001-01-01">https://hackr.io/blog/python-regex-cheat-sheet#0001-01-01</a></blockquote><div><div class="content">
										<p>正则表达式或Regex是Python编程或任何其他编程语言的一个重要方面。它用于通过字符、单词和模式匹配文本字符串。它还使用一组字符来创建搜索模式。</p>
<p>你的主要目标？记住语法和如何形成模式。但是说起来容易做起来难。在Python编程中，记住RegEx各个方面的每个语法是很困难的。这就是Python正则表达式备忘单派上用场的地方。如果你正在为即将到来的面试做准备，参考这个正则表达式Python备忘单来加速你的研究。</p>
<p><a href="https://drive.google.com/file/d/1XPcNtR8z9MvP7Mkcwyubd3T6Rc0fmNj6/view?usp=sharing" target="_blank" rel="noopener">点击这里</a>下载Hackr.io的Python Regex备忘单PDF。</p>
<p>那么，我们开始吧。</p>

<h2 id="python-regex-cheat-sheet"><strong> Python正则表达式备忘单</strong></h2>
<p>在这个Python正则表达式备忘单中，我们将用一个简单的例子来解释它是如何工作的。</p>

<p><a href="https://www.ibm.com/docs/en/informix-servers/12.10?topic=matching-metacharacters" target="_blank" rel="noopener">元字符</a>是正则表达式构建块。下表突出显示了Python正则表达式中的不同元字符，以及它们的描述和合适的示例:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>字符</strong></p>
</td>
<td>
<p><strong>描述</strong></p>
</td>
<td>
<p><strong>例子</strong></p>
</td>
</tr>
<tr>
<td>
<p>[]</p>
</td>
<td>
<p>一组字符</p>
</td>
<td>
<p>"[上午]"</p>
</td>
</tr>
<tr>
<td>
<p>\</p>
</td>
<td>
<p>表示特殊序列(也可用于转义特殊字符)</p>
</td>
<td>
<p>" \d "</p>
</td>
</tr>
<tr>
<td>
<p>。</p>
</td>
<td>
<p>任何字符(换行符除外)</p>
</td>
<td>
<p>“他..o "</p>
</td>
</tr>
<tr>
<td>
<p>^</p>
</td>
<td>
<p>始于</p>
</td>
<td>
<p>《^hello》</p>
</td>
</tr>
<tr>
<td>
<p>$</p>
</td>
<td>
<p>结尾为</p>
</td>
<td>
<p>"行星$ "</p>
</td>
</tr>
<tr>
<td>
<p>*</p>
</td>
<td>
<p>零次或多次出现</p>
</td>
<td>
<p>“他。*o "</p>
</td>
</tr>
<tr>
<td>
<p>+</p>
</td>
<td>
<p>一次或多次出现</p>
</td>
<td>
<p>“他。+o "</p>
</td>
</tr>
<tr>
<td>
<p>？</p>
</td>
<td>
<p>零或一次出现</p>
</td>
<td>
<p>“他。？o "</p>
</td>
</tr>
<tr>
<td>
<p>{}</p>
</td>
<td>
<p>精确指定的出现次数</p>
</td>
<td>
<p>“他。{2}o "</p>
</td>
</tr>
<tr>
<td>
<p>|</p>
</td>
<td>
<p>要么…要么…</p>
</td>
<td>
<p>“瀑布|停留”</p>
</td>
</tr>
<tr>
<td>
<p>()</p>
</td>
<td>
<p>捕获和分组</p>
</td>
</tr>
</tbody>
</table>
<p>让我们在下面详细讨论每个元字符。</p>
<h4 id="square-brackets"><strong> []方括号</strong></h4>
<p>它是一个字符类，有一组我们想要匹配的字符。</p>
<p>例如，字符类[abc]将匹配任何单个字符a、b或c。您可以根据需要指定任何范围的字符。</p>
<p>例如:</p>

<ul>
<li>[0，3]与[0123]相同</li>
<li>【a-c】和【abc】一样。</li>
</ul>
<p>您可以使用caret(^符号反转字符类。例如:</p>
<ul>
<li>[^0-3]是指除0、1、2或3以外的任何数字</li>
<li>[^a-c]是指除a、b或c以外的任何字符</li>
</ul>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
x = re.findall("[a-m]", txt)
print(x)</code></pre>
<p>输出</p>
<pre class="language-python"><code>['h', 'e', 'a', 'i', 'i', 'a', 'i']</code></pre>
<h4 id="backslash"><strong> \反斜杠</strong></h4>
<p>反斜杠(\)确保字符不会被特殊处理。它用于转义元字符。</p>
<p>例如，如果要搜索点(。)在字符串中，搜索到的点将被视为特殊字符。因此，您需要在点()前使用反斜杠(\)。)</p>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "That will be 59 dollars"
#Find all digit characters:
x = re.findall("\d", txt)
print(x)</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['5', '9']</code></pre>
<h4 id="dot"><strong>。-点号</strong></h4>
<p>使用点符号，您只能匹配一个字符，换行符除外。</p>
<ul>
<li><strong> a.b </strong>将检查在点的位置包含任何字符的字符串，如acb、acbd、abbb等</li>
<li><strong>..</strong>将检查字符串是否包含至少两个字符</li>
</ul>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "hello planet"
#Search for a sequence that starts with "he", followed by two (any) characters, and an "o":
x = re.findall("he..o", txt)
print(x)</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['hello']</code></pre>
<h4 id="caret-start-with"><strong> ^脱字符号(开头为)</strong></h4>
<p>脱字符号(^)允许您匹配字符串的开头。它检查字符串是否以特定字符开头。</p>
<p>例如:</p>
<ul>
<li>^g会检查字符串是否以g开头，如girl，globe，gym，g等。</li>
<li>^ge会检查字符串是否以ge开头，如gem、gel等。</li>
</ul>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "hello planet"
#Check if the string starts with 'hello':
x = re.findall("^hello", txt)
if x:
 print("Yes, the string starts with 'hello'")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>Yes, the string starts with 'hello'</code></pre>
<h4 id="dollar-end-with"><strong> $美元(结尾为)</strong></h4>
<p>美元($)符号允许您匹配字符串的结尾。它检查字符串是否以给定的字符结尾。</p>
<p>例如:</p>
<ul>
<li>s$将检查以a结尾的字符串，如sis、ends、s等。</li>
<li>ks$将检查以ks结尾的字符串，如seeks、disks、ks等。</li>
</ul>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "hello planet"
#Check if the string ends with 'planet':
x = re.findall("planet$", txt)
if x:
 print("Yes, the string ends with 'planet'")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>Yes, the string ends with 'world'</code></pre>
<h4 id="star"><strong>·明星</strong></h4>
<p>此符号将匹配*符号前的正则表达式的零次或多次出现。</p>
<p>例如:</p>
<ul>
<li>ab*c将与字符串ac、abc、abbbc、dabc等匹配。但是不会与abdc匹配，因为b后面没有c。</li>
</ul>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "hello planet"
#Search for a sequence that starts with "he", followed by 0 or more (any) characters, and an "o":
x = re.findall("he.*o", txt)
print(x)</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['hello']</code></pre>
<h4 id="plus"><strong> +加上</strong></h4>
<p>该符号将匹配+符号前面的正则表达式的一个或多个实例。</p>
<p>例如:</p>
<ul>
<li>ab+c将与字符串abc，abbc，dabc匹配，但不会与ac，abdc匹配，因为ac中没有b，并且在abdc中b后面没有c。</li>
</ul>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "hello planet"
#Search for a sequence that starts with "he", followed by 1 or more (any) characters, and an "o":
x = re.findall("he.+o", txt)
print(x)</code></pre>
<p>输出:</p>

<pre class="language-python"><code>['hello']</code></pre>
<h4 id="question-mark"><strong>？问号</strong></h4>
<p>这个符号将检查问号前的字符串是至少出现一次，还是根本不出现。</p>
<p>例如:</p>
<ul>
<li>ab？c将匹配字符串ac、acb和dabc，但不会匹配abbc，因为有两个b。同样，它不会与abdc匹配，因为b后面没有c。</li>
</ul>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "hello planet"
#Search for a sequence that starts with "he", followed by 0 or 1 (any) character, and an "o":
x = re.findall("he.?o", txt)
print(x)</code></pre>
<p>输出:</p>
<pre class="language-python"><code>[]</code></pre>
<h4 id="m-n-braces"><strong> {m，n}-大括号</strong></h4>
<p>大括号匹配正则表达式前面从m到n(包括m和n)的任何重复。</p>
<p>例如:</p>
<ul>
<li>a{2，4}将与字符串aaab，baaaac，gaad匹配，但不会与abc，bc等字符串匹配，因为在这两种情况下都只有一个a或没有a。</li>
</ul>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "hello planet"
#Search for a sequence that starts with "he", followed excactly 2 (any) characters, and an "o":
x = re.findall("he.{2}o", txt)
print(x)</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['hello']</code></pre>
<h4 id="or"><strong> | -或</strong></h4>
<p>“或”符号检查“或”符号之前或之后的模式是否出现在字符串中。</p>
<p>例如:</p>

<ul>
<li>a|b将匹配任何包含a或b的字符串，如acd、bcd、abcd等。</li>
</ul>
<p>例如:</p>

<pre class="language-python"><code>import re
txt = "The rain in Spain falls mainly in the plain!"
#Check if the string contains either "falls" or "stays":
x = re.findall("falls|stays", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['falls']
Yes, there is at least one match!</code></pre>
<h4 id="regex-group"><strong> ( &lt; RegEx &gt; )-组</strong></h4>
<p>分组符号用于分组子模式。</p>
<p>例如:</p>
<ul>
<li>(a|b)cd将匹配acd、abcd、gacd等字符串。</li>
</ul>
<h2 id=""><a href="https://datacamp.pxf.io/oeZvdm" target="_blank" rel="noopener"><img src="../Images/38dbc41f2fc5629ecc718a565194ce3f.png" alt="" data-original-src="https://hackr.io/blog/media/coursera-ai-course-1.png"/>T2】</a></h2>
<h2 id="special-sequences"><strong>特殊序列</strong></h2>
<p>在RegEx Python备忘单的这一部分，我们将用合适的例子讨论各种特殊序列。</p>
<table>
<tbody>
<tr>
<td>
<p><strong>字符</strong></p>
</td>
<td>
<p><strong>描述</strong></p>
</td>
<td>
<p><strong>例子</strong></p>
</td>
</tr>
<tr>
<td>
<p>\A</p>
</td>
<td>
<p>如果指定的字符位于字符串的开头，则返回匹配项</p>
</td>
<td>
<p>" \AThe "</p>
</td>
</tr>
<tr>
<td>
<p>\b</p>
</td>
<td>
<p>返回指定字符位于单词开头或结尾的匹配项</p>
<p>(开头的“r”确保字符串被视为“原始字符串”)</p>
</td>
<td>
<p>r " \贝恩"</p>
<p>r"ain\b "</p>
</td>
</tr>
<tr>
<td>
<p>\B</p>
</td>
<td>
<p>返回存在指定字符但不在单词开头(或结尾)的匹配项</p>
<p>(开头的“r”确保字符串被视为“原始字符串”)</p>
</td>
<td>
<p>r"\Bain "</p>
<p>r"ain\B "</p>
</td>
</tr>
<tr>
<td>
<p>\d</p>
</td>
<td>
<p>返回字符串包含数字(从0到9的数字)的匹配项</p>
</td>
<td>
<p>" \d "</p>
</td>
</tr>
<tr>
<td>
<p>\D</p>
</td>
<td>
<p>返回字符串不包含数字的匹配项</p>
</td>
<td>
<p>" \D "</p>
</td>
</tr>
<tr>
<td>
<p>\s</p>
</td>
<td>
<p>返回字符串包含空白字符的匹配项</p>
</td>
<td>
<p>" \s "</p>
</td>
</tr>
<tr>
<td>
<p>\S</p>
</td>
<td>
<p>返回字符串中不包含空白字符的匹配项</p>
</td>
<td>
<p>" \S "</p>
</td>
</tr>
<tr>
<td>
<p>\w</p>
</td>
<td>
<p>返回字符串包含任何单词字符(从a到Z的字符、从0到9的数字和下划线_字符)的匹配项</p>
</td>
<td>
<p>" \w "</p>
</td>
</tr>
<tr>
<td>
<p>\W</p>
</td>
<td>
<p>返回字符串不包含任何单词字符的匹配项</p>
</td>
<td>
<p>" \W "</p>
</td>
</tr>
<tr>
<td>
<p>\Z</p>
</td>
<td>
<p>如果指定的字符位于字符串的末尾，则返回匹配项</p>
</td>
<td>
<p>"西班牙\Z "</p>
</td>
</tr>
</tbody>
</table>
<h4 id="a"><strong> \A </strong></h4>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Check if the string starts with "The":
x = re.findall("\AThe", txt)
print(x)
if x:
 print("Yes, there is a match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['The']
Yes, there is a match!</code></pre>
<h4 id="b"><strong> \b </strong></h4>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Check if "ain" is present at the beginning of a WORD:
x = re.findall(r"\bain", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")
#Check if "ain" is present at the end of a WORD:
x = re.findall(r"ain\b", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>[]
No match
['ain', 'ain']
Yes, there is at least one match!</code></pre>
<h4 id="b-1"><strong> \B </strong></h4>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Check if "ain" is present, but NOT at the beginning of a word:
x = re.findall(r"\Bain", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['ain', 'ain']
Yes, there is at least one match!</code></pre>
<h4 id="d"><strong> \d </strong></h4>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Check if the string contains any digits (numbers from 0-9):
x = re.findall("\d", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>[]
No match</code></pre>
<h4 id="d-1"><strong> \D </strong></h4>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Return a match at every no-digit character:
x = re.findall("\D", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['T', 'h', 'e', ' ', 'r', 'a', 'i', 'n', ' ', 'i', 'n', ' ', 'S', 'p', 'a', 'i', 'n']
Yes, there is at least one match!</code></pre>
<h4 id="s"><strong> \s </strong></h4>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Return a match at every white-space character:
x = re.findall("\s", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>

<pre class="language-python"><code>[' ', ' ', ' ']
Yes, there is at least one match!</code></pre>
<h4 id="s-1"><strong> \S </strong></h4>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Return a match at every NON white-space character:
x = re.findall("\S", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>

<pre class="language-python"><code>['T', 'h', 'e', 'r', 'a', 'i', 'n', 'i', 'n', 'S', 'p', 'a', 'i', 'n']
Yes, there is at least one match!</code></pre>
<h3 id="w"><strong> \w </strong></h3>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Return a match at evry word character (characters from a to Z, digits from 0-9, and the underscore _ character):
x = re.findall("\w", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['T', 'h', 'e', 'r', 'a', 'i', 'n', 'i', 'n', 'S', 'p', 'a', 'i', 'n']
Yes, there is at least one match!</code></pre>
<h4 id="w-1"><strong> \W </strong></h4>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Return a match at every NON word character (characters NOT between a and Z. Like "!", "?" white-space etc.):
x = re.findall("\W", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>[' ', ' ', ' ']
Yes, there is at least one match!</code></pre>
<h4 id="z"><strong> \Z </strong></h4>
<pre class="language-python"><code>import re
txt = "Te rain in Spain"
#Check if the string ends with "Spain":
x = re.findall("Spain\Z", txt)
print(x)
if x:
 print("Yes, there is a match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['Spain']
Yes, there is a match!</code></pre>
<h3 id="sets"><strong>设置</strong></h3>
<p>这是一组用方括号[]括起来的字符，具有特殊的含义。在Python正则表达式备忘单的这一部分，我们将用例子解释所有集合类型。</p>
<h4 id="arn"><strong>【arn】</strong></h4>
<p>这将返回其中一个指定字符(a、r或n)存在的匹配项。</p>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Check if the string has any a, r, or n characters:
x = re.findall("[arn]", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['r', 'a', 'n', 'n', 'a', 'n']
Yes, there is at least one match!</code></pre>
<h4 id="a-n"><strong>【a-n】</strong></h4>
<p>这将返回任何小写字符的匹配，按字母顺序在a和n之间。</p>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Check if the string has any characters between a and n:
x = re.findall("[a-n]", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['h', 'e', 'a', 'i', 'n', 'i', 'n', 'a', 'i', 'n']
Yes, there is at least one match!</code></pre>
<h4 id="arn-1"><strong>【^arn】</strong></h4>
<p>这将返回除a、r和n之外的任何字符的匹配。</p>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Check if the string has other characters than a, r, or n:
x = re.findall("[^arn]", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['T', 'h', 'e', ' ', 'i', ' ', 'i', ' ', 'S', 'p', 'i']
Yes, there is at least one match!</code></pre>
<p><strong>【0123】</strong></p>
<p>这将返回包含任何指定数字(0、1、2或3)的匹配结果。</p>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "The rain in Spain"
#Check if the string has any 0, 1, 2, or 3 digits:
x = re.findall("[0123]", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>[]
No match</code></pre>
<h4 id="0-9"><strong>【0-9】</strong></h4>
<p>这将返回0到9之间任何数字的匹配结果。</p>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "8 times before 11:45 AM"
#Check if the string has any digits:
x = re.findall("[0-9]", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['8', '1', '1', '4', '5']
Yes, there is at least one match!</code></pre>
<h4 id="0-5-0-9"><strong>【0-5】【0-9】</strong></h4>
<p>这将返回从00到59的任何两位数的匹配。</p>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "8 times before 11:45 AM"
#Check if the string has any two-digit numbers, from 00 to 59:
x = re.findall("[0-5][0-9]", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['11', '45']
Yes, there is at least one match!</code></pre>
<h4 id="a-za-z"><strong/></h4>
<p>这将返回a和z之间字母顺序的任何字符的匹配，小写或大写。</p>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "8 times before 11:45 AM"
#Check if the string has any characters from a to z lower case, and A to Z upper case:
x = re.findall("[a-zA-Z]", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['t', 'i', 'm', 'e', 's', 'b', 'e', 'f', 'o', 'r', 'e', 'A', 'M']
Yes, there is at least one match!</code></pre>
<h4 id="-1"><strong> [+] </strong></h4>
<p>在集合中，+，*，。，|，()，$，{}没有特殊含义。所以，[+]的意思是:返回字符串中任意+字符的匹配。</p>
<p>例如:</p>
<pre class="language-python"><code>import re
txt = "8 times before 11:45 AM"
#Check if the string has any + characters:
x = re.findall("[+]", txt)
print(x)
if x:
 print("Yes, there is at least one match!")
else:
 print("No match")</code></pre>
<p>输出:</p>
<pre class="language-python"><code>[]
No match</code></pre>
<h3 id="regex-module-in-python"><strong>Python中的Regex模块</strong></h3>
<p>Python附带了一个名为‘re’的模块。你一定注意到了在上面的例子中我们导入了模块“re”。该模块由几个功能组成，可帮助您执行各种操作。</p>
<h4 id="findall-function"><strong> findall()函数</strong></h4>
<p>这是“re；”的内置函数处理正则表达式的模块。</p>
<p>语法:</p>
<pre class="language-python"><code>re.findall(pattern, string, flags=0)</code></pre>
<ul>
<li>模式是正则表达式。</li>
<li>字符串是用户提供的输入字符串。</li>
<li>标志用于修改标准模式行为。</li>
</ul>
<p>从左到右计算每个字符串，并在字符串中查找所有匹配的模式。然而，结果取决于模式。</p>
<ul>
<li>如果模式<strong>没有捕获组</strong>，findall()函数返回匹配整个模式的字符串列表。</li>
<li>如果模式有<strong>个捕获组</strong>，findall()函数返回与该组匹配的字符串列表。</li>
<li>如果模式有<strong>多个捕获组</strong>，findall()函数返回匹配这些组的字符串元组。</li>
<li>值得注意的是，非捕获组不会影响返回结果的形式。</li>
</ul>
<p>例如:</p>
<ul>
<li><strong>获取匹配字符串的列表</strong></li>
</ul>
<pre class="language-python"><code>import re
s = "black, blue and brown"
pattern = r'bl\w+'
matches = re.findall(pattern,s)
print(matches)</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['black', 'blue']</code></pre>
<ul>
<li><strong>单组图案</strong></li>
</ul>
<pre class="language-python"><code>import re
s = "black, blue and brown"
pattern = r'bl(\w+)'
matches = re.findall(pattern,s)
print(matches)</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['ack', 'ue']</code></pre>
<ul>
<li><strong>多组图案</strong></li>
</ul>
<pre class="language-python"><code>import re
s = "black, blue and brown"
pattern = r'(bl(\w+))'
matches = re.findall(pattern,s)
print(matches)</code></pre>
<p>输出</p>
<pre class="language-python"><code>[('black', 'ack'), ('blue', 'ue')]</code></pre>
<ul>
<li><strong>使用正则表达式标志</strong></li>
</ul>
<pre class="language-python"><code>import re
s = "Black, blue and brown"
pattern = r'(bl(\w+))'
matches = re.findall(pattern, s, re.IGNORECASE)
print(matches)</code></pre>
<p>输出:</p>
<pre class="language-python"><code>[('Black', 'ack'), ('blue', 'ue')]</code></pre>
<h4 id="finditer-function"><strong> finditer()函数</strong></h4>
<p>使用这个函数，您可以匹配字符串中的模式，并返回一个迭代器，产生所有非重叠匹配的匹配对象。</p>
<p>语法:</p>
<pre class="language-python"><code>re.finditer(pattern, string, flags=0)</code></pre>
<ul>
<li>模式是正则表达式。</li>
<li>字符串是用户提供的输入字符串。</li>
<li>标志是可选的，默认为零。它接受一个或多个正则表达式标志。flags参数更改正则表达式引擎匹配模式的方式。</li>
</ul>
<p>例如:</p>
<pre class="language-python"><code>import re
s = 'Readability counts.'
pattern = r'[aeoui]'
matches = re.finditer(pattern, s)
for match in matches:
 print(match)</code></pre>
<p>输出:</p>
<pre class="language-python"><code>&lt;re.Match object; span=(1, 2), match='e'&gt;
&lt;re.Match object; span=(2, 3), match='a'&gt;
&lt;re.Match object; span=(4, 5), match='a'&gt;
&lt;re.Match object; span=(6, 7), match='i'&gt;
&lt;re.Match object; span=(8, 9), match='i'&gt;
&lt;re.Match object; span=(13, 14), match='o'&gt;
&lt;re.Match object; span=(14, 15), match='u'&gt;</code></pre>
<h3 id="search-function"><strong>搜索()功能</strong></h3>
<p>search()函数从左到右扫描字符串，找到模式产生匹配的第一个位置。如果搜索成功，它返回一个匹配对象，否则返回None。</p>
<p>语法:</p>
<pre class="language-python"><code>re.search(pattern, string, flags=0)</code></pre>
<ul>
<li>模式是正则表达式。</li>
<li>字符串是用户提供的输入字符串。</li>
<li>标志用于修改模式的标准模式行为。</li>
</ul>
<p>例如:</p>

<pre class="language-python"><code>import re
s = 'Python 3 was released on Dec 3, 2008'
pattern = '\d+'
match = re.search(pattern, s)
if match is not None:
 print(match.group())
else:
 print('No match found')</code></pre>
<p>输出</p>
<pre class="language-python"><code>re.Match object; span=(7, 8), match='3'&gt;</code></pre>
<ul>
<li><strong>找到匹配模式的第一个单词</strong></li>
</ul>
<pre class="language-python"><code>import re
s = 'CPython, IronPython, or Cython'
pattern = r'\b((\w+)thon)\b'
match = re.search(pattern, s)
if match is not None:
 print(match.groups())</code></pre>
<p>输出:</p>
<pre class="language-python"><code>('CPython', 'CPy')</code></pre>
<p>模式r'\b((\w+)thon)\b '有两个捕获组:</p>
<ul>
<li>(\ w+)–捕获单词开头的字符。</li>
<li>((\ w+)thon)-捕获整个单词。</li>
</ul>
<p>search()函数返回找到匹配项的第一个位置。</p>
<h4 id="fullmatch-function"><strong> fullmatch()函数</strong></h4>
<p>如果整个字符串匹配正则表达式的搜索模式，该函数将返回一个match对象，否则不返回任何对象。</p>
<p>语法:</p>
<pre class="language-python"><code>re.fullmatch(pattern, string, flags=0)</code></pre>
<ul>
<li>模式是正则表达式。</li>
<li>字符串是用户提供的输入字符串。</li>
<li>标志是可选的，默认为零。它接受一个或多个正则表达式标志。flags参数更改正则表达式引擎匹配模式的方式。</li>
</ul>
<p>例如:</p>
<ul>
<li><strong>验证电子邮件地址</strong></li>
</ul>
<pre class="language-python"><code>import re
email = 'no-reply@pythontutorial.net'
pattern = r'[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}'
match = re.fullmatch(pattern, email)
if match is not None:
 print(f'The email "{match.group()}" is valid')
else:
 print(f'The email "{email}"" is not valid')</code></pre>
<p>输出:</p>
<pre class="language-python"><code>The email "no-reply@pythontutorial.net" is valid.</code></pre>
<h4 id="match-function"><strong> Match()函数</strong></h4>
<p>re模块的match函数允许您在字符串的开头搜索一个模式。</p>
<p>语法:</p>
<pre class="language-python"><code>re.match(pattern, string, flags=0)</code></pre>
<ul>
<li>模式是正则表达式。</li>
<li>字符串是用户提供的输入字符串。</li>
<li>标志用于修改模式的标准行为。</li>
</ul>
<p>例如:</p>
<ul>
<li><strong>检查字符串是否以数字开头。</strong></li>
</ul>
<pre class="language-python"><code>import re
s = '3 pieces cost 5 USD'
pattern = r'\d{1}'
match = re.match(pattern, s)
if match is not None:
 print(f'The string starts with a digit {match.group()}')</code></pre>
<p>输出:</p>
<pre class="language-python"><code>The string starts with a digit 3</code></pre>
<h4 id="sub-function"><strong> Sub()函数</strong></h4>
<p>re模块的这个函数允许你处理正则表达式。</p>
<p>语法:</p>
<pre class="language-python"><code>re.sub(pattern, repl, string, count=0, flags=0)</code></pre>
<ul>
<li>模式是正则表达式或模式对象。</li>
<li>Repl是替代品。</li>
<li>字符串是用户提供的输入字符串。</li>
<li>Count参数指定sub()函数应该替换的最大匹配数。如果您传递零或跳过它，sub()函数将替换所有匹配。</li>
<li>Fags是一个或多个用于修改标准模式行为的正则表达式标志。</li>
</ul>
<p>它将在字符串中搜索模式，并用替换(repl)替换匹配的字符串。如果sub()函数找不到匹配，它将返回原始字符串。否则，sub()函数将在替换匹配项后返回字符串。</p>
<p>例如:</p>
<ul>
<li><strong>将电话号码(212)-456-7890转换为2124567890 </strong></li>
</ul>
<pre class="language-python"><code>import re
phone_no = '(212)-456-7890'
pattern = '\D'
result = re.sub(pattern, '',phone_no)
print(result)</code></pre>
<p>输出:</p>
<pre class="language-python"><code>2124567890</code></pre>
<ul>
<li><strong>替换模式最左边的非重叠出现</strong></li>
</ul>
<pre class="language-python"><code>import re
pattern = '00'
s = '00000'
result = re.sub(pattern,'',s)
print(result)</code></pre>
<p>输出:</p>
<pre class="language-python"><code>0</code></pre>

<pre class="language-python"><code>import re
s = 'Make the World a *Better Place*'
pattern = r'\*(.*?)\*'
replacement = r'&lt;b&gt;\1&lt;\\b&gt;'
html = re.sub(pattern, replacement, s)
print(html)</code></pre>
<p>输出:</p>
<pre class="language-python"><code>Make the World a &lt;b&gt;Better Place&lt;\b&gt;</code></pre>
<h4 id="subn-function"><strong> Subn()函数</strong></h4>
<p>这个函数在所有方面都与sub()相似，只是它提供输出的方式不同。它返回一个元组，包含替换和新字符串的总数，而不仅仅是字符串。</p>
<p>语法:</p>
<pre class="language-python"><code>re.subn(pattern, repl, string, count=0, flags=0)</code></pre>
<p>例如:</p>
<pre class="language-python"><code>import re
print(re.subn('ub', '~*', 'Subject has Uber booked already'))
t = re.subn('ub', '~*', 'Subject has Uber booked already',
 flags=re.IGNORECASE)
print(t)
print(len(t))
# This will give same output as sub() would have
print(t[0])</code></pre>
<p>输出:</p>
<pre class="language-python"><code>('S~*ject has Uber booked already', 1)
('S~*ject has ~*er booked already', 2)
Length of Tuple is: 2
S~*ject has ~*er booked already</code></pre>
<h4 id="escape-function"><strong> escape()函数</strong></h4>
<p>这个函数将返回一个包含所有非字母数字反斜杠的字符串。如果您想要匹配其中可能包含正则表达式元字符的任意文字字符串，这将非常有用。</p>
<p>语法:</p>
<pre class="language-python"><code>re.escape(string)</code></pre>
<p>例如:</p>
<pre class="language-python"><code>import re
print(re.escape("This is Awesome even 1 AM"))
print(re.escape("I Asked what is this [a-9], he said \t ^WoW"))</code></pre>
<p>输出:</p>
<pre class="language-python"><code>This\ is\ Awesome\ even\ 1\ AM
I\ Asked\ what\ is\ this\ \[a\-9\]\,\ he\ said\ \ \ \^WoW</code></pre>
<h4 id="compile-function"><strong>编译()函数</strong></h4>
<p>这个函数将把正则表达式编译成模式对象，这些对象具有用于各种操作的方法，比如搜索模式匹配或执行字符串替换。</p>
<p>语法:</p>
<pre class="language-python"><code>re.compile(string)</code></pre>
<p>例如:</p>
<pre class="language-python"><code>import re
p = re.compile('[a-e]')
# findall() searches for the Regular Expression
# and return a list upon finding
print(p.findall("Aye, said Mr. Gibenson Stark"))</code></pre>
<p>输出:</p>
<pre class="language-python"><code>['e', 'a', 'd', 'b', 'e', 'a']</code></pre>
<h4 id="split-function"><strong> Split()函数</strong></h4>
<p>它通过正则表达式的匹配来拆分字符串。</p>
<p>语法:</p>
<pre class="language-python"><code>split(pattern, string, maxsplit=0, flags=0)</code></pre>
<ul>
<li>模式是正则表达式。</li>
<li>字符串是用户提供的输入字符串。</li>
<li>标志是可选的，默认为零。它接受一个或多个正则表达式标志。flags参数更改正则表达式引擎匹配模式的方式。</li>
<li>maxsplit确定最多发生几次拆分。通常，如果maxsplit为1，那么结果列表将包含两个元素。如果maxsplit是2，那么结果列表将有3个元素，依此类推。</li>
</ul>
<p>例如:</p>
<ul>
<li><strong>拆分句子中的单词</strong></li>
</ul>
<pre class="language-python"><code>import re
s = 'A! B. C D'
pattern = r'\W+'
l = re.split(pattern, s)
print(l)</code></pre>
<p>输出</p>
<pre class="language-python"><code>['A', 'B', 'C', 'D']</code></pre>

<pre class="language-python"><code>import re
s = 'A! B. C D'
pattern = r'(\W+)'
l = re.split(pattern, s, 2)
print(l)</code></pre>
<p>输出</p>
<pre class="language-python"><code>['A', '! ', 'B', '. ', 'C D']</code></pre>
<h2 id="groups"><strong>组</strong></h2>
<p>组是包含在括号()元字符中的正则表达式的一部分。</p>
<table>
<tbody>
<tr>
<td>
<p><strong>表情</strong></p>
</td>
<td>
<p><strong>解释</strong></p>
</td>
</tr>
<tr>
<td>
<p>( )</p>
</td>
<td>
<p>匹配括号内的表达式，并根据需要对其进行分组以进行捕获</p>
</td>
</tr>
<tr>
<td>
<p>(?#…)</p>
</td>
<td>
<p>阅读评论</p>
</td>
</tr>
<tr>
<td>
<p>(?PAB)</p>
</td>
<td>
<p>匹配表达式AB，可以用组名检索该表达式。</p>
</td>
</tr>
<tr>
<td>
<p>(?:A)</p>
</td>
<td>
<p>匹配由表示的表达式，但之后无法检索。</p>
</td>
</tr>
<tr>
<td>
<p>(?p =组)</p>
</td>
<td>
<p>匹配先前名为“group”的组所匹配的表达式</p>
</td>
</tr>
</tbody>
</table>
<p>例如:</p>
<pre class="language-python"><code>import re
example = (re.search(r"(?:AB)","ACABC"))
print(example)
print(example.groups())
result = re.search(r"(\w*), (\w*)","seeks, zest")
print(result.groups())</code></pre>
<p>输出:</p>
<pre class="language-python"><code>&lt;re.Match object; span=(2, 4), match='AB'&gt;
()
('seeks', 'zest')</code></pre>
<h2 id="assertions"><strong>断言</strong></h2>
<p>在Python RegEx中，我们使用Lookahead作为断言。它决定了模式是否在解析器当前位置的右边。</p>
<table>
<tbody>
<tr>
<td>
<p><strong>表情</strong></p>
</td>
<td>
<p><strong>解释</strong></p>
</td>
</tr>
<tr>
<td>
<p>一(？=B)</p>
</td>
<td>
<p>仅当表达式A后跟b时，才匹配表达式A。(正向前瞻断言)</p>
</td>
</tr>
<tr>
<td>
<p>一(？！b)</p>
</td>
<td>
<p>仅当表达式A后面没有b时，才匹配表达式A。(负的前瞻断言)</p>
</td>
</tr>
<tr>
<td>
<p>(?&lt; =B)A</p>
</td>
<td>
<p>仅当B紧挨着表达式A的左侧时，才匹配表达式A。(断言背后的积极因素)</p>
</td>
</tr>
<tr>
<td>
<p>(?</p>
</td>
<td>
<p>仅当B不在其左侧时，才匹配表达式A。(断言背后的负面看法)</p>
</td>
</tr>
</tbody>
</table>
<p>例如:</p>
<pre class="language-python"><code>import re
print(re.search(r"z(?=a)", "pizza"))
print(re.search(r"z(?!a)", "pizza"))</code></pre>
<p>输出</p>
<pre class="language-python"><code>&lt;re.Match object; span=(3, 4), match='z'&gt;
&lt;re.Match object; span=(2, 3), match='z'&gt;</code></pre>
<h2 id="flags-or-modifiers"><strong>标志或修饰符</strong></h2>
<table>
<tbody>
<tr>
<td>
<p><strong>表情</strong></p>
</td>
<td>
<p><strong>解释</strong></p>
</td>
</tr>
<tr>
<td>
<p>a</p>
</td>
<td>
<p>仅匹配ASCII</p>
</td>
</tr>
<tr>
<td>
<p>我</p>
</td>
<td>
<p>忽略大小写</p>
</td>
</tr>
<tr>
<td>
<p>L</p>
</td>
<td>
<p>区域设置字符类</p>
</td>
</tr>
<tr>
<td>
<p>m</p>
</td>
<td>
<p>^和$匹配行的开始和结束(多行)</p>
</td>
</tr>
<tr>
<td>
<p>s</p>
</td>
<td>
<p>匹配包括换行符在内的所有内容</p>
</td>
</tr>
<tr>
<td>
<p>u</p>
</td>
<td>
<p>匹配unicode字符类</p>
</td>
</tr>
<tr>
<td>
<p>x</p>
</td>
<td>
<p>允许空格和注释(详细)</p>
</td>
</tr>
</tbody>
</table>
<p>例如:</p>
<pre class="language-python"><code>import re
exp = """hello you
I am from
Hoolywood"""
print(re.search(r"and", "Sun And Moon", flags=re.IGNORECASE))
print(re.findall(r"^\w", exp, flags = re.MULTILINE))</code></pre>
<p>输出:</p>
<pre class="language-python"><code>&lt;re.Match object; span=(4, 7), match='And'&gt;
['h', 'I', 'H']</code></pre>
<h2 id="conclusion">结论</h2>
<p>在这个正则表达式备忘单中，您将可以访问无数的语法、解释和示例来增强Python正则表达式的学习。</p>
<p>准备好学习所有关于RegEx的知识并充分利用它了吗？<a href="https://hackr.io/tutorials/learn-regular-expressions-regex">上个正则表达式教程！</a></p>
<p>推荐Python课程</p>
<h3 id="recommend-python-course"><a class="btn btn-primary btn-call-to-action " href="https://click.linksynergy.com/deeplink?id=jU79Zysihs4&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fcomplete-python-bootcamp%2F" target="_blank" rel="noopener">用Python完成从零到英雄的Python boot camp</a></h3>
<p> </p>
<p> </p>


									</div>

									</div>    
</body>
</html>